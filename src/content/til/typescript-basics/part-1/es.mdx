---
title: "TypeScript # 1: La Inferencia trabaja por ti"
description: '¬øPor qu√© escribir tipos cuando TypeScript ya los sabe? Entendiendo const vs let y la inferencia autom√°tica.'
lang: 'es'
---
import CodeTabs from '../../../../components/mdx/CodeTabs.astro';
import Callout from '../../../../components/mdx/Callout.astro';
import TSEditor from '../../../../components/learn/TSEditor.tsx';

export const age = new Date().getFullYear() - 1985

## ¬°Bienvenido! üöÄ

Esta es la primera parte de una serie que intentar√° que entendamos TypeScript _**de verdad**_, no solo para que copiemos y 
peguemos "any" cuando el compilador se queja.

El objetivo de la serie completa es terminar comprendiendo que TypeScript no 
es solo JavaScript con tipado, sino que TypeScript es un protolenguaje de tipados para crear toda estructura de 
tipos que necesitemos para nuestros proyectos y hacer que aunque s√≠, todo sea m√°s lento y pesado con las malditas üëπ advertencias, 
al final ganemos en seguridad y robustez de c√≥digo.

Yo no soy ning√∫n experto, pero siempre he pensado que para aprender lo mejor es tratar de ense√±ar a otros. 
Esto nos obliga a abordar cada tema de forma que cualquiera pueda entenderlos y verlo desde muchas perspectivas.

Por eso, en esta serie voy a intentar explicar cada concepto desde cero, sin usar t√©rminos t√©cnicos complejos, 
sin usar lenguaje t√©cnico que solo los que ya saben TypeScript entiendan.

Lo primero por lo que empezaremos es entender que **TypeScript es listo. No hay que explicarle lo obvio.**

<Callout type="info" title="Info" filled>
    Nota: Esta es la primera entrada de una serie de TIL sobre aprendizaje. Aunque es distinto al resto de TIL que son notas 
cortas he pensado en reutilizarlo porque al fin y al cabo sigue la misma idea de algo que aprendemos d√≠a a d√≠a.
Por ahora esto es un experimento.
</Callout>

## La Inferencia de Tipos

Muchos devs que venimos de lenguajes fuertemente tipados (como C, Java o C# antiguos) es normal que estemos 
acostumbrados a la idea de tiparlo todo.

<CodeTabs
  status="error"
  items={[
    {
		label: 'example.ts',
		code: `// ‚ùå Redundante (Boilerplate innecesario)
const userName: string = "Denis";
const userAge: number = ${age};
const isAdmin: boolean = true;`,
		lang: 'typescript'
    }
]} />

TypeScript ya sabe que "Denis" es un string. No hace falta que se lo jures.



<CodeTabs
  status="success"
  items={[
  {
    label: 'example.ts',
    code: `// ‚úÖ Perfecto (Limpio y legible)
const userName = "Denis"; // TS infiere: string (o literal "Denis", veremos esto luego)
const userAge = ${age};       // TS infiere: number
const isAdmin = true;     // TS infiere: boolean`,
    lang: 'typescript'
    }
  ]} />

Esto se llama **Inferencia de Tipos**. Dejamos que TS deduzca el tipo por el valor inicial.

## `const` vs `let`: La diferencia clave

Aqu√≠ es donde la cosa se pone interesante y donde TS brilla.

### Con `let` (Variables mutables)
Cuando usamos `let`, TS asume que vamos a cambiar el valor, as√≠ que infiere el tipo primitivo "general".

<CodeTabs items={[
  {
  label: 'TypeScript',
  code: `// TS con esto entiende: "Ah, 'status' es un STRING y adem√°s cambiar√° a cualquier otro string".
let status = "pending";

status = "success"; // ‚úÖ Bien
status = "error";   // ‚úÖ Bien

status = 123;       // ‚ùå Si lo intentas te devolver√° un error.
// No puedes meter un n√∫mero en un string.`,
  lang: 'typescript'
  }
]} />

### Con `const` (Constantes)
Cuando usamos `const`, TS sabe que ese valor **nunca va a cambiar**. As√≠ que puede ser mucho m√°s espec√≠fico.

<CodeTabs items={[
  {
    label: 'TypeScript',
    code: `const method = "GET";
// TS dice: "Esto no es solo un string. Es EL string 'GET'".
// El tipo literal es "GET".
`,
  lang: 'typescript'
  }
]} />

Esto parece una tonter√≠a ahora, pero es la base para entender por qu√© a veces TS se queja de que `"GET"` no es asignable a `string` (o viceversa) en configuraciones complejas.

## Cu√°ndo S√ç anotar tipos

Entonces, si TS lo infiere, ¬ønunca es necesario poner tipos? No, hay casos donde es necesario:

1.  **Cuando la inferencia falla o es muy amplia**:

Desde nuestro punto de vista, dejar√≠amos que TS infiera any (o lo pondr√≠amos nosotros mismos) en casos en que no sepamos 
lo que va a pasar, sea por errores o que la respuesta pueda ser muy amplia.

<CodeTabs items={[
  {
    label: 'TypeScript',
    code: `// TS infiere 'any' si no est√° configurado en modo 'strict' (que te obliga a anotar tipos siempre)
let data; 
data = fetchSomething(); // Puedes pasarle lo que quieras y TS no se queja.`,
    lang: 'typescript'
  }
]} />

Pero ojo con any, porque le estamos quitando a TS todo su prop√≥sito. Lo ideal ser√≠a no vernos obligados a utilizarlo.

2.  **En par√°metros de funciones** (¬°Aqu√≠ es obligatorio!):

<CodeTabs items={[
  {
    label: 'TypeScript',
    code: `// ‚ùå TS no puede leer tu mente ni saber qui√©n llamar√° a esto
function greet(person) {
    ...
}

// ‚úÖ Aqu√≠ defines el contrato
function greet(person: string) {
    ...
}`, 
    lang: 'typescript'
  }
]} />

3.  **Para definir contratos de retorno expl√≠citos**:
    A veces queremos asegurarnos de que nuestra funci√≥n devuelve X, aunque infiera Y.

## Resumen de la Parte 1

*   **Menos es m√°s**: Si TS puede inferirlo, no lo escribamos. Nuestro c√≥digo ser√° m√°s limpio.
*   **Variable (`let`)** = Tipo General (`string`, `number`).
*   **Constante (`const`)** = Tipo Literal (El valor exacto).

En la **Parte 2**, miraremos c√≥mo usar esos tipos literales a nuestro favor con las **Uniones**, y c√≥mo decirle a TS: *"Esta variable solo puede ser 'admin' o 'user', nada m√°s"*.

## ¬°Experimentemos!

Aqu√≠ tenemos un editor de TypeScript real corriendo en el navegador para probar lo aprendido.

<TSEditor
  client:only="react"
  showConsole={true}
  allowAddFile={false}
  files={{
    'main.ts': `console.log("Hello world!");
`
  }}
/>
