---
title: 'TypeScript # 2: Tipos Literales y Uniones'
description: 'C√≥mo decirle a TypeScript que algo solo puede ser "A" o "B" y nada m√°s. Adi√≥s a los strings m√°gicos.'
lang: 'es'
---
import CodeTabs from '../../../../components/mdx/CodeTabs.astro';
import Callout from '../../../../components/mdx/Callout.astro';
import TSEditor from '../../../../components/learn/TSEditor.tsx';

En la Parte 1 vimos que `const` crea tipos **literales**.
Si escribes `const rol = "admin"`, para TypeScript `rol` no es un simple `string`, sino que es espec√≠ficamente `"admin"`.

Hoy vamos a ver c√≥mo usar eso para crear c√≥digo a prueba de balas.

## String vs. String Literal

Imagina que tienes una funci√≥n para pintar un bot√≥n.

<CodeTabs
  status="error"
  items={[
    {
		label: 'TypeScript',
		code: `function pintarBoton(color: string) {
    if (color === 'tojo') { // ‚ùå Ups, error de dedo ("tojo" en vez de "rojo")
        return 'üî¥';
    }
    return 'üîµ';
}

pintarBoton("azul"); // ‚úÖ Bien
pintarBoton("patata ü•î"); // ‚úÖ Bien (pero no deber√≠a, ¬°patata no es un color!)`,
		lang: 'typescript'
    }
]} />

El problema aqu√≠ es que `string` es **demasiado amplio**. Admite "azul", "rojo", y tambi√©n "patata ü•î" o "asdfg".

## La Uni√≥n de Tipos

Aqu√≠ es donde entra el operador `|` (pipe). Se lee como **"O"**.
Podemos decirle a TypeScript: *"El color solo puede ser 'rojo' O 'azul' O 'verde'"*.

<CodeTabs
  status="success"
  items={[
  {
    label: 'TypeScript',
    code: `type ColorBoton = "rojo" | "azul" | "verde";

function pintarBoton(color: ColorBoton) {
    // ...
}

pintarBoton("rojo");   // ‚úÖ Perfecto
pintarBoton("verde");  // ‚úÖ Perfecto
pintarBoton("patata ü•î");
// ‚ùå Error: Argument of type '"patata ü•î"' is not assignable to parameter of type 'ColorBoton'.`,
    lang: 'typescript'
    }
  ]} />

¬°Bum! üí• Acabas de eliminar una categor√≠a entera de bugs. Ya nadie puede pasar una cadena incorrecta a tu funci√≥n.

## El Autocompletado (IntelliSense)

Lo mejor de esto no es solo la seguridad, es la **experiencia de desarrollo**.

**Pru√©balo t√∫ mismo:** Ponte entre las comillas y pulsa Ctrl + Espacio en cada una. En la primera no hay sugerencias (es un `string` gen√©rico). En la segunda el editor te sugiere las opciones v√°lidas.

<div className="mb-8">
  <TSEditor
    client:only="react"
    height="280px"
    files={{
      'sin-tipos.ts': `// Sin autocompletado - acepta cualquier string
  function enviarString(mensaje: string) {
      console.log("Mensaje:", mensaje);
  }

  // Ponte entre las comillas y pulsa Ctrl + Espacio, ver√°s que NO te salen las sugerencias
  enviarString("");
  `,
      'con-tipos.ts': `// Con autocompletado - solo valores espec√≠ficos
  type Respuesta = "yes" | "no" | "maybe";

  function enviarRespuesta(respuesta: Respuesta) {
      console.log("Tu respuesta:", respuesta);
  }

  // Aqu√≠ S√ç te saldr√°n sugerencias, adem√°s TS ya te avisa de un error, 
  // ya que un string vac√≠o no es un valor que hayamos configurado como v√°lido
  enviarRespuesta("");
  `
    }}
/>
</div>

No tienes que ir a la documentaci√≥n para saber qu√© valores aceptaba. El propio tipo te dice qu√© valores acepta.

## Uniones Mixtas

Puedes mezclar tipos si quieres (aunque √∫salo con cabeza):

<CodeTabs items={[
  {
  label: 'TypeScript',
  code: `// Un ID puede ser un n√∫mero (ID de base de datos) o un string (UUID)
type ID = number | string;

function buscarUsuario(id: ID) {
    console.log("Buscando usuario con ID:", id);
}

buscarUsuario(123); // ‚úÖ
buscarUsuario("abc-123"); // ‚úÖ`,
  lang: 'typescript'
  }
]} />

## Resumen

*   **Tipos Literales**: Valores exactos (`"rojo"`, `1`).
*   **Uniones (`|`)**: Combinar tipos (`A | B` significa A o B).
*   √ösalo para evitar "Magic Strings" y ganar autocompletado gratis.

En la pr√≥xima parte veremos c√≥mo **Tipar Objetos** e Interfaces para dejar de pasar objetos 
an√≥nimos sin control por nuestra aplicaci√≥n.
