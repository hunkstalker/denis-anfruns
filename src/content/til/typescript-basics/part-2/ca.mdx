---
title: 'TypeScript #2: Tipus Literals i Uniones'
description: 'Com dir-li a TypeScript que alguna cosa nom√©s pot ser "A" o "B" i res m√©s. Ad√©u als strings m√†gics.'
series: 'typescript-basics'
seriesTitle: 'TypeScript Basics'
seriesDescription: 'Mini-curs sobre fonaments de TypeScript.'
lang: 'ca'
new: true
---
import CodeTabs from '../../../../components/mdx/CodeTabs.astro';
import Callout from '../../../../components/mdx/Callout.astro';
import TSEditor from '../../../../components/learn/TSEditor.tsx';

A la Part 1 vam veure que `const` crea tipus **literals**.
Si escrius `const rol = "admin"`, per a TypeScript `rol` no √©s un simple `string`, sin√≥ que √©s espec√≠ficament `"admin"`.

Avui veurem com utilitzar aix√≤ per crear codi "bulletproof".

## String vs. String Literal

Imagina que tens una funci√≥ per pintar un bot√≥.

<CodeTabs
  status="error"
  items={[
    {
		label: 'TypeScript',
		code: `function pintarBoto(color: string) {
    if (color === 'vermell') { // ‚ùå Ups, error de dit ("vermell" per√≤ alg√∫ escriu malament)
        return 'üî¥';
    }
    return 'üîµ';
}

pintarBoto("blau"); // ‚úÖ B√©
pintarBoto("patata"); // ‚úÖ B√© (per√≤ no hauria, patata no √©s un color!)`,
		lang: 'typescript'
    }
]} />

El problema aqu√≠ √©s que `string` √©s **massa ampli**. Admet "blau", "vermell", per√≤ tamb√© "patata" o "asdfg".

## La Uni√≥ de Tipus (`|`)

Aqu√≠ √©s on entra l'operador `|` (pipe). Es llegeix com **"O"**.
Podem dir-li a TypeScript: *"El color nom√©s pot ser 'vermell' O 'blau' O 'verd'"*.

<CodeTabs
  status="success"
  items={[
  {
    label: 'TypeScript',
    code: `type ColorBoto = "vermell" | "blau" | "verd";

function pintarBoto(color: ColorBoto) {
    // ...
}

pintarBoto("vermell");   // ‚úÖ Perfecte
pintarBoto("verd");  // ‚úÖ Perfecte
pintarBoto("patata"); // ‚ùå Error: Argument of type '"patata"' is not assignable to parameter of type 'ColorBoto'.`,
    lang: 'typescript'
    }
  ]} />

Bum! üí• Acabes d'eliminar una categoria sencera de bugs. Ja ning√∫ pot passar una cadena incorrecta a la teva funci√≥.

## L'Autocompletat (IntelliSense)

El millor d'aix√≤ no √©s nom√©s la seguretat, √©s l'**experi√®ncia de desenvolupament**.
Quan escriguis `pintarBoto("...` el teu editor et suggerir√† autom√†ticament:
*   "blau"
*   "vermell"
*   "verd"

No has d'anar a la documentaci√≥ per saber quins valors acceptava. El mateix tipus ET DIU quins valors accepta.

## Uniones Mixtes

Pots barrejar tipus si vols (encara que fes-ho amb cap):

<CodeTabs items={[
  {
  label: 'TypeScript',
  code: `// Un ID pot ser un n√∫mero (ID de base de dades) o un string (UUID)
type ID = number | string;

function buscarUsuari(id: ID) {
    console.log("Buscant usuari amb ID:", id);
}

buscarUsuari(123); // ‚úÖ
buscarUsuari("abc-123"); // ‚úÖ`,
  lang: 'typescript'
  }
]} />

## Resum

*   **Tipus Literals**: Valors exactes (`"vermell"`, `1`).
*   **Unions (`|`)**: Combinar tipus (`A | B` vol dir A o B).
*   Utilitza-ho per evitar "Magic Strings" i guanyar autocompletat gratis.

A la propera part veurem com **Tipar Objectes** i Interf√≠cies per deixar de passar objectes an√≤nims sense control per la nostra aplicaci√≥.

<TSEditor
  client:only="react"
  showConsole={true}
  files={{
    'main.ts': `type Estat = "carregant" | "exit" | "error";

function mostrarMissatge(estat: Estat) {
    if (estat === "carregant") return "‚è≥ Carregant...";
    if (estat === "exit") return "‚úÖ Fet!";
    return "‚ùå Error";
}

console.log(mostrarMissatge("exit"));
// Intenta canviar "exit" per "patata" i mira qu√® passa
`
  }}
/>
