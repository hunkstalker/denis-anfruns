---
title: 'TypeScript # 3: Objetos e Interfaces'
description: 'C√≥mo dar forma a tus datos. Interfaces, Types y por qu√© "any" es tu enemigo.'
lang: 'es'
---
import CodeTabs from '../../../../components/mdx/CodeTabs.astro';
import Callout from '../../../../components/mdx/Callout.astro';
import TSEditor from '../../../../components/learn/TSEditor.tsx';

Hasta ahora hemos visto tipos primitivos (`string`, `number`, `boolean`). Pero el mundo real funciona con **objetos**.
Usuarios, Productos, Pedidos... todos son objetos con m√∫ltiples propiedades.

## La Anarqu√≠a de los Objetos An√≥nimos

En JavaScript puro, solemos pasar objetos de un lado a otro confiando en nuestra memoria.

<CodeTabs
  status="error"
  items={[
    {
		label: 'JavaScript (Anarqu√≠a)',
		code: `function imprimirUsuario(usuario) {
    // ü§û Esperemos que 'usuario' tenga estas propiedades...
    console.log("Nombre: " + usuario.name.toUpperCase());
    console.log("Edad: " + usuario.age);
}

// Un mes despu√©s, alguien llama a la funci√≥n as√≠:
imprimirUsuario({ nombre: "Denis", edad: 40 }); 
// üí• CRASH: Cannot read properties of undefined (reading 'toUpperCase')
// ¬øPor qu√©? Porque pasamos "nombre" en espa√±ol pero la funci√≥n esperaba "name" en ingl√©s.`,
		lang: 'javascript'
    }
]} />

TypeScript evita esto oblig√°ndote a definir la **FORMA** (Shape) de tus objetos.

## Interfaces: El Contrato

Una `interface` es como un contrato. Si un objeto dice ser un `Usuario`, **DEBE** cumplir el contrato.

<CodeTabs
  status="success"
  items={[
    {
		label: 'TypeScript',
		code: `interface Usuario {
    name: string;
    age: number;
    isDeveloper: boolean;
}

const denis: Usuario = {
    name: "Denis",
    age: 39,
    isDeveloper: true
}; // ‚úÖ Cumple el contrato

const pepe: Usuario = {
    name: "Pepe"
}; // ‚ùå Error: Faltan las propiedades 'age' e 'isDeveloper'`,
		lang: 'typescript'
    }
]} />

## Propiedades Opcionales (`?`)

A veces no tenemos todos los datos. Quiz√°s el `email` es opcional.
Para eso usamos el signo de interrogaci√≥n `?` despu√©s del nombre de la propiedad.

<CodeTabs items={[
    {
		label: 'TypeScript',
		code: `interface Producto {
    id: number;
    nombre: string;
    descripcion?: string; // üëà Opcional (string | undefined)
}

const mesa: Producto = {
    id: 1,
    nombre: "Mesa de escritorio"
    // No hace falta poner descripci√≥n
};`,
		lang: 'typescript'
    }
]} />

## Propiedades de Solo Lectura (`readonly`)

Si quieres asegurarte de que una propiedad **nunca cambie** despu√©s de crear el objeto (como un ID), usa `readonly`.

<CodeTabs items={[
    {
		label: 'TypeScript',
		code: `interface Configuracion {
    readonly apiKey: string;
    theme: "light" | "dark";
}

const config: Configuracion = {
    apiKey: "xyz-123",
    theme: "light"
};

config.theme = "dark"; // ‚úÖ Puedes cambiarlo
config.apiKey = "abc-999"; // ‚ùå Error: Cannot assign to 'apiKey' because it is a read-only property.`,
		lang: 'typescript'
    }
]} />

## ¬ø`type` vs `interface`?

Ver√°s gente usando `type Usuario = { ... }` en lugar de `interface Usuario { ... }`.
Para definir la forma de un objeto, ambos funcionan casi igual.

> **Regla de oro (por ahora):**
> *   Usa **`interface`** para definir objetos que representan entidades (Usuario, Post, Producto).
> *   Usa **`type`** para Uniones (`string | number`), primitivos o tuplas.

En la Parte 8 profundizaremos en las diferencias t√©cnicas, pero por ahora qu√©date con eso.

## ¬°Int√©ntalo t√∫!

Crea una interfaz `Videojuego` con:
1. `titulo` (string)
2. `a√±o` (number)
3. `plataforma` (opcional)

Y crea una variable que use esa interfaz.

<TSEditor
  client:only="react"
  showConsole={true}
  files={{
    'main.ts': `// define tu interface aqu√≠

const miJuego = {
    
};

console.log(miJuego);`
  }}
/>

En la **Parte 4**, veremos qu√© pasa cuando tenemos muchos objetos iguales... es decir, **Arrays**.
