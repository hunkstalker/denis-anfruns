---
title: Sistema de Metadatos Autom치tico y DRY en Astro
lang: es
slug: astro-metadata-system
---
import Callout from '@components/mdx/Callout.astro';

En este TIL vamos a destripar c칩mo funciona el sistema de gesti칩n de metadatos que utilizamos en este proyecto. Si te has fijado, nuestros archivos Markdown (`.mdx`) est치n inusualmente limpios de frontmatter repetitivo. Esto no es magia, es ingenier칤a (bueno, un poco de magia de scripts s칤 que es).

## El Problema: Duplicidad en i18n

Cuando trabajas con internacionalizaci칩n (i18n) en Astro utilizando *Content Collections*, lo est치ndar es tener un archivo por idioma. Por ejemplo:

```text
src/content/blog/
  my-post-es.md
  my-post-en.md
  my-post-ca.md
```

El problema surge cuando tienes que mantener los metadatos sincronizados. 쯃a fecha de publicaci칩n? La misma en los tres. 쯃a imagen de portada? La misma. 쯃os tags? Los mismos (o casi).

Si decides cambiar la imagen de portada, tienes que editar 3 archivos. Si te equivocas en la fecha en uno, tienes inconsistencias. **Repetir c칩digo (o datos) viola el principio DRY (Don't Repeat Yourself)** y es una fuente de errores humanos garantizada.

## La Soluci칩n: Arquitectura de Carpetas y `meta.json`

En lugar de archivos sueltos, adoptamos una estructura de carpetas por contenido:

```text
src/content/til/astro-metadata-system/
  meta.json   <-- La Fuente de la Verdad (Datos Comunes)
  es.mdx      <-- Contenido en Espa침ol
  en.mdx      <-- Contenido en Ingl칠s
  ca.mdx      <-- Contenido en Catal치n
```

### 쯈u칠 va d칩nde?

- **`meta.json`**: Contiene todo lo que es agn칩stico del idioma.
    - `pubDate`
    - `updatedDate`
    - `tags`
    - `heroImage`
    - `series` (si pertenece a una)
    - `draft`
- **`*.mdx`**: Contiene solo lo espec칤fico del idioma y lo necesario para que Astro pueda generar el slug.
    - `title`
    - `description`
    - `slug`

## La Magia: Normalizaci칩n Autom치tica

Astro no soporta nativamente leer de un `meta.json` y fusionarlo con el frontmatter de los `.mdx` durante el build... a menos que se lo ense침emos.

Para ello, hemos creado un script: `scripts/normalize-content.mjs`. Este script se ejecuta autom치ticamente antes de que Astro empiece a trabajar (gracias al hook `astro:config:setup` en `astro.config.mjs`).

### 쯈u칠 hace el script?

<Callout type="info" title="Automatizaci칩n">
El script recorre todas tus colecciones de contenido y para cada carpeta realiza tres pasos clave:
</Callout>

<details>
<summary>游늯 Ver c칩digo completo de <code>scripts/normalize-content.mjs</code></summary>

```javascript
// scripts/normalize-content.mjs
import fs from 'fs'
import path from 'path'
import { fileURLToPath } from 'url'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)
const PROJECT_ROOT = path.resolve(__dirname, '..')
const CONTENT_ROOT = path.join(PROJECT_ROOT, 'src', 'content')

// Collections to normalize
const COLLECTIONS = [
	{ name: 'til', isNested: false }, // Flat: til/slug/
	{ name: 'devlog', isNested: true }, // Nested: devlog/series/slug/
]

// ... (configuraci칩n de campos comunes)

async function normalizeCollection(collectionName, isNested) {
	// ... (l칩gica de iteraci칩n de directorios)
    // 1. Cargar o Inicializar meta.json
    // 2. Fusionar datos (meta.json gana)
    // 3. Limpiar archivos MDX
}
// Nota: Puedes ver el archivo completo en el repositorio
```
</details>

1.  **Carga o Crea `meta.json`**:
    Busca si existe el archivo `meta.json`. Si no existe, intenta crearlo extrayendo los datos comunes del archivo `es.mdx` (nuestra fuente de verdad por defecto). Esto facilita migrar contenido viejo al nuevo sistema: simplemente crea la carpeta, mueve los archivos y corre el script. 칄l solito extraer치 las fechas y tags del markdown y los mover치 al JSON.

2.  **Fusiona los Datos**:
    Toma los datos de `meta.json` y los compara con los de `es.mdx`. Si hay datos en el JSON, estos *ganan*. El JSON es la autoridad.

3.  **Limpia los Archivos MDX**:
    Esta es la parte m치s "agresiva" y 칰til. El script reescribe tus archivos `.mdx`. Si encuentra que tienes definido `pubDate` o `tags` dentro del archivo `.mdx` y esos datos ya est치n asegurados en `meta.json`, los **borra del frontmatter del archivo**.
    Esto asegura que **no puedas** tener datos desincronizados accidentalmente. Si intentas a침adir una fecha distinta al `en.mdx`, el script la borrar치 la pr칩xima vez que ejecutes `dev` o `build`, forzando el uso de la fecha centralizada.

### Integraci칩n en `astro.config.mjs`

Para que esto sea transparente, lo inyectamos como una integraci칩n de Astro:

```javascript
// astro.config.mjs
import { normalize } from './scripts/normalize-content.mjs'

export default defineConfig({
  integrations: [
    // ... otros plugins
    {
      name: 'normalize-content',
      hooks: {
        'astro:config:setup': async () => {
          await normalize()
        },
      },
    },
  ],
})
```

Gracias a esto, nunca te olvidas de ejecutarlo. Es parte del ciclo de vida del desarrollo.

## Validaci칩n Robusta: `verify-content.mjs`

La normalizaci칩n ordena los datos, pero 쯤ui칠n asegura que sean correctos? Aqu칤 entra `scripts/verify-content.mjs`.

<details>
<summary>游늯 Ver c칩digo completo de <code>scripts/verify-content.mjs</code></summary>

```javascript
// scripts/verify-content.mjs
import fs from 'fs'
import path from 'path'
// ...
// Helper to recursively find meta.json files
function findMetaFiles(dir, fileList = []) {
    // ...
}

// Main verification
async function verify() {
	console.log('游댌 Iniciando verificaci칩n de contenido...')
    // 1. GLOBAL CHECKS (fechas, tags)
    // 2. SERIES CHECKS (orden de partes)
    // 3. MDX PURITY CHECKS (campos prohibidos)
}
verify()
```
</details>

Este script no modifica nada, solo juzga. Verifica reglas de negocio estrictas:

- **Fechas**: 쮼s `pubDate` una fecha v치lida? 쮼s `updatedDate` posterior a `pubDate`?
- **Series**: Si es un Devlog en serie, verifica que la Parte 1 sea anterior a la Parte 2.
- **Pureza**: En colecciones estrictas como TIL, se asegura de que *realmente* no queden campos prohibidos (como `series` o `draft`) dentro de los `.mdx`. Si el script de normalizaci칩n fallase o alguien editase manualmente ignorando el sistema, este script detendr칤a el CI/CD.

## Conclusi칩n

Este sistema nos permite:
1.  **Escribir menos**: Defines los metadatos una vez.
2.  **Reducir errores**: Imposible tener fechas dispares entre idiomas.
3.  **Migrar f치cil**: El script ayuda a mover contenido legacy al nuevo formato autom치ticamente.
4.  **Dormir tranquilos**: Las validaciones en CI aseguran que todo lo que llega a producci칩n cumple el est치ndar.

Es un ejemplo de c칩mo invertir un poco de tiempo en *tooling* (herramientas internas) ahorra horas de mantenimiento a largo plazo.
