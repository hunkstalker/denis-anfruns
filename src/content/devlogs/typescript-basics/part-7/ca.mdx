---
pubDate: '2025-12-20T10:00:00Z'
tags: ['typescript', 'unknown', 'safety']
draft: true
new: true
title: 'TypeScript #7: Unknown vs Any & Never'
description: Per qu√® 'any' √©s el dimoni i 'unknown' el teu millor amic. Aprenent a escriure codi segur a prova de bombes.
series: typescript-basics
seriesTitle: Fonaments de TypeScript
seriesDescription: Apr√®n TypeScript des de zero aprofundint en conceptes com infer√®ncia i tipus.
lang: ca
---

import CodeTabs from '../../../../components/mdx/CodeTabs.astro';
import Callout from '../../../../components/mdx/Callout.astro';
import TSEditor from '../../../../components/learn/TSEditor.tsx';

A TypeScript existeixen dos "Tipus Superiors" (Top Types) que poden contenir **qualsevol valor**: `any` i `unknown`. Encara que semblen similars, s√≥n oposats en filosofia.

I despr√©s est√† `never`, el tipus que no cont√© **res**. Anem a veure'ls.

## 1. `any`: L'enemic silenci√≥s üòà

`any` √©s b√†sicament "desactivar TypeScript". Quan assignes alguna cosa a `any`, el compilador deixa de comprovar res. Pots accedir a propietats que no existeixen, cridar a la variable com una funci√≥, etc.

<CodeTabs
  status="error"
  items={[
    {
      label: 'any.ts',
      code: `let perill: any = "Hola m√≥n";

// TypeScript NO es queixa de res d'aix√≤:
perill.foo.bar.baz(); 
perill();
const x: number = perill;

// ...per√≤ tot fallar√† en execuci√≥ üí•`,
      lang: 'typescript'
    }
  ]}
/>

<Callout type="error" title="Evita any a tota costa">
Usar `any` contagia el teu codi. Si una funci√≥ retorna `any`, aquesta falta de seguretat es propaga. Usa'l nom√©s quan estiguis migrant codi JS antic o sigui 100% impossible saber el tipus (i tot i aix√≠, prefereix `unknown`).
</Callout>

## 2. `unknown`: L'alternativa segura üõ°Ô∏è

`unknown` √©s com `any`: accepta qualsevol valor. PER√í (i √©s un gran per√≤) **no et deixa fer res amb ell** fins que comprovis qu√® √©s.

T'obliga a usar **Narrowing** (el que vam veure al Cap. #6) abans d'usar-lo.

<CodeTabs
  status="success"
  items={[
    {
      label: 'unknown.ts',
      code: `let segur: unknown = "Hola m√≥n";

// Error: Object is of type 'unknown'.
// segur.toUpperCase(); 

// La forma correcta: Comprovar primer
if (typeof segur === "string") {
  // Ara TS sap que √©s string
  console.log(segur.toUpperCase());
}`,
      lang: 'typescript'
    }
  ]}
/>

Aix√≤ √©s ideal per a respostes d'APIs externes o `JSON.parse()`, on *realment* no saps qu√® vindr√†, per√≤ vols gestionar-ho de forma segura.

## 3. `never`: L'impossible üö´

`never` √©s el tipus per a valors que **mai poden oc√≥rrer**. √âs el tipus de retorn d'una funci√≥ que llan√ßa un error sempre (i per tant mai retorna) o un bucle infinit.

<CodeTabs
  items={[
    {
      label: 'never.ts',
      code: `function error(missatge: string): never {
  throw new Error(missatge);
}
// Aquesta funci√≥ mai retorna "undefined" ni res, 
// la seva execuci√≥ mai acaba exitosament.`,
      lang: 'typescript'
    }
  ]}
/>

### Exhaustiveness Checking (El truc pro)

L'√∫s m√©s potent de `never` √©s assegurar-te que has cobert tots els casos possibles en un `switch` o `uni√≥`.

<CodeTabs
  items={[
    {
      label: 'main.ts',
      code: `type Estat = "Carregant" | "Exit" | "Error";

function getMissatge(s: Estat) {
  switch (s) {
    case "Carregant": return "‚è≥";
    case "Exit": return "‚úÖ";
    case "Error": return "‚ùå";
    default:
      // Si dem√† afegeixes "Inactiu" a Estat, 
      // TS marcar√† error aqu√≠ perqu√® "s" no seria never.
      const _exhaustiveCheck: never = s;
      return _exhaustiveCheck;
  }
}`,
      lang: 'typescript'
    }
  ]}
/>

Si en el futur alg√∫ afegeix `| "Inactiu"` al tipus `Estat` i oblida actualitzar el `switch`, TypeScript llan√ßar√† un error en temps de compilaci√≥ dient que `Type 'string' is not assignable to type 'never'`. M√†gia! ‚ú®

## 4. Exercici: Domant el Desconegut

Anem a posar en pr√†ctica `unknown`. Tens una funci√≥ que rep una dada desconeguda. Per a usar-lo de forma segura, **necessitar√†s aplicar l'apr√®s en el cap√≠tol anterior (Type Guards)**.

La teva missi√≥:
1. Comprovar si √©s un `string`.
2. Si ho √©s, retornar-lo en MAJ√öSCULES.
3. Si NO ho √©s, llan√ßar un error dient exactament: `"No √©s text"`.

import validationCode from './validation.ca.ts?raw';

<TSEditor
  client:only="react"
  validationCode={validationCode}
  showConsole={true}
  successSound="success"
  files={{
    'exercise.ts': `// 1. Afegeix el type unknown

    function safeUpperCase(value: ...): string {

  // TODO: Implementa la l√≤gica aqu√≠...


  // Recorda: unknown t'obliga a comprovar el tipus abans d'usar-lo
  // value.toUpperCase() provocar√† un error si no apliques Type Guard (cap√≠tol #6)
  // JS TIP: per llan√ßar un error, usa 'throw new Error();'

  return "ups"; 
}`
  }}
/>

Amb aix√≤ tanquem el bloc de tipus avan√ßats de seguretat! Ara el teu codi ser√† molt m√©s robust. üõ°Ô∏è

## Resum

*   **`any`**: "M'√©s igual tot, deixa'm en pau". (Insegur, evita'l).
*   **`unknown`**: "No em refio de tu, ensenya'm el teu DNI". (Segur, obliga a verificar).
*   **`never`**: "Aix√≤ no hauria de passar". (Usat per a codi inabastable).
