---
pubDate: '2025-12-20T10:00:00Z'
tags: ['typescript', 'unknown', 'safety']
draft: true
new: true
title: 'TypeScript #7: Unknown vs Any & Never'
description: Por qu√© 'any' es el diablo y 'unknown' tu mejor amigo. Aprendiendo a escribir c√≥digo seguro a prueba de bombas.
series: typescript-basics
seriesTitle: Fundamentos de TypeScript
seriesDescription: Aprende TypeScript desde cero profundizando en conceptos como inferencia y tipos.
lang: es
---

import CodeTabs from '../../../../components/mdx/CodeTabs.astro';
import Callout from '../../../../components/mdx/Callout.astro';
import TSEditor from '../../../../components/learn/TSEditor.tsx';

En TypeScript existen dos "Tipos Superiores" (Top Types) que pueden contener **cualquier valor**: `any` y `unknown`. Aunque parecen similares, son opuestos en filosof√≠a.

Y luego est√° `never`, el tipo que no contiene **nada**. Vamos a verlos.

## 1. `any`: El enemigo silencioso üòà

`any` es b√°sicamente "desactivar TypeScript". Cuando asignas algo a `any`, el compilador deja de comprobar nada. Puedes acceder a propiedades que no existen, llamar a la variable como una funci√≥n, etc.

<TSEditor
  client:visible
  id="types-any"
  files={{
    'main.ts': `let peligro: any = "Hola mundo";

// TypeScript NO se queja de nada de esto:
peligro.foo.bar.baz(); 
peligro();
const x: number = peligro;

// ...pero todo fallar√° en ejecuci√≥n üí•`
  }}
/>

<Callout type="error" title="Evita any a toda costa">
Usar `any` contagia tu c√≥digo. Si una funci√≥n devuelve `any`, esa falta de seguridad se propaga. √ösalo solo cuando est√©s migrando c√≥digo JS antiguo o sea 100% imposible saber el tipo (y aun as√≠, prefiere `unknown`).
</Callout>

## 2. `unknown`: La alternativa segura üõ°Ô∏è

`unknown` es como `any`: acepta cualquier valor. PERO (y es un gran pero) **no te deja hacer nada con √©l** hasta que compruebes qu√© es.

Te obliga a usar **Narrowing** (lo que vimos en el Cap. #6) antes de usarlo.

<TSEditor
  client:visible
  id="types-unknown"
  files={{
    'main.ts': `let seguro: unknown = "Hola mundo";

// Error: Object is of type 'unknown'.
// seguro.toUpperCase(); 

// La forma correcta: Comprobar primero
if (typeof seguro === "string") {
  // Ahora TS sabe que es string
  console.log(seguro.toUpperCase());
}`
  }}
/>

Esto es ideal para respuestas de APIs externas o `JSON.parse()`, donde *realmente* no sabes qu√© vendr√°, pero quieres manejarlo de forma segura.

## 3. `never`: Lo imposible üö´

`never` es el tipo para valores que **nunca pueden ocurrir**. Es el tipo de retorno de una funci√≥n que lanza un error siempre (y por tanto nunca retorna) o un bucle infinito.

```typescript
function error(mensaje: string): never {
  throw new Error(mensaje);
}
// Esta funci√≥n nunca devuelve "undefined" ni nada, su ejecuci√≥n nunca termina exitosamente.
```

### Exhaustiveness Checking (El truco pro)

El uso m√°s potente de `never` es asegurarte de que has cubierto todos los casos posibles en un `switch` o `ion`.

<TSEditor
  client:visible
  id="types-never-check"
  files={{
    'main.ts': `type Estado = "Cargando" | "Exito" | "Error";

function getMensaje(s: Estado) {
  switch (s) {
    case "Cargando": return "‚è≥";
    case "Exito": return "‚úÖ";
    case "Error": return "‚ùå";
    default:
      // Si ma√±ana a√±ades "Inactivo" a Estado, 
      // TS marcar√° error aqu√≠ porque "s" no ser√≠a never.
      const _exhaustiveCheck: never = s;
      return _exhaustiveCheck;
  }
}`
  }}
/>

Si en el futuro alguien a√±ade `| "Inactivo"` al tipo `Estado` y olvida actualizar el `switch`, TypeScript lanzar√° un error en tiempo de compilaci√≥n diciendo que `Type 'string' is not assignable to type 'never'`. ¬°Magia! ‚ú®

## Resumen

*   **`any`**: "Me da igual todo, d√©jame en paz". (Inseguro, ev√≠talo).
*   **`unknown`**: "No s√© qu√© es esto, as√≠ que te obligar√© a comprobarlo". (Seguro).
*   **`never`**: "Esto no deber√≠a pasar nunca". (√ötil para asegurar l√≥gica exhaustiva).
