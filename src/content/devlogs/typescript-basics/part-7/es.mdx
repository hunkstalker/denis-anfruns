---
description: C√≥mo domar a los Generics para que no acepten "cualquier cosa". Constraints, valores por defecto y el truco de keyof.
draft: true
new: true
lang: es
pubDate: '2025-12-21T10:00:00Z'
seriesDescription: "Aprende TypeScript desde cero profundizando en conceptos como inferencia y tipos."
seriesTitle: "Fundamentos de TypeScript"
tags: ['typescript', 'generics', 'constraints']
title: 'TypeScript #7: Generics Intermedios (Constraints)'
---

import CodeTabs from '../../../../components/mdx/CodeTabs.astro';
import Callout from '../../../../components/mdx/Callout.astro';
import TSEditor from '../../../../components/learn/TSEditor.tsx';

En la parte anterior vimos que `<T>` puede ser cualquier cosa. A veces, eso es **demasiado flexible**.
¬øQu√© pasa si queremos que `T` tenga s√≠ o s√≠ una propiedad `.length`?

## Restricciones (`extends`)

Imaginemos esta funci√≥n:

<CodeTabs
  status="error"
  items={[
    {
		label: 'TypeScript',
		code: `function obtenerLongitud<T>(item: T) {
    return item.length; // ‚ùå Error: Property 'length' does not exist on type 'T'.
}

// TS se queja porque T podr√≠a ser un n√∫mero (que no tiene .length), 
// o un boolean...`,
		lang: 'typescript'
    }
]} />

Para arreglarlo, usamos `extends` para poner una **restricci√≥n** (Constraint).

<CodeTabs
  status="success"
  items={[
    {
		label: 'TypeScript',
		code: `// Le decimos: "T puede ser lo que quieras, PERO debe extender (cumplir) esta forma"
interface TieneLongitud {
    length: number;
}

function obtenerLongitud<T extends TieneLongitud>(item: T) {
    return item.length; // ‚úÖ Ahora TS sabe que existe
}

obtenerLongitud("Hola"); // ‚úÖ string tiene .length
obtenerLongitud([1, 2, 3]); // ‚úÖ array tiene .length
obtenerLongitud(123); // ‚ùå Error: number no tiene .length`,
		lang: 'typescript'
    }
]} />

## Generics con `keyof` (El truco maestro)

Este patr√≥n lo veremos en todas partes. Queremos una funci√≥n que obtenga una propiedad de un objeto de forma segura.

Necesitamos definir dos Generics:
1. `T`: El objeto.
2. `K`: La clave (key). Pero `K` no puede ser cualquier string, debe ser **una key de T**.

<CodeTabs items={[
    {
		label: 'TypeScript',
		code: `function getProperty<T, K extends keyof T>(obj: T, key: K) {
    return obj[key];
}

const developer = {
    name: "BartoloDev",
    language: "TypeScript"
};

getProperty(developer, "name"); // ‚úÖ TS sabe que esto devuelve string
getProperty(developer, "age"); // ‚ùå Error: "age" no es una key de developer`,
		lang: 'typescript'
    }
]} />

## Valores por Defecto (`=`)

Al igual que en las funciones normales (`function suma(a, b = 0)`), los Generics pueden tener valores por defecto.

Esto es muy √∫til para no obligar al usuario a escribir el tipo siempre.

<CodeTabs items={[
    {
		label: 'TypeScript',
		code: `// Si no pasamos T, asumir√© que es 'string'
interface RespuestaAPI<T = string> {
    data: T;
    error: boolean;
}

// Uso sin pasar tipo (usa el default)
const respuestaSimple: RespuestaAPI = {
    data: "Todo ok", // T es string
    error: false
};

// Uso especificando tipo
const respuestaCompleja: RespuestaAPI<number> = {
    data: 200, // T es number
    error: false
};`,
		lang: 'typescript'
    }
]} />

## ¬°Prob√©moslo!

Creemos una funci√≥n `fusionar` que tome dos objetos `obj1` y `obj2` y los combine. Tipemos la funci√≥n usando dos generics `T` y `U`.

<TSEditor
  client:only="react"
  id="ex-generics-constraints"
  showConsole={false}
  defaultMuted={true}
  height="500px"
  files={{
    'main.ts': `// Reto: Modifica 'fusionar' para que SOLO acepte objetos reales.
// 1. A√±ade generics <T, U> a la funci√≥n.
// 2. Usa 'extends object' (en min√∫scula) para restringirlos. 
//      -> Esto bloquear√° n√∫meros, strings y booleanos.
//      -> Si usas 'Object' (may√∫scula), los primitivos se colar√≠an.

function fusionar(obj1: any, obj2: any) {
    return { ...obj1, ...obj2 };
}

const user = { nombre: "BartoloDev" };
const settings = { theme: "dark" };

// ‚úÖ Caso de √©xito (esto funcionar√° siempre):
const resultado = fusionar(user, settings); 
console.log("Resultado:", resultado);

// üß™ Comprobaci√≥n. Esto es lo que queremos evitar, que se pueda colar un n√∫mero.
// Si al descomentar la l√≠nea de abajo sale un error, ¬°has superado el reto!
// fusionar(user, 123);
`
  }}
  validationCode={`
     try {
        if (!/extends\s+object/.test(code)) {
             throw new Error("‚ö†Ô∏è Debes usar 'extends object' (min√∫scula) para bloquear primitivos.");
        }

        // Check if returns intersection (roughly)
        // @ts-ignore
        const res = fusionar({a:1}, {b:2});
        if (res.a !== 1 || res.b !== 2) throw new Error("La l√≥gica de fusi√≥n se ha roto.");

        if (typeof onSuccess === 'function') onSuccess();
        console.log("‚úÖ ¬°Ejercicio Superado! Has creado una funci√≥n robusta.");
        console.log("üîí Has bloqueado exitosamente el paso de tipos primitivos.");

    } catch (e) {
        console.error(e.message);
    }
  `}
/>

En la **Parte 8**, abordaremos una de las mayores confusiones: **Generics en Interfaces vs en Tipos**, y c√≥mo pasar tipos de padres a hijos (prop drilling de tipos).
