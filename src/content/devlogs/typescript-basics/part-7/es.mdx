---
pubDate: '2025-12-20T10:00:00Z'
tags: ['typescript', 'unknown', 'safety']
draft: false
new: true
title: 'TypeScript #7: Unknown vs Any & Never'
description: Por qu√© 'any' es el diablo y 'unknown' tu mejor amigo. Aprendiendo a escribir c√≥digo seguro a prueba de bombas.
series: typescript-basics
seriesTitle: Fundamentos de TypeScript
seriesDescription: Aprende TypeScript desde cero profundizando en conceptos como inferencia y tipos.
lang: es
---

import CodeTabs from '../../../../components/mdx/CodeTabs.astro';
import Callout from '../../../../components/mdx/Callout.astro';
import TSEditor from '../../../../components/learn/TSEditor.tsx';

En TypeScript existen dos "Tipos Superiores" (Top Types) que pueden contener **cualquier valor**: `any` y `unknown`. Aunque parecen similares, son opuestos en filosof√≠a.

Y luego est√° `never`, el tipo que no contiene **nada**. Vamos a verlos.

## 1. `any`: El enemigo silencioso üòà

`any` es b√°sicamente "desactivar TypeScript". Cuando asignas algo a `any`, el compilador deja de comprobar nada. Puedes acceder a propiedades que no existen, llamar a la variable como una funci√≥n, etc.

<CodeTabs
  status="error"
  items={[
    {
      label: 'any.ts',
      code: `let peligro: any = "Hola mundo";

// TypeScript NO se queja de nada de esto:
peligro.foo.bar.baz(); 
peligro();
const x: number = peligro;

// ...pero todo fallar√° en ejecuci√≥n üí•`,
      lang: 'typescript'
    }
  ]}
/>

<Callout type="error" title="Evita any a toda costa">
Usar `any` contagia tu c√≥digo. Si una funci√≥n devuelve `any`, esa falta de seguridad se propaga. √ösalo solo cuando est√©s migrando c√≥digo JS antiguo o sea 100% imposible saber el tipo (y aun as√≠, prefiere `unknown`).
</Callout>

## 2. `unknown`: La alternativa segura üõ°Ô∏è

`unknown` es como `any`: acepta cualquier valor. PERO (y es un gran pero) **no te deja hacer nada con √©l** hasta que compruebes qu√© es.

Te obliga a usar **Narrowing** (lo que vimos en el Cap. #6) antes de usarlo.

<CodeTabs
  status="success"
  items={[
    {
      label: 'unknown.ts',
      code: `let seguro: unknown = "Hola mundo";

// Error: Object is of type 'unknown'.
// seguro.toUpperCase(); 

// La forma correcta: Comprobar primero
if (typeof seguro === "string") {
  // Ahora TS sabe que es string
  console.log(seguro.toUpperCase());
}`,
      lang: 'typescript'
    }
  ]}
/>

Esto es ideal para respuestas de APIs externas o `JSON.parse()`, donde *realmente* no sabes qu√© vendr√°, pero quieres manejarlo de forma segura.

## 3. `never`: Lo imposible üö´

`never` es el tipo para valores que **nunca pueden ocurrir**. Es el tipo de retorno de una funci√≥n que lanza un error siempre (y por tanto nunca retorna) o un bucle infinito.

<CodeTabs
  items={[
    {
      label: 'never.ts',
      code: `function error(mensaje: string): never {
  throw new Error(mensaje);
}
// Esta funci√≥n nunca devuelve "undefined" ni nada, 
// su ejecuci√≥n nunca termina exitosamente.`,
      lang: 'typescript'
    }
  ]}
/>

### Exhaustiveness Checking (El truco pro)

El uso m√°s potente de `never` es asegurarte de que has cubierto todos los casos posibles en un `switch` o `ion`.

<CodeTabs
  items={[
    {
      label: 'main.ts',
      code: `type Estado = "Cargando" | "Exito" | "Error";

function getMensaje(s: Estado) {
  switch (s) {
    case "Cargando": return "‚è≥";
    case "Exito": return "‚úÖ";
    case "Error": return "‚ùå";
    default:
      // Si ma√±ana a√±ades "Inactivo" a Estado, 
      // TS marcar√° error aqu√≠ porque "s" no ser√≠a never.
      const _exhaustiveCheck: never = s;
      return _exhaustiveCheck;
  }
}`,
      lang: 'typescript'
    }
  ]}
/>

Si en el futuro alguien a√±ade `| "Inactivo"` al tipo `Estado` y olvida actualizar el `switch`, TypeScript lanzar√° un error en tiempo de compilaci√≥n diciendo que `Type 'string' is not assignable to type 'never'`. ¬°Magia! ‚ú®

## 4. Ejercicio: Domando lo Desconocido

Vamos a poner en pr√°ctica `unknown`. Tienes una funci√≥n que recibe un dato desconocido. Para usarlo de forma segura, **necesitar√°s aplicar lo aprendido en el cap√≠tulo anterior (Type Guards)**.

Tu misi√≥n:
1.  Comprobar si es un `string`.
2.  Si lo es, devolverlo en MAY√öSCULAS.
3.  Si NO lo es, lanzar un error diciendo exactamente: `"No es texto"`.

import validationCode from './validation.ts?raw';

<TSEditor
  client:only="react"
  validationCode={validationCode}
  showConsole={true}
  successSound="success"
  files={{
    'exercise.ts': `// 1. A√±ade el type unknown

    function safeUpperCase(value: ...): string {

  // TODO: Implementa la l√≥gica aqu√≠...


  // Recuerda: unknown te obliga a comprobar el tipo antes de usarlo
  // value.toUpperCase() provocar√° un error si no aplicas Type Guard (cap√≠tulo #6)
  // JS TIP: para lanzar un error, usa 'throw new Error();'

  return "ups"; 
}`
  }}
/>

¬°Con esto cerramos el bloque de tipos avanzados de seguridad! Ahora tu c√≥digo ser√° mucho m√°s robusto. üõ°Ô∏è

## Resumen

*   **`any`**: "Me da igual todo, d√©jame en paz". (Inseguro, ev√≠talo).
*   **`unknown`**: "No s√© qu√© es esto, as√≠ que te obligar√© a comprobarlo". (Seguro).
*   **`never`**: "Esto no deber√≠a pasar nunca". (√ötil para asegurar l√≥gica exhaustiva).
