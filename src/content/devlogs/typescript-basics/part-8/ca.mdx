---
pubDate: '2025-12-21T10:00:00Z'
tags: ['typescript', 'generics', 'basics']
draft: true
new: true
title: 'TypeScript #8: Generics (El b√†sic)'
description: L'eina m√©s potent de TS. Apr√®n a escriure codi reutilitzable i flexible amb <T>.
series: typescript-basics
seriesTitle: Fonaments de TypeScript
seriesDescription: Apr√®n TypeScript des de zero aprofundint en conceptes com infer√®ncia i tipus.
lang: ca
---

import CodeTabs from '../../../../components/mdx/CodeTabs.astro';
import Callout from '../../../../components/mdx/Callout.astro';
import TSEditor from '../../../../components/learn/TSEditor.tsx';

Fins ara, els nostres tipus eren fixos. `string` √©s sempre `string`.
Per√≤, i si volem crear una funci√≥ o un component que funcioni amb **qualsevol tipus**, per√≤ sense perdre la seguretat?

Aqu√≠ entren els **Generics**. S√≥n com "par√†metres" per√≤ per a Tipus.

## El Problema: Duplicaci√≥ o `any`

Imaginem una funci√≥ que retorna el que li passes (cl√†ssica funci√≥ `identity`).

<CodeTabs
  status="error"
  items={[
    {
		label: 'TypeScript',
		code: `// Opci√≥ 1: Duplicar codi per a cada tipus
function returnString(val: string): string { return val; }
function returnNumber(val: number): number { return val; }

// Opci√≥ 2: Usar 'any' (Perdem el tipus)
function returnAny(val: any): any { return val; }

const resultat = returnAny("Hola"); 
// TS no sap que 'resultat' √©s string, creu que √©s 'any'.
// resultat.toUpperCase(); // ‚ùå No autocompleta`,
		lang: 'typescript'
    }
]} />

## La Soluci√≥: Generics `<T>`

Podem dir-li a la funci√≥: *"Escolta, et passarem un tipus al qual direm `T`. Usa'l per tipar l'argument i el retorn"*.

<CodeTabs
  status="success"
  items={[
    {
		label: 'TypeScript',
		code: `function identity<T>(val: T): T {
    return val;
}

// √ös expl√≠cit (li passem el tipus)
const num = identity<number>(123); // num √©s number

// Infer√®ncia (TS √©s llest i ho endevina)
const str = identity("Hola"); // str √©s "Hola" (literal) o string`,
		lang: 'typescript'
    }
]} />

La `T` √©s una convenci√≥ (ve de *Type*), per√≤ podem dir-li com vulguem: `<Data>`, `<Response>`, `<Props>`.

## Interf√≠cies Gen√®riques

Aix√≤ √©s s√∫per com√∫ en React o respostes d'API.

<CodeTabs items={[
    {
		label: 'TypeScript',
		code: `// Una caixa que pot contenir qualsevol COSA
interface Caixa<T> {
    contingut: T;
    etiqueta: string;
}

const caixaDeSabates: Caixa<string> = {
    contingut: "Nike Air",
    etiqueta: "Esports"
};

const caixaDeRegal: Caixa<number> = {
    contingut: 1000,
    etiqueta: "Diners"
};`,
		lang: 'typescript'
    }
]} />

## Exemple Real: `useState`

Si hem usat React, ja hem usat Generics sense saber-ho.

<CodeTabs items={[
    {
		label: 'tsx',
		code: `// useState √©s una funci√≥ Gen√®rica: function useState<S>(initialState: S | (() => S)): [S, Dispatch<SetStateAction<S>>]

// Infer√®ncia:
const [name, setName] = useState("Alice"); // TS infereix que T √©s string

// Expl√≠cit (√∫til quan el valor inicial √©s null):
const [user, setUser] = useState<Usuari | null>(null);`,
		lang: 'tsx'
    }
]} />

### Provem-ho!

Crea una funci√≥ `envolver` que **posis el que posis**, t'ho retorni dins d'un **array**.
Si poses `10`, surt `[10]`. Si poses `"hola"`, surt `["hola"]`.

import validationCode from './validation.ca.ts?raw';

<TSEditor
  client:only="react"
  id="ex-generics-basic"
  showConsole={true}
  successSound="success"
  defaultMuted={false}
  height="600px"
  files={{
    'main.ts': `// Repte: Crea la funci√≥ gen√®rica 'envolver'
// Ha de rebre un valor de tipus T i retornar un array de T (T[])

function envolver... // Implementa aqu√≠ la teva soluci√≥

// üß™ Proves (No toquis aix√≤):
const n = envolver(10);
const s = envolver("hola");

console.log("N√∫mero embolicat:", n);
console.log("Text embolicat:", s);
`
  }}
  validationCode={validationCode}
/>
