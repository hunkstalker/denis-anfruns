---
pubDate: '2025-12-21T10:00:00Z'
tags: ['typescript', 'generics', 'basics']
draft: true
new: true
title: 'TypeScript #8: Generics (Lo b√°sico)'
description: La herramienta m√°s potente de TS. Aprende a escribir c√≥digo reutilizable y flexible con <T>.
series: typescript-basics
seriesTitle: Fundamentos de TypeScript
seriesDescription: Aprende TypeScript desde cero profundizando en conceptos como inferencia y tipos.
lang: es
---

import CodeTabs from '../../../../components/mdx/CodeTabs.astro';
import Callout from '../../../../components/mdx/Callout.astro';
import TSEditor from '../../../../components/learn/TSEditor.tsx';

Hasta ahora, nuestros tipos eran fijos. `string` es siempre `string`.
Pero, ¬øy si queremos crear una funci√≥n o un componente que funcione con **cualquier tipo**, pero sin perder la seguridad?

Ah√≠ entran los **Generics**. Son como "par√°metros" pero para Tipos.

## El Problema: Duplicaci√≥n o `any`

Imaginemos una funci√≥n que devuelve lo que le pasas (cl√°sica funci√≥n `identity`).

<CodeTabs
  status="error"
  items={[
    {
		label: 'TypeScript',
		code: `// Opci√≥n 1: Duplicar c√≥digo para cada tipo
function returnString(val: string): string { return val; }
function returnNumber(val: number): number { return val; }

// Opci√≥n 2: Usar 'any' (Perdemos el tipo)
function returnAny(val: any): any { return val; }

const resultado = returnAny("Hola"); 
// TS no sabe que 'resultado' es string, cree que es 'any'.
// resultado.toUpperCase(); // ‚ùå No autocompleta`,
		lang: 'typescript'
    }
]} />

## La Soluci√≥n: Generics `<T>`

Podemos decirle a la funci√≥n: *"Oye, vamos a pasarte un tipo al que llamaremos `T`. √ösalo para tipar el argumento y el retorno"*.

<CodeTabs
  status="success"
  items={[
    {
		label: 'TypeScript',
		code: `function identity<T>(val: T): T {
    return val;
}

// Uso expl√≠cito (le pasamos el tipo)
const num = identity<number>(123); // num es number

// Inferencia (TS es listo y lo adivina)
const str = identity("Hola"); // str es "Hola" (literal) o string`,
		lang: 'typescript'
    }
]} />

La `T` es una convenci√≥n (viene de *Type*), pero podemos llamarlo como queramos: `<Data>`, `<Response>`, `<Props>`.

## Interfaces Gen√©ricas

Esto es s√∫per com√∫n en React o respuestas de API.

<CodeTabs items={[
    {
		label: 'TypeScript',
		code: `// Una caja que puede contener cualquier COSA
interface Caja<T> {
    contenido: T;
    etiqueta: string;
}

const cajaDeZapatos: Caja<string> = {
    contenido: "Nike Air",
    etiqueta: "Deportes"
};

const cajaDeRegalo: Caja<number> = {
    contenido: 1000,
    etiqueta: "Dinero"
};`,
		lang: 'typescript'
    }
]} />

## Ejemplo Real: `useState`

Si hemos usado React, ya hemos usado Generics sin saberlo.

<CodeTabs items={[
    {
		label: 'React',
		code: `// useState es una funci√≥n Gen√©rica: function useState<S>(initialState: S | (() => S)): [S, Dispatch<SetStateAction<S>>]

// Inferencia:
const [name, setName] = useState("Alice"); // TS infiere que T es string

// Expl√≠cito (√∫til cuando el valor inicial es null):
const [user, setUser] = useState<Usuario | null>(null);`,
		lang: 'tsx'
    }
]} />

### Uniones vs Generics

Igual has pensado: *"¬øY si uso `string | number` en vez de `<T>`?"*

```typescript
function echo(val: string | number): string | number { return val; }
const res = echo("Hola"); // TS cree que 'res' es 'string | number' ‚ùå
// Perdiste la precisi√≥n: TS ya no sabe que es un string.
```

Con `<T>`, TS mantiene la conexi√≥n: entr√≥ string -> sale string.

---

### ¬°Prob√©moslo!

Crea una funci√≥n `envolver` que **metas lo que metas**, te lo devuelva dentro de un **array**.
Si metes `10`, sale `[10]`. Si metes `"hola"`, sale `["hola"]`.

import validationCode from './validation.ts?raw';

<TSEditor
  client:only="react"
  id="ex-generics-basic"
  showConsole={true}
  successSound="success"
  defaultMuted={false}
  height="600px"
  files={{
    'main.ts': `// Reto: Crea la funci√≥n gen√©rica 'envolver'
// Debe recibir un valor de tipo T y devolver un array de T (T[])

function envolver... // Implementa aqu√≠ tu soluci√≥n

// üß™ Pruebas (No toques esto):
const n = envolver(10);
const s = envolver("hola");

console.log("N√∫mero envuelto:", n);
console.log("Texto envuelto:", s);
`
  }}
  validationCode={validationCode}
/>

En la **Parte 7**, subiremos el nivel. Veremos c√≥mo **restringir** esos Generics (para que no valga "cualquier cosa") y c√≥mo darles valores por defecto.
