---
description: 'La parte dif√≠cil: combinar Generics, Interfaces y Tipos sin volverse loco.'
draft: false
lang: es
new: false
pubDate: '2025-12-22T10:00:00Z'
seriesDescription: {"es": "Aprende TypeScript desde cero profundizando en conceptos como inferencia y tipos.", "en": "Learn TypeScript from scratch diving deep into inference and types."}
seriesTitle: {"es": "Fundamentos de TypeScript", "en": "TypeScript Basics"}
tags: ['typescript', 'generics', 'interfaces']
title: 'TypeScript #8: Mezclando Conceptos (Generics + Interfaces)'
---

import CodeTabs from '../../../../components/mdx/CodeTabs.astro';
import Callout from '../../../../components/mdx/Callout.astro';
import TSEditor from '../../../../components/learn/TSEditor.tsx';

Aqu√≠ es donde mucha gente se pierde. Empezamos a ver `<T>`, `interface`, `type`, `return T`... todo mezclado y parece jerogl√≠fico.

Vamos a desenredarlo paso a paso.

## Generics en Interfaces vs Tipos

¬øCu√°ndo usar uno u otro? La sintaxis es casi id√©ntica.

<CodeTabs items={[
    {
		label: 'TypeScript',
		code: `// Opci√≥n A: Interface Gen√©rica
interface CajaInterface<T> {
    valor: T;
}

// Opci√≥n B: Type Gen√©rico
type CajaType<T> = {
    valor: T;
};

// Se usan IGUAL
const a: CajaInterface<string> = { valor: "Hola" };
const b: CajaType<string> = { valor: "Hola" };`,
		lang: 'typescript'
    }
]} />

No hay diferencia funcional real para datos simples. Usemos la que prefiramos (solemos usar `interface` para objetos y `type` para funciones/uniones).

## El Patr√≥n "Wrapper" (Datawrapper)

Este es el caso de uso #1 en el mundo real: Respuestas de API.
Tenemos una estructura fija (`data`, `status`, `error`) pero el contenido de `data` cambia seg√∫n la llamada.

<CodeTabs items={[
    {
		label: 'TypeScript',
		code: `// Definamos la "c√°scara" gen√©rica
interface ApiResponse<Data> {
    status: number;
    message: string;
    data: Data; // üëà Aqu√≠ va la magia
}

// Definamos nuestros modelos concretos
interface User { id: number; name: string; }
interface Product { sku: string; price: number; }

// ¬°Combin√©moslos!
type UserResponse = ApiResponse<User>;
type ProductResponse = ApiResponse<Product>;

function fetchUser(): UserResponse {
    return {
        status: 200,
        message: "OK",
        data: { id: 1, name: "BartoloDev" } // TS sabe que data es User
    };
}`,
		lang: 'typescript'
    }
]} />

## "Prop Drilling" de Tipos

A veces tenemos Generics dentro de Generics. Es como pasar una variable de un abuelo a un nieto.

<CodeTabs items={[
    {
		label: 'TypeScript',
		code: `interface PaginatedResponse<T> {
    items: T[];       // Array de T
    total: number;
    page: number;
}

// ApiResponse contiene PaginatedResponse, que contiene User
type UsersApi = ApiResponse<PaginatedResponse<User>>;

// Parece complejo, pero TS lo resuelve solo:
// UsersApi = { 
//   status: number,
//   message: string,
//   data: { 
//      items: User[], 
//      total: number,
//      page: number,
//   } 
// }`,
		lang: 'typescript'
    }
]} />

## Generics en Funciones Flecha

La sintaxis aqu√≠ puede llegar a asustar, especialmente en archivos `.tsx` (React) y donde se vuelve m√°s complejo.

<CodeTabs items={[
    {
		label: 'TypeScript',
		code: `// Funci√≥n normal
function identity<T>(arg: T): T { return arg; }

// Funci√≥n flecha
const identityArrow = <T>(arg: T): T => arg;

// ‚ö†Ô∏è En archivos .tsx (React), necesitamos una coma para que no crea que es HTML
const hookEnReact = <T,>(arg: T) => { ... };`,
		lang: 'typescript'
    }
]} />

## ¬°Prob√©moslo!

Creemos una interfaz `Respuesta<T>` con `datos: T` y `error: string | null`.
Luego creemos un objeto que use esa interfaz con `number`.

<TSEditor
  client:only="react"
  id="ex-generics-wrapper"
  showConsole={true}
  successSound="success"
  defaultMuted={false}
  height="600px"
  files={{
    'main.ts': `// Reto: 
// 1. Define una interfaz gen√©rica 'Respuesta' con:
//    - el campo 'datos' que sea de tipo gen√©rico
//    - el campo 'error' que sea de tipo string | null
// 2. Crea un objeto 'acierto' que use nuestra interface gen√©rica con datos=42
// 3. Crea un objeto 'fallo' que use nuestra interface gen√©rica con datos="Ups"

// Escribe tu c√≥digo aqu√≠:
interface Respuesta...

const acierto...
const fallo...
`
  }}
  validationCode={`
     try {
        // 1. Comprobar existencia
        // @ts-ignore
        if (typeof acierto === 'undefined' || typeof fallo === 'undefined') {
            throw new Error("Debes crear las variables 'acierto' y 'fallo'.");
        }

        // 2. Comprobar tipos runtime
        // @ts-ignore
        if (acierto.datos !== 42 || typeof fallo.datos !== 'string') {
             throw new Error("Los valores de 'acierto' o 'fallo' no son los esperados.");
        }

        if (typeof onSuccess === 'function') onSuccess();
        console.log("‚úÖ ¬°Perfecto! Dominas los interfaces gen√©ricos.");
        console.log("Objetos creados correctamente:");
        console.log(JSON.stringify({ acierto, fallo }, null, 2));

    } catch (e) {
        console.error(e.message);
    }
  `}
/>

En la **Parte 9**, vamos a relajarnos un poco y ver los **Utility Types** (`Partial`, `Pick`, `Omit`). Son tipos gen√©ricos que TS ya trae de serie para hacernos la vida m√°s f√°cil.
