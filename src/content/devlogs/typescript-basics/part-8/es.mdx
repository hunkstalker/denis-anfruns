---
description: 'La parte dif√≠cil: combinar Generics, Interfaces y Tipos sin volverse loco.'
draft: true
lang: es
new: false
pubDate: '2025-12-22T10:00:00Z'
seriesDescription: {"es": "Aprende TypeScript desde cero profundizando en conceptos como inferencia y tipos.", "en": "Learn TypeScript from scratch diving deep into inference and types."}
seriesTitle: {"es": "Fundamentos de TypeScript", "en": "TypeScript Basics"}
tags: ['typescript', 'generics', 'interfaces']
title: 'TypeScript #8: Mezclando Conceptos (Generics + Interfaces)'
---

import CodeTabs from '../../../../components/mdx/CodeTabs.astro';
import Callout from '../../../../components/mdx/Callout.astro';
import TSEditor from '../../../../components/learn/TSEditor.tsx';

Aqu√≠ es donde mucha gente se pierde. Empezamos a ver `<T>`, `interface`, `type`, `return T`... todo mezclado y parece jerogl√≠fico.

Vamos a desenredarlo paso a paso.

## Generics en Interfaces vs Tipos

¬øCu√°ndo usar uno u otro? La sintaxis es casi id√©ntica.

<CodeTabs items={[
    {
		label: 'TypeScript',
		code: `// Opci√≥n A: Interface Gen√©rica
interface CajaInterface<T> {
    valor: T;
}

// Opci√≥n B: Type Gen√©rico
type CajaType<T> = {
    valor: T;
};

// Se usan IGUAL
const a: CajaInterface<string> = { valor: "Hola" };
const b: CajaType<string> = { valor: "Hola" };`,
		lang: 'typescript'
    }
]} />

No hay diferencia funcional real para datos simples. Usemos la que prefiramos (solemos usar `interface` para objetos y `type` para funciones/uniones).

## El Patr√≥n "Wrapper" (Datawrapper)

Este es el caso de uso #1 en el mundo real: Respuestas de API.
Tenemos una estructura fija (`data`, `status`, `error`) pero el contenido de `data` cambia seg√∫n la llamada.

<CodeTabs items={[
    {
		label: 'TypeScript',
		code: `// Definamos la "c√°scara" gen√©rica
interface ApiResponse<Data> {
    status: number;
    message: string;
    data: Data; // üëà Aqu√≠ va la magia
}

// Definamos nuestros modelos concretos
interface User { id: number; name: string; }
interface Product { sku: string; price: number; }

// ¬°Combin√©moslos!
type UserResponse = ApiResponse<User>;
type ProductResponse = ApiResponse<Product>;

function fetchUser(): UserResponse {
    return {
        status: 200,
        message: "OK",
        data: { id: 1, name: "Denis" } // TS sabe que data es User
    };
}`,
		lang: 'typescript'
    }
]} />

## "Prop Drilling" de Tipos

A veces tenemos Generics dentro de Generics. Es como pasar una variable de un abuelo a un nieto.

<CodeTabs items={[
    {
		label: 'TypeScript',
		code: `interface PaginatedResponse<T> {
    items: T[];       // Array de T
    total: number;
    page: number;
}

// ApiResponse contiene PaginatedResponse, que contiene User
type UsersApi = ApiResponse<PaginatedResponse<User>>;

// Parece complejo, pero TS lo resuelve solo:
// UsersApi = { 
//   status: number, 
//   data: { 
//      items: User[], 
//      total: number 
//   } 
// }`,
		lang: 'typescript'
    }
]} />

## Generics en Funciones Flecha

La sintaxis aqu√≠ puede llegar a asustar, especialmente en archivos `.tsx` (React) y donde se vuelve m√°s complejo.

<CodeTabs items={[
    {
		label: 'TypeScript',
		code: `// Funci√≥n normal
function identity<T>(arg: T): T { return arg; }

// Funci√≥n flecha
const identityArrow = <T>(arg: T): T => arg;

// ‚ö†Ô∏è En archivos .tsx (React), necesitamos una coma para que no crea que es HTML
const hookEnReact = <T,>(arg: T) => { ... };`,
		lang: 'typescript'
    }
]} />

## ¬°Prob√©moslo!

Creemos una interfaz `Respuesta<T>` con `datos: T` y `error: string | null`.
Luego creemos un objeto que use esa interfaz con `number`.

<TSEditor
  client:only="react"
  showConsole={true}
  files={{
    'main.ts': `// Nuestro c√≥digo aqu√≠

`
  }}
/>

En la **Parte 9**, vamos a relajarnos un poco y ver los **Utility Types** (`Partial`, `Pick`, `Omit`). Son tipos gen√©ricos que TS ya trae de serie para hacernos la vida m√°s f√°cil.
