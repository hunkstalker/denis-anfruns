---
pubDate: '2025-12-22T10:00:00Z'
tags: ['typescript', 'generics', 'constraints']
draft: true
new: true
title: 'TypeScript #9: Generics Intermedis (Constraints)'
description: Com domar els Generics perqu√® no acceptin "qualsevol cosa". Constraints, valors per defecte i el truc de keyof.
series: typescript-basics
seriesTitle: Fonaments de TypeScript
seriesDescription: Apr√®n TypeScript des de zero aprofundint en conceptes com infer√®ncia i tipus.
lang: ca
---

import CodeTabs from '../../../../components/mdx/CodeTabs.astro';
import Callout from '../../../../components/mdx/Callout.astro';
import TSEditor from '../../../../components/learn/TSEditor.tsx';

A la part anterior vam veure que `<T>` pot ser qualsevol cosa. A vegades, aix√≤ √©s **massa flexible**.
Qu√® passa si volem que `T` tingui s√≠ o s√≠ una propietat `.length`?

## Restriccions (`extends`)

Imaginem aquesta funci√≥:

<CodeTabs
  status="error"
  items={[
    {
		label: 'TypeScript',
		code: `function getLength<T>(item: T) {
    return item.length; // ‚ùå Error: Property 'length' does not exist on type 'T'.
}

// TS es queixa perqu√® T podria ser un n√∫mero (que no t√© .length), 
// o un boolean...`,
		lang: 'typescript'
    }
]} />

Per arreglar-ho, usem `extends` per posar una **restricci√≥** (Constraint).

<CodeTabs
  status="success"
  items={[
    {
		label: 'TypeScript',
		code: `// Li diem: "T pot ser el que vulguis, PER√í ha d'estendre (complir) aquesta forma"
interface TeLongitud {
    length: number;
}

function getLength<T extends TeLongitud>(item: T) {
    return item.length; // ‚úÖ Ara TS sap que existeix
}

getLength("Hola"); // ‚úÖ string t√© .length
getLength([1, 2, 3]); // ‚úÖ array t√© .length
getLength(123); // ‚ùå Error: number no t√© .length`,
		lang: 'typescript'
    }
]} />

## Generics amb `keyof` (El truc mestre)

Aquest patr√≥ el veurem a tot arreu. Volem una funci√≥ que obtingui una propietat d'un objecte de forma segura.

Necessitem definir dos Generics:
1. `T`: L'objecte.
2. `K`: La clau (key). Per√≤ `K` no pot ser qualsevol string, ha de ser **una key de T**.

<CodeTabs items={[
    {
		label: 'TypeScript',
		code: `function getProperty<T, K extends keyof T>(obj: T, key: K) {
    return obj[key];
}

const developer = {
    name: "AliceDev",
    language: "TypeScript"
};

getProperty(developer, "name"); // ‚úÖ TS sap que aix√≤ retorna string
getProperty(developer, "age"); // ‚ùå Error: "age" no √©s una key de developer`,
		lang: 'typescript'
    }
]} />

## Valors per Defecte (`=`)

Igual que en les funcions normals (`function suma(a, b = 0)`), els Generics poden tenir valors per defecte.

Aix√≤ √©s molt √∫til per no obligar l'usuari a escriure el tipus sempre.

<CodeTabs items={[
    {
		label: 'TypeScript',
		code: `// Si no passem T, assumir√© que √©s 'string'
interface RespostaAPI<T = string> {
    data: T;
    status: number;
}

// √ös sense arguments:
const simple: RespostaAPI = { data: "Hola", status: 200 }; // T √©s string

// √ös amb arguments:
const complex: RespostaAPI<number> = { data: 123, status: 200 }; // T √©s number`,
		lang: 'typescript'
    }
]} />

### Provem-ho!

Creem una funci√≥ `fusionar` que prengui dos objectes `obj1` i `obj2` i els combini. Tipem la funci√≥ usant dos generics `T` i `U`.

import validationCode from './validation.ca.ts?raw';

<TSEditor
  client:only="react"
  id="ex-generics-constraints"
  showConsole={false}
  defaultMuted={true}
  height="500px"
  files={{
    'main.ts': `// Repte: Modifica 'fusionar' perqu√® NOM√âS accepti objectes reals.
// 1. Afegeix generics <T, U> a la funci√≥.
// 2. Usa 'extends object' (en min√∫scula) per restringir-los. 
//      -> Aix√≤ bloquejar√† n√∫meros, strings i booleans.
//      -> Si uses 'Object' (maj√∫scula), els primitius es colarien.

function fusionar(obj1: any, obj2: any) {
    return { ...obj1, ...obj2 };
}

const user = { nombre: "AliceDev" };
const settings = { theme: "dark" };

// ‚úÖ Cas d'√®xit (aix√≤ funcionar√† sempre):
const resultat = fusionar(user, settings); 
console.log("Resultat:", resultat);

// üß™ Comprovaci√≥. Aix√≤ √©s el que volem evitar, que es pugui colar un n√∫mero.
// Si en descomentar la l√≠nia de sota surt un error, has superat el repte!
// fusionar(user, 123);
`
  }}
  validationCode={validationCode}
/>
