---
title: 'TypeScript #4: Arrays y Tuplas'
description: Listas de cosas y la magia de las Tuplas (o por qué useState devuelve un array).
pubDate: '2025-12-17T18:00:00Z'
tags: ['typescript', 'series']
lang: en
series: typescript-basics
seriesTitle: {"es":"Fundamentos de TypeScript","en":"TypeScript Basics"}
seriesDescription: {"es":"Aprende TypeScript desde cero profundizando en conceptos como inferencia y tipos.","en":"Learn TypeScript from scratch diving deep into inference and types."}
new: true
draft: false
---

import CodeTabs from '../../../../components/mdx/CodeTabs.astro';
import Callout from '../../../../components/mdx/Callout.astro';
import TSEditor from '../../../../components/learn/TSEditor.tsx';

In the previous part we saw Objects. Now, what happens if we have **many** objects? We need a list.

## Arrays `[]`

There are two ways to define an array in TypeScript. Both are identical, it's just a matter of taste.

<CodeTabs
  status="success"
  items={[
    {
		label: 'TypeScript',
		code: `// Option A: Type[] (Most common)
const skills: string[] = ["React", "Astro", "TypeScript"];

// Option B: Array<Type> (Generic Syntax)
const years: Array<number> = [2020, 2021, 2022];

// Object Array (using the interface from previous part)
interface User {
    name: string;
    age: number;
}

const users: User[] = [
    { name: "Denis", age: 39 },
    { name: "Pepe", age: 25 }
];`,
		lang: 'typescript'
    }
]} />

If we try to put a number into our `skills` array (which is of strings), TS will scream.

## Tuples: Arrays with Strict Rules

Sometimes we know **exactly** how many elements an array has and what type they are at each position.
That is a **Tuple**.

The most famous example is React's `useState` hook:

<CodeTabs items={[
    {
		label: 'React (Example)',
		code: `// useState returns a tuple: [value, function]
// position 0 is always the state (string)
// position 1 is always the setter (function)
const [name, setName] = useState("Denis");`,
		lang: 'tsx'
    }
]} />

In TypeScript it is defined like this:

<CodeTabs items={[
    {
		label: 'TypeScript',
		code: `// Tuple: [string, number]
// The first MUST be string, the second MUST be number.
let role: [string, number] = ["admin", 1];

role = ["user", 2]; // ✅ Good
role = [1, "admin"]; // ❌ Bad (Incorrect order)
role = ["guest", 3, "extra"]; // ❌ Bad (Too many elements)`,
		lang: 'typescript'
    }
]} />

### What are they for?
They are useful when we want to return multiple values from a function without creating an object.

*   Coordinates: `[x, y]` -> `[number, number]`
*   Ranges: `[start, end]`
*   States: `[loading, error, data]`

## Read-Only Arrays (`ReadonlyArray`)

Just like with objects, we can make arrays immutable.

<CodeTabs items={[
    {
		label: 'TypeScript',
		code: `const todoList: readonly string[] = ["Buy bread"];

todoList.push("Milk"); // ❌ Error: Property 'push' does not exist on type 'readonly string[]'.`,
		lang: 'typescript'
    }
]} />

Great for functional programming and avoiding side effects!

## Let's try it!

1. Create an array of strings.
2. Try doing `.push(123)` (you will see the error).
3. Create a tuple `[string, boolean]` (e.g., Name and if active).

<TSEditor
  client:only="react"
  showConsole={true}
  files={{
    'main.ts': `// Our code here
`
  }}
/>

In **Part 5**, things get serious. We leave the basics and enter the magic of TypeScript: we will learn to let TS **write types for us** using `typeof` and `keyof`.
