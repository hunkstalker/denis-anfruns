---
pubDate: '2025-12-17T18:00:00Z'
tags: ['typescript', 'arrays', 'tuples']
draft: true
new: true
title: 'TypeScript #4: Arrays y Tuplas'
description: Listas de cosas y la magia de las Tuplas (o por qué useState devuelve un array).
series: typescript-basics
seriesTitle: Fundamentos de TypeScript
seriesDescription: Aprende TypeScript desde cero profundizando en conceptos como inferencia y tipos.
lang: es
---

import CodeTabs from '../../../../components/mdx/CodeTabs.astro';
import Callout from '../../../../components/mdx/Callout.astro';
import TSEditor from '../../../../components/learn/TSEditor.tsx';

En la parte anterior vimos Objetos. Ahora, ¿qué pasa si tenemos **muchos** objetos? Necesitamos una lista.

## Arrays `[]`

Hay dos formas de definir un array en TypeScript. Ambas son idénticas, es cuestión de gustos.

<CodeTabs
  status="success"
  items={[
    {
		label: 'TypeScript',
		code: `// Opción A: Tipo[] (La más común)
const skills: string[] = ["React", "Astro", "TypeScript"];

// Opción B: Array<Tipo> (Sintaxis Genérica)
const years: Array<number> = [2020, 2021, 2022];

// Array de Objetos (usando la interfaz de la parte anterior)
interface Usuario {
    name: string;
    age: number;
}

const users: Usuario[] = [
    { name: "Alice", age: 30 },
    { name: "Pepe", age: 25 }
];`,
		lang: 'typescript'
    }
]} />

Si intentamos meter un número en nuestro array de `skills` (que es de strings), TS gritará.

## Tuplas: Arrays con reglas estrictas

A veces sabemos **exactamente** cuántos elementos tiene un array y de qué tipo son en cada posición.
Eso es una **Tupla**.

El ejemplo más famoso es el hook `useState` de React:

<CodeTabs items={[
    {
		label: 'React (Ejemplo)',
		code: `// useState devuelve una tupla: [valor, funcion]
// posición 0 siempre es el estado (string)
// posición 1 siempre es el setter (función)
const [name, setName] = useState("Alice");`,
		lang: 'tsx'
    }
]} />

En TypeScript se define así:

<CodeTabs items={[
    {
		label: 'TypeScript',
		code: `// Tupla: [string, number]
// El primero DEBE ser string, el segundo DEBE ser number.
let role: [string, number] = ["admin", 1];

role = ["user", 2]; // ✅ Bien
role = [1, "admin"]; // ❌ Mal (Orden incorrecto)
role = ["guest", 3, "extra"]; // ❌ Mal (Demasiados elementos)`,
		lang: 'typescript'
    }
]} />

Para ser más claros, aquí tienes una comparación entre arrays y tuplas:

<CodeTabs items={[
    {
		label: 'TypeScript',
		code: `// --- ARRAYS  ---
// Da lo mismo el orden de los datos
const miArray1: (string | number)[] = ["TextoArray1", 1]; ✅
const miArray2: (string | number)[] = [5, "TextoArray2"]; ✅

// --- TUPLAS ---
// Le decimos a TS: "Esto es fijo, el primero es string, el segundo number"
const miTupla1: [string, number] = ["TextoTupla1", 1]; ✅
const miTupla2: [string, number] = [5, "TextoTupla2"]; ❌`,
		lang: 'typescript'
    }
]} />

### ¿Para qué sirven las Tuplas?
Son útiles cuando queremos devolver múltiples valores de una función sin crear un objeto.

*   Coordenadas: `[x, y]` -> `[number, number]`
*   Rangos: `[inicio, fin]` -> `[number, number]`
*   Estados: `[loading, error, data]` -> `[boolean, Error | null, any]`

## Arrays de Lectura (`ReadonlyArray`)

Al igual que con los objetos, podemos hacer arrays inmutables.

<CodeTabs items={[
    {
		label: 'TypeScript',
		code: `const todoList: readonly string[] = ["Comprar pan"];

todoList.push("Leche"); // ❌ Error: Property 'push' does not exist on type 'readonly string[]'.`,
		lang: 'typescript'
    }
]} />

¡Genial para programación funcional y evitar efectos secundarios!

## ¡Probémoslo!

Vamos a ensuciarnos las manos. Tienes dos retos abajo: uno para Arrays y otro para Tuplas. TypeScript te avisará de los errores mientras escribes, y al darle a "Run", validaremos si cumple los requisitos.

### Ejercicio 1: Arrays
Crea un array llamado `paises` que contenga al menos 3 nombres de países (strings). Intenta añadir un número al array para ver cómo se queja TypeScript.

import validationArrays from './validation-arrays.ts?raw';

<TSEditor
  client:only="react"
  id="ex-arrays"
  showConsole={true}
  successSound="success"
  defaultMuted={false}
  files={{
    'main.ts': `// 1. Crea un array de strings llamado 'paises'
// const paises...

// 2. Añade países (descomenta y completa)
// paises.push(...);

// 3. Intenta añadir un número (descomenta y dale a RUN para ver el error)
// paises.push(123);

// 4. Vuelve a comentar el push del punto anterior y dale a RUN
`
  }}
  validationCode={validationArrays}
/>

### Ejercicio 2: Tuplas
Crea una tupla estricta llamada `usuario`. Debe tener exactamente 3 elementos en este orden:
1. `nombre` (string)
2. `edad` (number)
3. `esAdmin` (boolean)

import validationTuples from './validation-tuples.ts?raw';

<TSEditor
  client:only="react"
  id="ex-tuples"
  showConsole={true}
  successSound="success"
  defaultMuted={false}
  files={{
    'main.ts': `// Crea la tupla 'usuario' con tipo [string, number, boolean]
// const usuario...
`
  }}
  validationCode={validationTuples}
/>

En la **Parte 5**, las cosas se ponen serias. Dejamos lo básico y entramos en la magia de TypeScript: aprenderemos a que TS **escriba los tipos por nosotros** usando `typeof` y `keyof`.
