---
description: C√≥mo decirle a TypeScript que algo solo puede ser "A" o "B" y nada m√°s. Adi√≥s a los strings m√°gicos.
draft: false
lang: es
new: true
pubDate: '2025-12-15T18:00:00Z'
series: typescript-basics
seriesDescription: "Aprende TypeScript desde cero profundizando en conceptos como inferencia y tipos."
seriesTitle: "Fundamentos de TypeScript"
tags: ['typescript', 'learning', 'series']
title: 'TypeScript # 2: Tipos Literales y Uniones'
---

import CodeTabs from '../../../../components/mdx/CodeTabs.astro';
import Callout from '../../../../components/mdx/Callout.astro';
import TSEditor from '../../../../components/learn/TSEditor.tsx';

En la Parte 1 vimos que `const` crea tipos **literales**.
Si escribimos `const rol = "admin"`, para TypeScript `rol` no es un simple `string`, sino que es espec√≠ficamente `"admin"`.

Hoy vamos a ver c√≥mo usar eso para crear c√≥digo a prueba de balas.

## String vs. String Literal

Imaginemos que tenemos una funci√≥n para pintar un bot√≥n.

<CodeTabs
  status="error"
  items={[
    {
		label: 'TypeScript',
		code: `function pintarBoton(color: string) {
    if (color === 'tojo') { // ‚ùå Ups, error de dedo ("tojo" en vez de "rojo")
        return 'üî¥';
    }
    return 'üîµ';
}

pintarBoton("azul"); // ‚úÖ Bien
pintarBoton("patata ü•î"); // ‚úÖ Bien (pero no deber√≠a, ¬°patata no es un color!)`,
		lang: 'typescript'
    }
]} />

El problema aqu√≠ es que `string` es **demasiado amplio**. Admite "azul", "rojo", y tambi√©n "patata ü•î" o "asdfg".

## La Uni√≥n de Tipos

Aqu√≠ es donde entra el operador `|` (pipe). Se lee como **"O"**.
Podemos decirle a TypeScript: *"El color solo puede ser 'rojo' O 'azul' O 'verde'"*.

<CodeTabs
  status="success"
  items={[
  {
    label: 'TypeScript',
    code: `type ColorBoton = "rojo" | "azul" | "verde";

function pintarBoton(color: ColorBoton) {
    // ...
}

pintarBoton("rojo");   // ‚úÖ Perfecto
pintarBoton("verde");  // ‚úÖ Perfecto
pintarBoton("patata ü•î");
// ‚ùå Error: Argument of type '"patata ü•î"' is not assignable to parameter of type 'ColorBoton'.`,
    lang: 'typescript'
    }
  ]} />

¬°Bum! üí• Acabamos de eliminar una categor√≠a entera de bugs. Ya nadie puede pasar una cadena incorrecta a nuestra funci√≥n.

## El Autocompletado (IntelliSense)

Lo mejor de esto no es solo la seguridad, es la **experiencia de desarrollo**.

**Vamos a probarlo:** Entre las comillas, pulsamos Ctrl + Espacio en cada una. En la primera no hay sugerencias (es un `string` gen√©rico). En la segunda el editor te sugiere las opciones v√°lidas.

import validationCode from './validation.ts?raw';

<div className="mb-8">
  <TSEditor
    client:only="react"
    height="480px"
    showConsole={true}
    allowAddFile={false}
    validationCode={validationCode}
    successSound="/audio/grunt-birthday-party-sound.mp3"
    files={{
      'sin-tipos.ts': `// Sin autocompletado - acepta cualquier string
  function enviarString(mensaje: string) {
      console.log("Mensaje:", mensaje);
  }

  // Prueba entre las comillas y pulsa Ctrl + Espacio
  enviarString("");
  `,
      'con-tipos.ts': `// Con autocompletado - solo valores espec√≠ficos
  type Respuesta = "yes" | "no" | "maybe";

  function enviarRespuesta(respuesta: Respuesta) {
      console.log("Tu respuesta:", respuesta);
  }

  // Prueba entre las comillas y pulsa Ctrl + Espacio
  enviarRespuesta("");
  `
    }}
/>
</div>

No tenemos que ir a la documentaci√≥n para saber qu√© valores aceptaba. El propio tipo nos dice qu√© valores acepta.

## Uniones Mixtas

Podemos mezclar tipos si queremos (aunque us√©moslo con cabeza):

<CodeTabs items={[
  {
  label: 'TypeScript',
  code: `// Un ID puede ser un n√∫mero (ID de base de datos) o un string (UUID)
type ID = number | string;

function buscarUsuario(id: ID) {
    console.log("Buscando usuario con ID:", id);
}

buscarUsuario(123); // ‚úÖ
buscarUsuario("abc-123"); // ‚úÖ`,
  lang: 'typescript'
  }
]} />

## Resumen

*   **Tipos Literales**: Valores exactos (`"rojo"`, `1`).
*   **Uniones (`|`)**: Combinar tipos (`A | B` significa A o B).
*   Us√©moslo para evitar "Magic Strings" y ganar autocompletado gratis.

En la pr√≥xima parte veremos c√≥mo **Tipar Objetos** e Interfaces para dejar de pasar objetos 
an√≥nimos sin control por nuestra aplicaci√≥n.
