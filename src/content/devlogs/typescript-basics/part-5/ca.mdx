---
pubDate: '2025-12-18T10:00:00Z'
tags: ['typescript', 'typeof', 'keyof']
draft: false
new: true
title: 'TypeScript #5: La M√†gia de typeof i keyof'
description: Com crear tipus a partir de valors i oblidar-se de mantenir tipus sincronitzats manualment.
series: typescript-basics
seriesTitle: Fonaments de TypeScript
seriesDescription: Apr√®n TypeScript des de zero aprofundint en conceptes com infer√®ncia i tipus.
lang: ca
---

import CodeTabs from '../../../../components/mdx/CodeTabs.astro';
import Callout from '../../../../components/mdx/Callout.astro';
import TSEditor from '../../../../components/learn/TSEditor.tsx';

Aqu√≠ √©s on TypeScript deixa de ser "JavaScript amb tipus" i es converteix en un superpoder.
Fins ara hem definit tipus manualment. Per√≤, i si pogu√©ssim **generar els tipus autom√†ticament** des del nostre codi?

## `typeof`: Extraient l'ADN

A JS, `typeof` retorna un string ("string", "number", "object").
A TS, si l'usem en un context de tipus, retorna **el tipus complet**.

<CodeTabs
  items={[
    {
		label: 'TypeScript',
		code: `const settings = {
    theme: "dark",
    notifications: true,
    version: 1.0
};

// En lloc d'escriure la interf√≠cie manualment...
// type Settings = { theme: string; notifications: boolean; version: number }; üò¥

type Settings = typeof settings; 
// ü™Ñ Boom! TS acaba d'escriure la interf√≠cie per tu.`,
		lang: 'typescript'
    }
]} />

Aix√≤ √©s brutal per a APIs o llibreries de tercers (o les nostres pr√≤pies constants de configuraci√≥). Tenim una "Single Source of Truth" (Font √önica de Veritat): el valor. El tipus s'adapta sol.

<Callout type="tip" title="Truc per a APIs">
    Imagina que tens la resposta JSON d'una API. En lloc d'escriure la interf√≠cie a m√†, pots enganxar el JSON com una constant (mock) i treure el tipus d'all√†. Aix√≠, l'exemple serveix de documentaci√≥ i de generador de tipus a la vegada.
</Callout>

## `keyof`: Dona'm les claus

`keyof` pren un **Tipus** i ens retorna una Uni√≥ de les seves claus (keys).

<CodeTabs items={[
    {
		label: 'TypeScript',
		code: `interface Usuari {
    name: string;
    age: number;
    email: string;
}

type UsuariKeys = keyof Usuari;
// √âs equivalent a: "name" | "age" | "email"`,
		lang: 'typescript'
    }
]} />

Per a qu√® serveix? Perqu√® no puguem demanar propietats que no existeixen.

<CodeTabs items={[
    {
		label: 'TypeScript',
		code: `function getProperty(user: Usuari, key: keyof Usuari) {
    return user[key];
}

const me: Usuari = { name: "Alice", age: 39, email: "..." };

getProperty(me, "name"); // ‚úÖ
getProperty(me, "password"); // ‚ùå Error: Argument of type '"password"' is not assignable...`,
		lang: 'typescript'
    }
]} />

## El Combo Definitiu: `keyof typeof`

Aquesta √©s una de les combinacions m√©s usades en TypeScript real.
S'usa quan volem treure les keys d'un **objecte/valor** que ja existeix (no d'una interf√≠cie).

1. `typeof objecte` -> Ens dona el Tipus de l'objecte.
2. `keyof (Tipus)` -> Ens dona les keys d'aquest Tipus.

<CodeTabs items={[
    {
		label: 'TypeScript',
		code: `const COLORS = {
    vermell: "#FF0000",
    verd: "#00FF00",
    blau: "#0000FF"
};

type ColorName = keyof typeof COLORS;
// "vermell" | "verd" | "blau"

function paint(color: ColorName) { ... }

paint("vermell"); // ‚úÖ
paint("groc"); // ‚ùå Error`,
		lang: 'typescript'
    }
]} />

## Provem-ho!

Usem l'editor. Creem un objecte `config` amb diverses opcions. Usem `typeof` per treure el seu tipus i creem una funci√≥ que rebi aquest tipus.

import validationCode from './validation.ca.ts?raw';

<TSEditor
  client:only="react"
  id="ex-typeof-keyof"
  showConsole={true}
  successSound="success"
  defaultMuted={false}
  height="700px"
  files={{
    'main.ts': `const config = {
    theme: "dark",
    version: 2,
    debug: true
} as const; // üëà Ull al 'as const'

// 1. Crea el tipus 'Config' usant l'operador typeof
type Config = any; 

// 2. Crea el tipus 'ConfigKey' usant l'operador keyof
type ConfigKey = any;

// 3. Completa la funci√≥ perqu√® 'key' sigui segura (usa ConfigKey)
function getSetting(key: any) {
    return config[key];
}

// Proves (No toquis aix√≤):
getSetting("theme"); // ‚úÖ Hauria de funcionar
// getSetting("password"); // ‚ùå Hauria de donar error si descomentes
`
  }}
  validationCode={validationCode}
/>

A la **Part 6** veurem els **Generics**, l'eina que ens permet crear components i funcions reutilitzables que funcionen amb qualsevol tipus (el fam√≥s `<T>`).
