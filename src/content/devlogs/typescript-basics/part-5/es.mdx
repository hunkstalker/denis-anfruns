---
description: C√≥mo crear tipos a partir de valores y olvidarse de mantener tipos sincronizados manualmente.
draft: true
lang: es
new: false
pubDate: '2025-12-19T10:00:00Z'
seriesDescription: "Aprende TypeScript desde cero profundizando en conceptos como inferencia y tipos."
seriesTitle: "Fundamentos de TypeScript"
tags: ['typescript', 'typeof', 'keyof']
title: 'TypeScript #5: La Magia de typeof y keyof'
---

import CodeTabs from '../../../../components/mdx/CodeTabs.astro';
import Callout from '../../../../components/mdx/Callout.astro';
import TSEditor from '../../../../components/learn/TSEditor.tsx';

Aqu√≠ es donde TypeScript deja de ser "JavaScript con tipos" y se convierte en un superpoder.
Hasta ahora hemos definido tipos manualmente. Pero, ¬øy si pudi√©ramos **generar los tipos autom√°ticamente** desde nuestro c√≥digo?

## `typeof`: Extrayendo el ADN

En JS, `typeof` devuelve un string ("string", "number", "object").
En TS, si lo usamos en un contexto de tipos, devuelve **el tipo completo**.

<CodeTabs
  items={[
    {
		label: 'TypeScript',
		code: `const settings = {
    theme: "dark",
    notifications: true,
    version: 1.0
};

// En vez de escribir la interfaz manualmente...
// type Settings = { theme: string; notifications: boolean; version: number }; üò¥

type Settings = typeof settings; 
// ü™Ñ ¬°Boom! TS acaba de escribir la interfaz por ti.`,
		lang: 'typescript'
    }
]} />

Esto es brutal para APIs o librer√≠as de terceros (o nuestras propias constantes de configuraci√≥n). Tenemos una "Single Source of Truth" (Fuente √önica de Verdad): el valor. El tipo se adapta solo.

<Callout type="tip" title="Truco para APIs">
    Imagina que tienes la respuesta JSON de una API. En lugar de escribir la interfaz a mano, puedes pegar el JSON como una constante (mock) y sacar el tipo de ah√≠. As√≠, el ejemplo sirve de documentaci√≥n y de generador de tipos a la vez.
</Callout>

## `keyof`: Dame las llaves

`keyof` toma un **Tipo** y nos devuelve una Uni√≥n de sus claves (keys).

<CodeTabs items={[
    {
		label: 'TypeScript',
		code: `interface Usuario {
    name: string;
    age: number;
    email: string;
}

type UsuarioKeys = keyof Usuario;
// Es equivalente a: "name" | "age" | "email"`,
		lang: 'typescript'
    }
]} />

¬øPara qu√© sirve? Para que no podamos pedir propiedades que no existen.

<CodeTabs items={[
    {
		label: 'TypeScript',
		code: `function getProperty(user: Usuario, key: keyof Usuario) {
    return user[key];
}

const me: Usuario = { name: "Paco", age: 39, email: "..." };

getProperty(me, "name"); // ‚úÖ
getProperty(me, "password"); // ‚ùå Error: Argument of type '"password"' is not assignable...`,
		lang: 'typescript'
    }
]} />

## El Combo Definitivo: `keyof typeof`

Esta es una de las combinaciones m√°s usadas en TypeScript real.
Se usa cuando queremos sacar los keys de un **objeto/valor** que ya existe (no de una interfaz).

1. `typeof objeto` -> Nos da el Tipo del objeto.
2. `keyof (Tipo)` -> Nos da las keys de ese Tipo.

<CodeTabs items={[
    {
		label: 'TypeScript',
		code: `const COLORES = {
    rojo: "#FF0000",
    verde: "#00FF00",
    azul: "#0000FF"
} as const; // 'as const' hace que sean literales y readonly

// Queremos un tipo que solo permita "rojo" | "verde" | "azul"
type NombreColor = keyof typeof COLORES;

function pintar(color: NombreColor) { ... }

pintar("rojo"); // ‚úÖ
pintar("amarillo"); // ‚ùå`,
		lang: 'typescript'
    }
]} />

<Callout type="info" title="Nota Pro" filled>
    El `as const` es vital aqu√≠. Si no lo ponemos, TS inferir√° que propiedades son `string`, y `typeof` ser√° muy gen√©rico. Con `as const` le decimos: "¬°Esto no cambia, es literal!".
</Callout>

## ¬°Prob√©moslo!

Usemos el editor. Creemos un objeto `config` con varias opciones. Usemos `typeof` para sacar su tipo y creemos una funci√≥n que reciba ese tipo.

<TSEditor
  client:only="react"
  id="ex-typeof-keyof"
  showConsole={true}
  successSound="success"
  defaultMuted={false}
  height="700px"
  files={{
    'main.ts': `const config = {
    theme: "dark",
    version: 2,
    debug: true
} as const; // üëà Ojo al 'as const'

// 1. Crea el tipo 'Config' usando el operador typeof
type Config = any; 

// 2. Crea el tipo 'ConfigKey' usando el operador keyof
type ConfigKey = any;

// 3. Completa la funci√≥n para que 'key' sea segura (usa ConfigKey)
function getSetting(key: any) {
    return config[key];
}

// Pruebas (No toques esto):
getSetting("theme"); // ‚úÖ Deber√≠a funcionar
// getSetting("password"); // ‚ùå Deber√≠a dar error si descomentas
`
  }}
  validationCode={`
     try {
        // Validaci√≥n de tipos est√°tica (inspecci√≥n de c√≥digo fuente simplificada)
        // 1. Verificar Config
        type _TestConfig = typeof config;
        const testConfig: _TestConfig = { theme: "dark", version: 2, debug: true };
        
        // 2. Verificar Keys
        type _TestKeys = keyof _TestConfig;
        const k1: _TestKeys = "theme";
        const k2: _TestKeys = "version";
        // @ts-expect-error
        const k3: _TestKeys = "fake"; 

        if (typeof onSuccess === 'function') onSuccess();
        console.log("‚úÖ ¬°Ejercicio completado! Has dominado typeof y keyof.");
        console.log("üîë Las claves inferidas son:", Object.keys(config).join(" | "));

    } catch (e) {
        console.error("Algo no est√° bien. Aseg√∫rate de usar 'typeof config' y 'keyof Config'.");
    }
  `}
/>

En la **Parte 6** veremos los **Generics**, la herramienta que nos permite crear componentes y funciones reutilizables que funcionan con cualquier tipo (el famoso `<T>`).
