---
pubDate: '2025-12-14T20:00:00Z'
tags: ['typescript', 'inference', 'basics']
heroImage: /assets/typescript-basics/hero-ts-basics.webp
draft: false
new: false
title: 'TypeScript #1: La Inferencia treballa per tu'
description: Per qu√® escriure tipus quan TypeScript ja els sap? Entenent const vs let i la infer√®ncia autom√†tica.
series: typescript-basics
seriesTitle: Fonaments de TypeScript
seriesDescription: Apr√®n TypeScript des de zero aprofundint en conceptes com infer√®ncia i tipus.
lang: ca
---

import Callout from '../../../../components/mdx/Callout.astro';
import TSEditor from '../../../../components/learn/TSEditor.tsx';

export const age = new Date().getFullYear() - 1985

## Benvingut! üöÄ

Aquesta √©s la primera part d'una s√®rie que intentar√† que entenguis TypeScript _**de veritat**_, no nom√©s perqu√® copi√Øs i enganxis "any" quan el compilador es queixa.

L'objectiu de la s√®rie completa √©s acabar comprenent que TypeScript no √©s nom√©s JavaScript amb tipus, sin√≥ que TypeScript √©s un protolenguatge de tipat per crear tota estructura de tipus que necessitis per als teus projectes i fer que, encara que s√≠, tot sigui m√©s lent i pesat amb les male√Ødes üëπ advert√®ncies, al final guanyis en seguretat i robustesa de codi.

Jo no soc cap expert, per√≤ sempre he pensat que per aprendre el millor √©s tractar d'ensenyar als altres. Aix√≤ t'obliga a abordar cada tema de manera que qualsevol pugui entendre'ls i veure-ho des de moltes perspectives.

Per aix√≤, en aquesta s√®rie intentar√© explicar cada concepte des de zero, sense utilitzar termes t√®cnics complexos, sense utilitzar llenguatge t√®cnic que nom√©s els que ja saben TypeScript entenguin.

El primer pel que comen√ßarem √©s entendre que **TypeScript √©s llest. No cal explicar-li l'obvi.**

<Callout type="info" title="Info" filled>
    Nota: Aquesta √©s la primera entrada d'una s√®rie de TIL sobre aprenentatge. Encara que √©s diferent de la resta de TIL que s√≥n notes curtes, he pensat a reutilitzar-lo perqu√® al cap i a la fi segueix la mateixa idea d'alguna cosa que aprens dia a dia. Per ara aix√≤ √©s un experiment.
</Callout>

## La Infer√®ncia de Tipus

Molts devs (com jo) que venen de llenguatges fortament tipats (com C, Java o C# antics) √©s normal que estiguem acostumats a la idea de tipar-ho tot.

<CodeTabs
  status="error"
  items={[
    {
		label: 'example.ts',
		code: `// ‚ùå Redundant (Boilerplate innecessari)
const userName: string = "Denis";
const userAge: number = ${age};
const isAdmin: boolean = true;`,
		lang: 'typescript'
    }
]} />

TypeScript ja sap que "Denis" √©s un string. No cal que l'hi juris.

<CodeTabs
  status="success"
  items={[
  {
    label: 'example.ts',
    code: `// ‚úÖ Perfecte (Net i llegible)
const userName = "Denis"; // TS infereix: string (o literal "Denis", veurem aix√≤ despr√©s)
const userAge = ${age};       // TS infereix: number
const isAdmin = true;     // TS infereix: boolean`,
    lang: 'typescript'
    }
  ]} />

Aix√≤ es diu **Infer√®ncia de Tipus**. Deixes que TS dedueixi el tipus pel valor inicial.

## `const` vs `let`: La difer√®ncia clau

Aqu√≠ √©s on la cosa es posa interessant i on TS brilla.

### Amb `let` (Variables mutables)
Quan uses `let`, TS assumeix que canviar√†s el valor, aix√≠ que infereix el tipus primitiu "general".

<CodeTabs items={[
  {
  label: 'TypeScript',
  code: `// TS amb aix√≤ ent√©n: "Ah, 'status' √©s un STRING i a m√©s canviar√† a qualsevol altre string".
let status = "pending";

status = "success"; // ‚úÖ B√©
status = "error";   // ‚úÖ B√©

status = 123;       // ‚ùå Si ho intentes et retornar√† un error.
// No pots ficar un n√∫mero en un string.`,
  lang: 'typescript'
  }
]} />

### Amb `const` (Constants)
Quan uses `const`, TS sap que aquest valor **mai canviar√†**. Aix√≠ que pot ser molt m√©s espec√≠fic.

<CodeTabs items={[
  {
    label: 'TypeScript',
    code: `const method = "GET";
// TS diu: "Aix√≤ no √©s nom√©s un string. √âs L'string 'GET'".
// El tipus literal √©s "GET".
`,
  lang: 'typescript'
  }
]} />

Aix√≤ sembla una ximpleria ara, per√≤ √©s la base per entendre per qu√® a vegades TS es queixa que `"GET"` no √©s assignable a `string` (o viceversa) en configuracions complexes.

## Quan S√ç anotar tipus

Llavors, si TS ho infereix, mai √©s necessari posar tipus? No, hi ha casos on √©s necessari:

1.  **Quan la infer√®ncia falla o √©s molt √†mplia**:

Des del meu punt de vista amb poca experi√®ncia, deixaria que TS infereixi any (o el posaria jo mateix) en casos en qu√® no s√© el que passar√†, sigui per errors o que la resposta pugui ser molt √†mplia.

<CodeTabs items={[
  {
    label: 'TypeScript',
    code: `// TS infereix 'any' si no est√† configurat en mode 'strict' (que t'obliga a anotar tipus sempre)
let data; 
data = fetchSomething(); // Pots passar-li el que vulguis i TS no es queixa.`,
    lang: 'typescript'
  }
]} />

Per√≤ ull amb any, perqu√® li est√†s traient a TS tot el seu prop√≤sit. L'ideal seria no veure't obligat a utilitzar-lo.

2.  **En par√†metres de funcions** (Aqu√≠ √©s obligatori!):

<CodeTabs items={[
  {
    label: 'TypeScript',
    code: `// ‚ùå TS no pot llegir la teva ment ni saber qui cridar√† a aix√≤
function greet(person) {
    ...
}

// ‚úÖ Aqu√≠ defineixes el contracte
function greet(person: string) {
    ...
}`, 
    lang: 'typescript'
  }
]} />

3.  **Per definir contractes de retorn expl√≠cits**:
    A vegades vols assegurar-te que la teva funci√≥ retorna X, encara que infereixi Y.

## Resum de la Part 1

*   **Menys √©s m√©s**: Si TS pot inferir-ho, no ho escriguis. El teu codi ser√† m√©s net.
*   **Variable (`let`)** = Tipus General (`string`, `number`).
*   **Constant (`const`)** = Tipus Literal (El valor exacte).

A la **Part 2**, mirarem com usar aquests tipus literals al nostre favor amb les **Unions**, i com dir-li a TS: *"Aquesta variable nom√©s pot ser 'admin' o 'user', res m√©s"*.

## Experimenta!

Aqu√≠ tens un editor de TypeScript real corrent al teu navegador per provar el que has apr√®s.

<TSEditor
  client:only="react"
  showConsole={true}
  files={{
    'main.ts': `console.log("Hello world!");
`
  }}
/>
