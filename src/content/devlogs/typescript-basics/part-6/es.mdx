---
pubDate: '2025-12-19T10:00:00Z'
tags: ['typescript', 'narrowing', 'basics']
draft: true
new: true
title: 'TypeScript #6: Type Guards & Narrowing'
description: Aprende a decirle a TypeScript "conf√≠a en m√≠, s√© lo que hago". Type Guards, operador 'is' y narrowing.
series: typescript-basics
seriesTitle: Fundamentos de TypeScript
seriesDescription: Aprende TypeScript desde cero profundizando en conceptos como inferencia y tipos.
lang: es
---

import CodeTabs from '../../../../components/mdx/CodeTabs.astro';
import Callout from '../../../../components/mdx/Callout.astro';
import TSEditor from '../../../../components/learn/TSEditor.tsx';

TypeScript es muy listo, pero a veces necesita "pistas" para saber exactamente de qu√© tipo es una variable en un momento dado. Este proceso de refinar un tipo amplio (como `string | number`) a uno m√°s espec√≠fico (como `string`) se llama **Narrowing**.

Y para lograrlo, usamos **Type Guards** (Guardias de Tipos).

## 1. El problema: La incertidumbre

Imagina que tienes una funci√≥n que acepta un ID, pero este ID puede ser un n√∫mero (Base de datos SQL) o un texto (UUID).

<TSEditor
  client:visible
  id="narrowing-problem"
  files={{
    'main.ts': `function printId(id: string | number) {
  // Error: Property 'toUpperCase' does not exist on type 'string | number'.
  // Property 'toUpperCase' does not exist on type 'number'.
  console.log(id.toUpperCase()); 
}

printId("abc");`
  }}
/>

TypeScript se queja porque **no est√° seguro** de que `id` sea un string. Si fuera un n√∫mero, `.toUpperCase()` explotar√≠a en tiempo de ejecuci√≥n. üí•

## 2. Soluci√≥n: `typeof` Guards

La forma m√°s com√∫n de narrowing es usar el operador `typeof` de JavaScript dentro de un condicional `if`. TypeScript entiende este c√≥digo y "reduce" el tipo dentro del bloque.

<TSEditor
  client:visible
  id="narrowing-typeof"
  files={{
    'main.ts': `function printId(id: string | number) {
  if (typeof id === "string") {
    // ¬°Aqu√≠ dentro TypeScript SABE que id es string!
    console.log("Tu ID es: " + id.toUpperCase());
  } else {
    // Y aqu√≠ sabe que TIENE que ser number
    console.log("Tu ID es: " + id.toFixed(2));
  }
}

printId("denis");
printId(123.456);`
  }}
/>

<Callout type="check" title="Tipos soportados por typeof">
Recuerda que `typeof` solo funciona con primitivos b√°sicos: `"string"`, `"number"`, `"boolean"`, `"symbol"`, `"undefined"`, `"object"` y `"function"`.
¬°Ojo! `typeof null` devuelve `"object"`, lo cual es un bug hist√≥rico de JS.
</Callout>

## 3. Truthiness Narrowing

A veces no necesitas saber el tipo exacto, solo si el valor existe (no es `null` ni `undefined`).

```typescript
function printName(name?: string) {
  // name es string | undefined
  if (name) {
    // Aqu√≠ name es string (porque undefined es falsy)
    console.log(name.toUpperCase());
  }
}
```

## 4. `instanceof` Narrowing

Para objetos construidos con clases, `typeof` no sirve de mucho (todo es "object"). Aqu√≠ entra `instanceof`.

<TSEditor
  client:visible
  id="narrowing-instanceof"
  files={{
    'classes.ts': `class Perro {
  ladrar() { return "Guau!"; }
}

class Gato {
  maullar() { return "Miau!"; }
}

function comunicar(mascota: Perro | Gato) {
  if (mascota instanceof Perro) {
    console.log(mascota.ladrar());
  } else {
    console.log(mascota.maullar());
  }
}

comunicar(new Perro());`
  }}
/>

## 5. Predicados de Tipo (Custom Type Guards)

¬øQu√© pasa si quieres reutilizar una l√≥gica de comprobaci√≥n compleja? Puedes crear tus propias funciones de guardia usando el operador `is`.

La sintaxis clave es el tipo de retorno: `param is Type`.

<TSEditor
  client:visible
  id="narrowing-predicates"
  files={{
    'main.ts': `type Pez = { nadar: () => void };
type Pajaro = { volar: () => void };

// Funci√≥n guardia personalizada
function esPez(mascota: Pez | Pajaro): mascota is Pez {
  return (mascota as Pez).nadar !== undefined;
}

function mover(animal: Pez | Pajaro) {
  if (esPez(animal)) {
    // TypeScript conf√≠a en tu funci√≥n: aqu√≠ es Pez
    animal.nadar();
  } else {
    // Aqu√≠ debe ser Pajaro
    animal.volar();
  }
}

const nemo = { nadar: () => console.log("Nadando...") };
mover(nemo);`
  }}
/>

<Callout type="warning" title="Poder y Responsabilidad">
Cuando usas `is`, le dices al compilador "conf√≠a en m√≠". Si tu l√≥gica dentro de la funci√≥n `esPez` est√° mal, TypeScript se lo creer√° y podr√≠as tener errores en tiempo de ejecuci√≥n.
</Callout>

El Narrowing es esencial para escribir c√≥digo que sea flexible (acepte varios tipos) pero seguro (trate cada uno como corresponde). En el **siguiente cap√≠tulo**, veremos qu√© pasa cuando *realmente* no sabemos qu√© tipo nos llega... `unknown` vs `any`.
