---
pubDate: '2025-12-19T10:00:00Z'
tags: ['typescript', 'narrowing', 'basics']
draft: false
new: true
title: 'TypeScript #6: Type Guards & Narrowing'
description: "Aprende a decirle a TypeScript \"conf√≠a en m√≠, s√© lo que hago\". Type Guards, operador 'is' y narrowing."
series: typescript-basics
seriesTitle: Fundamentos de TypeScript
seriesDescription: Aprende TypeScript desde cero profundizando en conceptos como inferencia y tipos.
lang: es
---

import CodeTabs from '../../../../components/mdx/CodeTabs.astro';
import Callout from '../../../../components/mdx/Callout.astro';
import TSEditor from '../../../../components/learn/TSEditor.tsx';

TypeScript es muy listo, pero a veces necesita "pistas" para saber exactamente de qu√© tipo es una variable en un momento dado. Este proceso de refinar un tipo amplio (como `string | number`) a uno m√°s espec√≠fico (como `string`) se llama **Narrowing**.

Y para lograrlo, usamos **Type Guards** (Guardias de Tipos).

## 1. El problema: La incertidumbre

Imagina que tienes una funci√≥n que acepta un ID, pero este ID puede ser un n√∫mero (Base de datos SQL) o un texto (UUID).

<CodeTabs
  status="error"
  items={[
    {
      label: 'main.ts',
      code: `function printId(id: string | number) {
  // Error: Property 'toUpperCase' does not exist on type 'string | number'.
  // Property 'toUpperCase' does not exist on type 'number'.
  console.log(id.toUpperCase()); 
}

printId("abc");`,
      lang: 'typescript'
    }
  ]}
/>

TypeScript se queja porque **no est√° seguro** de que `id` sea un string. Si fuera un n√∫mero, `.toUpperCase()` explotar√≠a en tiempo de ejecuci√≥n. üí•

## 2. Soluci√≥n: `typeof` Guards

La forma m√°s com√∫n de narrowing es usar el operador `typeof` de JavaScript dentro de un condicional `if`. TypeScript entiende este c√≥digo y "reduce" el tipo dentro del bloque.

<CodeTabs
  status="success"
  items={[
    {
      label: 'main.ts',
      code: `function printId(id: string | number) {
  if (typeof id === "string") {
    // ¬°Aqu√≠ dentro TypeScript SABE que id es string!
    console.log("Tu ID es: " + id.toUpperCase());
  } else {
    // Y aqu√≠ sabe que TIENE que ser number
    console.log("Tu ID es: " + id.toFixed(2));
  }
}

printId("Pizza!");
printId(123.456);`,
      lang: 'typescript'
    }
  ]}
/>

<Callout type="tip" title="Tipos soportados por typeof">
Recuerda que `typeof` solo funciona con primitivos b√°sicos: `"string"`, `"number"`, `"boolean"`, `"symbol"`, `"undefined"`, `"object"` y `"function"`.
¬°Ojo! `typeof null` devuelve `"object"`, lo cual es un bug hist√≥rico de JS.
</Callout>

## 3. Truthiness Narrowing

A veces no necesitas saber el tipo exacto, solo si el valor existe (no es `null` ni `undefined`).

<CodeTabs
  items={[
    {
      label: 'truthiness.ts',
      code: `function printName(name?: string) {
  // name es string | undefined
  if (name) {
    // Aqu√≠ name es string (porque undefined es falsy)
    console.log(name.toUpperCase());
  }
}`,
      lang: 'typescript'
    }
  ]}
/>

## 4. `instanceof` Narrowing

Para objetos construidos con clases, `typeof` no sirve de mucho (todo es "object"). Aqu√≠ entra `instanceof`.

<CodeTabs
  items={[
    {
      label: 'classes.ts',
      code: `class Perro {
  ladrar() { return "Guau!"; }
}

class Gato {
  maullar() { return "Miau!"; }
}

function comunicar(mascota: Perro | Gato) {
  if (mascota instanceof Perro) {
    console.log(mascota.ladrar());
  } else {
    console.log(mascota.maullar());
  }
}

comunicar(new Perro());`,
      lang: 'typescript'
    }
  ]}
/>

## 5. Predicados de Tipo (Custom Type Guards)

¬øQu√© pasa si quieres reutilizar una l√≥gica de comprobaci√≥n compleja? Puedes crear tus propias funciones de guardia usando el operador `is`.

La sintaxis clave es el tipo de retorno: `param is Type`.

<CodeTabs
  items={[
    {
      label: 'main.ts',
      code: `type Pez = { nadar: () => void };
type Pajaro = { volar: () => void };

// Funci√≥n guardia personalizada
function esPez(mascota: Pez | Pajaro): mascota is Pez {
  return (mascota as Pez).nadar !== undefined;
}

function mover(animal: Pez | Pajaro) {
  if (esPez(animal)) {
    // TypeScript conf√≠a en tu funci√≥n: aqu√≠ es Pez
    animal.nadar();
  } else {
    // Aqu√≠ debe ser Pajaro
    animal.volar();
  }
}

const nemo = { nadar: () => console.log("Nadando...") };
mover(nemo);`,
      lang: 'typescript'
    }
  ]}
/>

<Callout type="warning" title="Poder y Responsabilidad">
Cuando usas `is`, le dices al compilador "conf√≠a en m√≠". Si tu l√≥gica dentro de la funci√≥n `esPez` est√° mal, TypeScript se lo creer√° y podr√≠as tener errores en tiempo de ejecuci√≥n.
</Callout>

## 6. Ejercicio: El Formateador Universal

¬°Te toca! Tengo una funci√≥n que recibe un `input`. Puede ser un `string` o un `number`.

*   Si es `string`: Devu√©lvelo en MAY√öSCULAS.
*   Si es `number`: Devu√©lvelo con 2 decimales (usa `.toFixed(2)`).

import validationCode from './validation.ts?raw';

<TSEditor
  client:only="react"
  validationCode={validationCode}
  successSound="success"
  defaultMuted={false}
  showConsole={true}
  files={{
    'exercise.ts': `function procesarInput(input: string | number) {
  // TODO: Usa un Type Guard (typeof) aqu√≠
  // 1. procesarInput debe devolver strings (MAY√öSCULAS)
  // 2. procesarInput debe devolver n√∫meros (2 decimales)
  
  return input; // ‚ùå Error: toUpperCase no existe en number

  // JS TIP: para devolver may√∫sculas toUpperCase() y para devolver 2 decimales toFixed(2)
}`
  }}
/>

El Narrowing es esencial para escribir c√≥digo que sea flexible (acepte varios tipos) pero seguro (trate cada uno como corresponde). En el **siguiente cap√≠tulo**, veremos qu√© pasa cuando *realmente* no sabemos qu√© tipo nos llega... `unknown` vs `any`.
