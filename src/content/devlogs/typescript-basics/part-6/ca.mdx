---
pubDate: '2025-12-19T10:00:00Z'
tags: ['typescript', 'narrowing', 'basics']
draft: true
new: true
title: 'TypeScript #6: Type Guards & Narrowing'
description: Apr√®n a dir-li a TypeScript "confia en mi, s√© el que faig". Type Guards, operador 'is' i narrowing.
series: typescript-basics
seriesTitle: Fonaments de TypeScript
seriesDescription: Apr√®n TypeScript des de zero aprofundint en conceptes com infer√®ncia i tipus.
lang: ca
---

import CodeTabs from '../../../../components/mdx/CodeTabs.astro';
import Callout from '../../../../components/mdx/Callout.astro';
import TSEditor from '../../../../components/learn/TSEditor.tsx';

TypeScript √©s molt llest, per√≤ a vegades necessita "pistes" per saber exactament de quin tipus √©s una variable en un moment donat. Aquest proc√©s de refinar un tipus ampli (com `string | number`) a un de m√©s espec√≠fic (com `string`) es diu **Narrowing**.

I per aconseguir-ho, usem **Type Guards** (Guardies de Tipus).

## 1. El problema: La incertesa

Imagina que tens una funci√≥ que accepta un ID, per√≤ aquest ID pot ser un n√∫mero (Base de dades SQL) o un text (UUID).

<CodeTabs
  status="error"
  items={[
    {
      label: 'main.ts',
      code: `function printId(id: string | number) {
  // Error: Property 'toUpperCase' does not exist on type 'string | number'.
  // Property 'toUpperCase' does not exist on type 'number'.
  console.log(id.toUpperCase()); 
}

printId("abc");`,
      lang: 'typescript'
    }
  ]}
/>

TypeScript es queixa perqu√® **no est√† segur** que `id` sigui un string. Si fos un n√∫mero, `.toUpperCase()` explotaria en temps d'execuci√≥. üí•

## 2. Soluci√≥: `typeof` Guards

La forma m√©s comuna de narrowing √©s usar l'operador `typeof` de JavaScript dins d'un condicional `if`. TypeScript ent√©n aquest codi i "redueix" el tipus dins del bloc.

<CodeTabs
  status="success"
  items={[
    {
      label: 'main.ts',
      code: `function printId(id: string | number) {
  if (typeof id === "string") {
    // Aqu√≠ dins TypeScript SAP que id √©s string!
    console.log("El teu ID √©s: " + id.toUpperCase());
  } else {
    // I aqu√≠ sap que HA de ser number
    console.log("El teu ID √©s: " + id.toFixed(2));
  }
}

printId("Pizza!");
printId(123.456);`,
      lang: 'typescript'
    }
  ]}
/>

<Callout type="tip" title="Tipus suportats per typeof">
Recorda que `typeof` nom√©s funciona amb primitius b√†sics: `"string"`, `"number"`, `"boolean"`, `"symbol"`, `"undefined"`, `"object"` i `"function"`.
Compte! `typeof null` retorna `"object"`, la qual cosa √©s un bug hist√≤ric de JS.
</Callout>

## 3. Truthiness Narrowing

A vegades no necessites saber el tipus exacte, nom√©s si el valor existeix (no √©s `null` ni `undefined`).

<CodeTabs
  items={[
    {
      label: 'truthiness.ts',
      code: `function printName(name?: string) {
  // name √©s string | undefined
  if (name) {
    // Aqu√≠ name √©s string (perqu√® undefined √©s falsy)
    console.log(name.toUpperCase());
  }
}`,
      lang: 'typescript'
    }
  ]}
/>

## 4. `instanceof` Narrowing

Per a objectes constru√Øts amb classes, `typeof` no serveix de gaire (tot √©s "object"). Aqu√≠ entra `instanceof`.

<CodeTabs
  items={[
    {
      label: 'main.ts',
      code: `function logValue(x: Date | string) {
  if (x instanceof Date) {
    console.log(x.toUTCString()); // x √©s Date
  } else {
    console.log(x.toUpperCase()); // x √©s string
  }
}`,
      lang: 'typescript'
    }
  ]}
/>

## 5. Type Predicates (`is`)

Aquesta √©s la part m√©s "Pro". Qu√® passa si tenim una l√≤gica de verificaci√≥ personalitzada?
Podem crear una funci√≥ que retorni un **Type Predicate**: `param is Type`.

<CodeTabs
  items={[
    {
      label: 'main.ts',
      code: `interface Fish { swim: () => void }
interface Bird { fly: () => void }

// Narrowing Function
function isFish(pet: Fish | Bird): pet is Fish {
  return (pet as Fish).swim !== undefined;
}

// √ös
function move(pet: Fish | Bird) {
  if (isFish(pet)) {
    pet.swim(); // TS sap que √©s Fish
  } else {
    pet.fly(); // TS sap que HA de ser Bird
  }
}`,
      lang: 'typescript'
    }
  ]}
/>

## 6. Exercici: El Formatejador Universal

Tens una funci√≥ que rep inputs segurs, per√≤ no saps si vindran com `string` o `number`. La teva feina √©s formatejar-los correctament sense que TypeScript es queixi.

Idealment fes √∫s de `typeof`

import validationCode from './validation.ca.ts?raw';

<TSEditor
  client:only="react"
  validationCode={validationCode}
  showConsole={true}
  successSound="success"
  files={{
    'exercise.ts': `function procesarInput(input: string | number) {
  // TODO: Usa un Type Guard (typeof) aqu√≠
  // 1. Si √©s string -> return string.toUpperCase()
  // 2. Si √©s number -> return number.toFixed(2)
  
  return input; // ‚ùå Error: toUpperCase no existeix en number
}`
  }}
/>
