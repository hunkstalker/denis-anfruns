---
title: 'TypeScript # 3: Objetos e Interfaces'
description: C√≥mo dar forma a tus datos. Interfaces, Types y por qu√© "any" es tu enemigo.
pubDate: '2025-12-16T18:00:00Z'
tags: ['typescript', 'learning', 'series']
lang: ca
series: typescript-basics
seriesTitle: {"es":"Fundamentos de TypeScript","en":"TypeScript Basics"}
seriesDescription: {"es":"Aprende TypeScript desde cero profundizando en conceptos como inferencia y tipos.","en":"Learn TypeScript from scratch diving deep into inference and types."}
new: true
draft: false
---

import CodeTabs from '../../../../components/mdx/CodeTabs.astro';
import Callout from '../../../../components/mdx/Callout.astro';
import TSEditor from '../../../../components/learn/TSEditor.tsx';

Fins ara hem vist tipus primitius (`string`, `number`, `boolean`). Per√≤ el m√≥n real funciona amb **objectes**.
Usuaris, Productes, Comandes... tots s√≥n objectes amb m√∫ltiples propietats.

## L'Anarquia dels Objectes An√≤nims

En JavaScript pur, solem passar objectes d'un costat a l'altre confiant en la nostra mem√≤ria.

<CodeTabs
  status="error"
  items={[
    {
		label: 'JavaScript (Anarquia)',
		code: `function imprimirUsuari(usuari) {
    // ü§û Esperem que 'usuari' tingui aquestes propietats...
    console.log("Nom: " + usuari.name.toUpperCase());
    console.log("Edat: " + usuari.age);
}

// Un mes despr√©s, alg√∫ crida la funci√≥ aix√≠:
imprimirUsuari({ nom: "Denis", edat: 40 }); 
// üí• CRASH: Cannot read properties of undefined (reading 'toUpperCase')
// Per qu√®? Perqu√® passem "nom" en catal√† per√≤ la funci√≥ esperava "name" en angl√®s.`,
		lang: 'javascript'
    }
]} />

TypeScript evita aix√≤ obligant-te a definir la **FORMA** (Shape) dels teus objectes.

## Interf√≠cies: El Contracte

Una `interface` √©s com un contracte. Si un objecte diu ser un `Usuari`, **HA_DE** complir el contracte.

<CodeTabs
  status="success"
  items={[
    {
		label: 'TypeScript',
		code: `interface Usuari {
    name: string;
    age: number;
    isDeveloper: boolean;
}

const denis: Usuari = {
    name: "Denis",
    age: 39,
    isDeveloper: true
}; // ‚úÖ Compleix el contracte

const pepe: Usuari = {
    name: "Pepe"
}; // ‚ùå Error: Falten les propietats 'age' i 'isDeveloper'`,
		lang: 'typescript'
    }
]} />

## Propietats Opcionals (`?`)

A vegades no tenim totes les dades. Potser l'`email` √©s opcional.
Per a aix√≤ fem servir el signe d'interrogaci√≥ `?` despr√©s del nom de la propietat.

<CodeTabs items={[
    {
		label: 'TypeScript',
		code: `interface Producte {
    id: number;
    nom: string;
    descripcio?: string; // üëà Opcional (string | undefined)
}

const taula: Producte = {
    id: 1,
    nom: "Taula d'escriptori"
    // No cal posar descripci√≥
};`,
		lang: 'typescript'
    }
]} />

## Propietats de Nom√©s Lectura (`readonly`)

Si vols assegurar-te que una propietat **mai canvi** despr√©s de crear l'objecte (com un ID), fes servir `readonly`.

<CodeTabs items={[
    {
		label: 'TypeScript',
		code: `interface Configuracio {
    readonly apiKey: string;
    theme: "light" | "dark";
}

const config: Configuracio = {
    apiKey: "xyz-123",
    theme: "light"
};

config.theme = "dark"; // ‚úÖ Pots canviar-ho
config.apiKey = "abc-999"; // ‚ùå Error: Cannot assign to 'apiKey' because it is a read-only property.`,
		lang: 'typescript'
    }
]} />

## `type` vs `interface`?

Veur√†s gent fent servir `type Usuari = { ... }` en lloc d'`interface Usuari { ... }`.
Per definir la forma d'un objecte, tots dos funcionen gaireb√© igual.

> **Regla d'or (per ara):**
> *   Fes servir **`interface`** per definir objectes que representen entitats (Usuari, Post, Producte).
> *   Fes servir **`type`** per a Unions (`string | number`), primitius o tuples.

A la Part 8 aprofundirem en les difer√®ncies t√®cniques, per√≤ per ara queda't amb aix√≤.

## Prova-ho tu!

Anem a posar a prova el que has apr√®s. Has de definir una interf√≠cie i crear un objecte espec√≠fic per passar la validaci√≥ oculta.

**Requisits de l'exercici:**

1.  Defineix una interf√≠cie anomenada `Videojoc` amb:
    *   `titol` (string)
    *   `any` (number)
    *   `plataforma` (opcional, string)
2.  Crea un objecte constant anomenat `jocPreferit` que implementi aquesta interf√≠cie.
3.  Les dades han de ser exactament: **"The Legend of Zelda"**, any **1986**.

import validationCode from './validation.ca.ts?raw';

<TSEditor
  client:only="react"
  showConsole={true}
  files={{
    'main.ts': `// 1. Defineix la teva interf√≠cie 'Videojoc' aqu√≠
// interface Videojoc ...


// 2. Crea l'objecte 'jocPreferit' amb les dades demanades
const jocPreferit = {

};

console.log("Resultat:", jocPreferit);`
  }}
  validationCode={validationCode}
  successSound="/audio/grunt-birthday-party-sound.mp3"
/>

A la **Part 4**, veurem qu√® passa quan tenim molts objectes iguals... √©s a dir, **Arrays**.
