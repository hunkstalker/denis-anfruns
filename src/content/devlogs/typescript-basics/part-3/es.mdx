---
description: C√≥mo dar forma a tus datos. Interfaces, Types y por qu√© "any" es tu enemigo.
draft: false
lang: es
new: true
pubDate: '2025-12-16T18:00:00Z'
series: typescript-basics
seriesDescription: {"es": "Aprende TypeScript desde cero profundizando en conceptos como inferencia y tipos.", "en": "Learn TypeScript from scratch diving deep into inference and types."}
seriesTitle: {"es": "Fundamentos de TypeScript", "en": "TypeScript Basics"}
tags: ['typescript', 'learning', 'series']
title: 'TypeScript # 3: Objetos e Interfaces'
---

import CodeTabs from '../../../../components/mdx/CodeTabs.astro';
import Callout from '../../../../components/mdx/Callout.astro';
import TSEditor from '../../../../components/learn/TSEditor.tsx';

Hasta ahora hemos visto tipos primitivos (`string`, `number`, `boolean`). Pero el mundo real funciona con **objetos**.
Usuarios, Productos, Pedidos... todos son objetos con m√∫ltiples propiedades.

## La Anarqu√≠a de los Objetos An√≥nimos

En JavaScript puro, solemos pasar objetos de un lado a otro confiando en nuestra memoria.

<CodeTabs
  status="error"
  items={[
    {
		label: 'JavaScript (Anarqu√≠a)',
		code: `function imprimirUsuario(usuario) {
    // ü§û Esperemos que 'usuario' tenga estas propiedades...
    console.log("Nombre: " + usuario.name.toUpperCase());
    console.log("Edad: " + usuario.age);
}

// Un mes despu√©s, alguien llama a la funci√≥n as√≠:
imprimirUsuario({ nombre: "Denis", edad: 40 }); 
// üí• CRASH: Cannot read properties of undefined (reading 'toUpperCase')
// ¬øPor qu√©? Porque pasamos "nombre" en espa√±ol pero la funci√≥n esperaba "name" en ingl√©s.`,
		lang: 'javascript'
    }
]} />

TypeScript evita esto oblig√°ndonos a definir la **FORMA** (Shape) de nuestros objetos.

## Interfaces: El Contrato

Una `interface` es como un contrato. Si un objeto dice ser un `Usuario`, **DEBE** cumplir el contrato.

<CodeTabs
  status="success"
  items={[
    {
		label: 'TypeScript',
		code: `interface Usuario {
    name: string;
    age: number;
    isDeveloper: boolean;
}

const denis: Usuario = {
    name: "Denis",
    age: 39,
    isDeveloper: true
}; // ‚úÖ Cumple el contrato

const pepe: Usuario = {
    name: "Pepe"
}; // ‚ùå Error: Faltan las propiedades 'age' e 'isDeveloper'`,
		lang: 'typescript'
    }
]} />

## Propiedades Opcionales (`?`)

A veces no tenemos todos los datos. Quiz√°s el `email` es opcional.
Para eso usamos el signo de interrogaci√≥n `?` despu√©s del nombre de la propiedad.

<CodeTabs items={[
    {
		label: 'TypeScript',
		code: `interface Producto {
    id: number;
    nombre: string;
    descripcion?: string; // üëà Opcional (string | undefined)
}

const mesa: Producto = {
    id: 1,
    nombre: "Mesa de escritorio"
    // No hace falta poner descripci√≥n
};`,
		lang: 'typescript'
    }
]} />

## Propiedades de Solo Lectura (`readonly`)

Si queremos asegurarnos de que una propiedad **nunca cambie** despu√©s de crear el objeto (como un ID), usemos `readonly`.

<CodeTabs items={[
    {
		label: 'TypeScript',
		code: `interface Configuracion {
    readonly apiKey: string;
    theme: "light" | "dark";
}

const config: Configuracion = {
    apiKey: "xyz-123",
    theme: "light"
};

config.theme = "dark"; // ‚úÖ Puedes cambiarlo
config.apiKey = "abc-999"; // ‚ùå Error: Cannot assign to 'apiKey' because it is a read-only property.`,
		lang: 'typescript'
    }
]} />

## ¬ø`type` vs `interface`?

Veremos gente usando `type Usuario = { ... }` en lugar de `interface Usuario { ... }`.
Para definir la forma de un objeto, ambos funcionan casi igual.

> **Regla de oro (por ahora):**
> *   Usemos **`interface`** para definir objetos que representan entidades (Usuario, Post, Producto).
> *   Usemos **`type`** para Uniones (`string | number`), primitivos o tuplas.

En la Parte 8 profundizaremos en las diferencias t√©cnicas, pero por ahora qued√©monos con eso.

## ¬°Intent√©moslo!

Vamos a poner a prueba lo aprendido. Tenemos que definir una interfaz y crear un objeto espec√≠fico para pasar la validaci√≥n.

**Requisitos del ejercicio:**

1.  Definamos una interfaz llamada `Videojuego` con:
    *   `titulo` (string)
    *   `anio` (number) ‚Äî *Usamos `anio` para evitar la `√±` en c√≥digo.*
    *   `plataforma` (opcional, string)
2.  Creemos un objeto constante llamado `juegoFavorito` que implemente esa interfaz.
3.  Los datos deben ser exactamente: **"The Legend of Zelda"**, a√±o **1986**.

<Callout type="party" title="¬°Ey!">
    <p>Probemos a activar el volumen del editor antes de darle al bot√≥n > Run cuando vayamos a resolver el ejercicio!</p>
</Callout>

import validationCode from './validation.ts?raw';

<TSEditor
  client:only="react"
  showConsole={true}
  validationCode={validationCode}
  successSound="/audio/grunt-birthday-party-sound.mp3"
  files={{
    'main.ts': `// 1. Definamos nuestra interface 'Videojuego' aqu√≠
// interface Videojuego ...


// 2. Creamos el objeto 'juegoFavorito' con los datos pedidos
const juegoFavorito = {

};

console.log("Resultado:", juegoFavorito);`
  }}
/>

En la **Parte 4**, veremos qu√© pasa cuando tenemos muchos objetos iguales... es decir, **Arrays**.
