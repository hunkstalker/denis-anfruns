---
pubDate: '2026-01-19T10:00:00Z'
tags: ['godot', 'gdscript', 'math', 'vectors']
draft: true
new: true
title: 'Godot #1: Vectores y Movimiento'
description: Entendiendo las matem√°ticas detr√°s del movimiento. ¬øPor qu√© normalizamos? ¬øQu√© es Delta? Explicado para humanos.
series: godot-basics
seriesTitle: Godot & Game Dev Science
seriesDescription: Aprende Godot creando un Space Shooter desde cero, con √©nfasis en Matem√°ticas y Shaders.
lang: es
---

import Callout from '../../../../components/mdx/Callout.astro';
import CodeTabs from '../../../../components/mdx/CodeTabs.astro';
import VectorDemo from '../../../../components/mdx/interactive/VectorDemo.tsx';

## La Nave y las Matem√°ticas

En este cap√≠tulo vamos a crear nuestra nave y a hacer que se mueva. Pero no vamos a copiar un script. Vamos a entender **por qu√©** se mueve. Y para eso, tenemos que hablar de nuestra amiga (o enemiga): **La Flecha (El Vector)**.

<Callout type="tip" title="¬øNecesitas gr√°ficos?">
  Para seguir este curso, necesitar√°s una nave. Si no tienes una a mano, te recomendamos encarecidamente el pack gratuito de **[Kenney Space Shooter Extension](https://kenney.nl/assets/space-shooter-extension)**. Es limpio, bonito y perfecto para aprender.
  
  ¬øNecesitas editar las im√°genes? No hace falta piratear nada. Tienes la suite **[Affinity Studio](https://www.affinity.studio/)** disponible de forma gratuita en la web.
</Callout>

### 1. El Escenario (Plano Cartesiano)

Tu monitor es una cuadr√≠cula de p√≠xeles.
*   **X (Horizontal)**: Crece hacia la derecha.
*   **Y (Vertical)**: Crece hacia **ABAJO**.

<Callout type="warning" title="¬°Cuidado con la Y!">
  En matem√°ticas del colegio, la Y crece hacia arriba. En Game Dev, la Y crece hacia abajo (porque empezamos a dibujar desde la esquina superior izquierda). No lo olvides o tu nave volar√° al rev√©s.
</Callout>

### 2. La Elecci√≥n del Nodo (Tu Nave)

En la intro dijimos que "Todo es una Escena". Cierto, pero... ¬øde qu√© est√° hecha una escena? **De Nodos**.
Si la Escena es la casa, los Nodos son los ladrillos. Y hay muchos tipos de ladrillos:

1.  **Node2D**: Es la base **para el mundo 2D**. Tiene posici√≥n `(x, y)`, rotaci√≥n y escala. (Si estuvi√©ramos en 3D ser√≠a `Node3D`, y para interfaces `Control`, pero aqu√≠ vivimos en el plano).
2.  **RigidBody2D**: Tiene f√≠sica real (gravedad, rebotes). Si le das una patada, sale volando. Dif√≠cil de controlar para un personaje principal.
3.  **CharacterBody2D**: El t√©rmino medio perfecto. Tiene posici√≥n (como Node2D) y sabe chocarse (como RigidBody), pero **no se mueve solo**. T√ö eres el motor. Es el est√°ndar para personajes en juegos 2D.

**Pasos:**
1.  Crea una **Nueva Escena**.
2.  El nodo ra√≠z ser√° un `CharacterBody2D` (por lo que acabamos de explicar: queremos control total). Ll√°malo `Player`.
3.  El nodo se quejar√° con una alerta ‚ö†Ô∏è. Te est√° diciendo: *"¬°Oye, tengo cuerpo f√≠sico pero no tengo forma! ¬øSoy un c√≠rculo? ¬øUn cuadrado?"*.
4.  A√±ade un hijo `CollisionShape2D` y en el inspector dale forma de `Capsule` o `Circle`.
5.  A√±ade un hijo `Sprite2D` para que se vea bonito (arrastra tu imagen de la nave a la propiedad Texture).
6.  Guarda como `Player.tscn`.

### 3. El Problema de "Moverse"

Para mover la nave, necesitamos decirle hacia d√≥nde ir. Aqu√≠ entran los **Vectores**.

Un vector no es m√°s que una flecha. En videojuegos, cuando esa flecha nos indica "hacia d√≥nde", la llamamos **Vector de Direcci√≥n**.
*   Si tocas **Derecha**, el vector apunta a `(1, 0)`.
*   Si tocas **Abajo**, el vector apunta a `(0, 1)`.

En Godot, esto se llama `Input.get_vector()`.

Pero obtener el vector no mueve la nave. Solo nos dice "hacia d√≥nde quiere ir el jugador".
Para moverla, necesitamos dos cosas m√°gicas que viven dentro de `CharacterBody2D`:

1.  **`velocity` (Velocidad)**: Es una variable interna. Imag√≠nala como el veloc√≠metro de la nave. T√∫ le dices "Ponte a 300 km/h siguiendo este vector".
2.  **`move_and_slide()`**: Esta funci√≥n es el motor. Le dices "¬°Arranca!". Y ella sola busca la variable `velocity` y mueve la nave esa cantidad, choc√°ndose si hace falta.

**No tienes que pasarle `velocity` a `move_and_slide()`. Lo hace solo.**

Aqu√≠ tienes el c√≥digo completo. **Te recomiendo escribirlo a mano** para memorizar los comandos, pero si tienes prisa, puedes copiarlo.

<CodeTabs
  items={[
    {
      label: 'Player.gd',
      lang: 'gdscript',
      code: `extends CharacterBody2D

func _physics_process(delta):
    # Pedimos al Input que nos construya el Vector de Direcci√≥n basado en las teclas
    # "ui_left", "ui_right", "ui_up", "ui_down" son acciones por defecto en Godot
    var direccion = Input.get_vector("ui_left", "ui_right", "ui_up", "ui_down")
    
    velocity = direccion * 300
    move_and_slide()`
    }
  ]}
/>

### 4. ¬øPor qu√© corres m√°s en diagonal? (Pit√°goras)

Si presionas **Derecha** `(1, 0)` y **Abajo** `(0, 1)` a la vez, Godot suma los vectores. El resultado es `(1, 1)`.

¬øCu√°nto mide ese vector `(1, 1)`? Aqu√≠ es donde entra nuestro amigo griego.

Imagina que est√°s en una ciudad cuadriculada (como el Eixample de Barcelona o Manhattan):
*   Caminar 1 calle al Este cuesta **1 minuto**.
*   Caminar 1 calle al Sur cuesta **1 minuto**.
*   Si caminas Este y luego Sur, tardas **2 minutos** en total.

Pero, **¬øy si atraviesas la calle en diagonal?**
Aqu√≠ entra el se√±or Pit√°goras con su famoso **Teorema**. No te asustes, vamos a diseccionarlo pieza a pieza:

$$
h = \sqrt{a^2 + b^2}
$$

**¬øQu√© significa cada letra?**
*   **$h$ (Hipotenusa)**: Es la distancia larga, la **longitud (magnitud)** del vector.
*   **$a$ y $b$ (Catetos)**: Son los lados rectos. En nuestro caso, el movimiento en **X** (1 paso) y en **Y** (1 paso).

**¬°Saca la calculadora! De verdad, hazlo.**
Vamos a sustituir las letras por nuestros n√∫meros (1 derecha, 1 abajo):

1.  **Elevamos al cuadrado**: $1^2$ significa $1 \times 1$. Sigue siendo $1$.
    
    Resultado:
    $$ h = \sqrt{1 + 1} $$
2.  **Sumamos**: $1 + 1 = 2$.

    Resultado:
    $$ h = \sqrt{2} $$
3.  **Ra√≠z cuadrada**: Busca el bot√≥n $\sqrt{}$ en tu calculadora del m√≥vil y pon $2$.

    Resultado:
    $$ h \approx 1.41421356... $$

<Callout type="info" title="Diccionario Gamer ü§ì">
  En videojuegos y matem√°ticas, a esta longitud $h$ la llamamos **Magnitud** o **M√≥dulo** del vector.
  Tambi√©n es conocida como **Distancia Euclidiana** (la l√≠nea recta entre dos puntos).
  
  Cuando hacemos `input_vector.length()` en Godot, el motor hace este c√°lculo de Pit√°goras por ti.
</Callout>

¬°Ah√≠ lo tienes!
Si no hacemos nada, tu direcci√≥n tiene una fuerza de **1.41**.
Comparado con la fuerza de **1.0** cuando vas recto, **¬°est√°s corriendo un 41% m√°s r√°pido!**

<VectorDemo client:visible />

Esto es un problema cl√°sico ("Speedrunning hack"). En un juego competitivo, todos ir√≠an en diagonal para llegar antes.

#### La Soluci√≥n: Normalizar

Normalizar un vector significa: **"No me importa lo largo que sea el vector (la flecha), c√≥rtalo para que mida exactamente 1, pero mant√©n la direcci√≥n".**

Godot es listo. `Input.get_vector()` **YA normaliza** el resultado por defecto.
Es importante saberlo porque en matem√°ticas de shaders o IA, tendr√°s que usar `.normalized()` manualmente muchas veces cuando solo te importe la **direcci√≥n** ($ \hat{v} $) y no la fuerza.

### 5. ¬øQu√© demonios es `delta`?

Ver√°s `delta` en todos los tutoriales.

<CodeTabs
  items={[
    {
      label: 'F√≠sica B√°sica',
      lang: 'gdscript',
      code: `position += velocity * delta`
    }
  ]}
  hideTabs={true}
/>

Imagina que tu juego va a **60 FPS** (im√°genes por segundo). Tu c√≥digo se ejecuta 60 veces por segundo.
Ahora imagina que a tu amigo le va a **144 FPS**. Su c√≥digo se ejecuta 144 veces por segundo.

Si sumas `position += 1` en cada frame:
*   T√∫ avanzas 60 p√≠xeles cada segundo.
*   Tu amigo avanza 144 p√≠xeles cada segundo.

¬°Tu amigo es m√°s r√°pido solo por tener mejor PC! Eso es injusto (y rompe la f√≠sica).

**Delta** es el **tiempo que ha pasado desde el √∫ltimo frame**.
*   Si vas a 60 FPS, delta es `1/60` (aprox 0.016s).
*   Si vas a 144 FPS, delta es `1/144` (aprox 0.006s).

Si multiplicas por delta:
*   T√∫: `1 * 60 veces * 0.016 = 1` metro por segundo.
*   Amigo: `1 * 144 veces * 0.006 = 1` metro por segundo.

**Conclusi√≥n**: Multiplicar por Delta convierte "P√≠xeles por Frame" en "P√≠xeles por Segundo". Hace que el juego vaya igual en un banano que en un PC de la NASA.

<Callout type="tip" title="Nota de Godot">
  `move_and_slide()` usa `delta` autom√°ticamente dentro, por eso en el c√≥digo de arriba no lo ves multiplicando. Pero si mueves cosas manualmente cambiando `position`, SIEMPRE usa delta.
</Callout>

### 6. Script Final üèÜ (Por ahora)

Antes de copiar, mira dos detalles nuevos:
1.  **`@export`**: Esta palabra m√°gica hace que la variable `speed` aparezca en el **Inspector** de Godot. As√≠ puedes ajustar la velocidad escribiendo un n√∫mero en la cajita sin volver a abrir el script.
2.  **`direction * speed`**: Recuerda que `direction` vale **1** (es un Vector Unitario). Es solo la direcci√≥n pura. Al multiplicarlo por **400**, convertimos ese 1 en 400 p√≠xeles por segundo.
    *   Esto significa: **"Mu√©vete 400 p√≠xeles por segundo en esa direcci√≥n"**.

<CodeTabs
  items={[
    {
      label: 'Player.gd',
      lang: 'gdscript',
      code: `extends CharacterBody2D

@export var speed = 400

func _physics_process(delta):
	var direction = Input.get_vector("ui_left", "ui_right", "ui_up", "ui_down")
	
	velocity = direction * speed
	move_and_slide()`
    }
  ]}
/>

¬°Felicidades! Tienes una nave que se mueve consistentemente en todas direcciones y en todos los ordenadores.
