---
pubDate: '2026-01-11T10:00:00Z'
tags: ['godot', 'gdscript', 'math', 'vectors']
draft: false
new: true
title: 'Godot #1: Vectores y Movimiento'
description: Entendiendo las matem√°ticas detr√°s del movimiento. ¬øPor qu√© normalizamos? ¬øQu√© es Delta? Explicado para humanos.
series: gamedev-godot-basics
seriesTitle: Game Dev con Godot
seriesDescription: Aprendemos los fundamentos del desarrollo de videojuegos (vectores, trigonometr√≠a, shaders) usando Godot y un Shoot 'em Up como excusa pr√°ctica.
lang: es
---

import Callout from '../../../../components/mdx/Callout.astro';
import CodeTabs from '../../../../components/mdx/CodeTabs.astro';
import VectorDemo from '../../../../components/mdx/interactive/VectorDemo.tsx';

## La Nave y las Matem√°ticas

En este cap√≠tulo vamos a crear nuestra nave y a hacer que se mueva. Pero no vamos a copiar un script. Vamos a entender **por qu√©** se mueve. Y para eso, tenemos que hablar de nuestra amiga (o enemiga): **La Flecha (El Vector)**.

<Callout type="tip" title="¬øNecesitas gr√°ficos?">
  Para seguir este curso, necesitar√°s una nave. Si no tienes una a mano, te recomendamos encarecidamente el pack gratuito de **[Kenney Space Shooter Extension](https://kenney.nl/assets/space-shooter-extension)**. Es limpio, bonito y perfecto para aprender.
  
  ¬øNecesitas editar las im√°genes? No hace falta piratear nada. Tienes la suite **[Affinity Studio](https://www.affinity.studio/)** disponible de forma gratuita en la web.
</Callout>

### 1. El Escenario (Plano Cartesiano)

Tu monitor es una cuadr√≠cula de p√≠xeles.
*   **X (Horizontal)**: Crece hacia la derecha.
*   **Y (Vertical)**: Crece hacia **ABAJO**.

<Callout type="warning" title="¬°Cuidado con la Y!">
  En matem√°ticas del colegio, la Y crece hacia arriba. En Game Dev, la Y crece hacia abajo (porque empezamos a dibujar desde la esquina superior izquierda). No lo olvides o tu nave volar√° al rev√©s.
</Callout>

### 2. La Elecci√≥n del Nodo (Tu Nave)

En la intro dijimos que "Todo es una Escena". Cierto, pero... ¬øde qu√© est√° hecha una escena? **De Nodos**.
Si la Escena es la casa, los Nodos son los ladrillos. Y hay muchos tipos de ladrillos:

1.  **Node2D**: Es la base **para el mundo 2D**. Tiene posici√≥n `(x, y)`, rotaci√≥n y escala. (Si estuvi√©ramos en 3D ser√≠a `Node3D`, y para interfaces `Control`, pero aqu√≠ vivimos en el plano).
2.  **RigidBody2D**: Tiene f√≠sica real (gravedad, rebotes). Si le das una patada, sale volando. Dif√≠cil de controlar para un personaje principal.
3.  **CharacterBody2D**: El t√©rmino medio perfecto. Tiene posici√≥n (como Node2D) y sabe chocarse (como RigidBody), pero **no se mueve solo**. T√ö eres el motor. Es el est√°ndar para personajes en juegos 2D.

#### Prepara tus Assets
Antes de empezar, necesitas una nave. Puedes dibujar una o usar esta de prueba:

![Nave del Jugador](/assets/gamedev-godot-basics/player.png)

> Clic derecho -> Guardar imagen.  
> *Cr√©ditos: <a href="https://puszke.itch.io/psx-plane" target="_blank" rel="noopener noreferrer">PSX Plane</a> por **Puck**.*

1.  Crea una carpeta llamada `sprites` en tu FileSystem.
2.  Arrastra esta imagen dentro.

**Pasos:**
1.  En la escena vac√≠a que aparece por defecto:
2.  En el panel de "Create Root Node", selecciona **Other Node**.
3.  Escribe `CharacterBody2D` en el buscador y dale doble clic. Esto crear√° una nueva escena con este nodo como ra√≠z. Ll√°malo `Player`.
4.  El nodo se quejar√° con una alerta ‚ö†Ô∏è. Te est√° diciendo: *"¬°Oye, tengo cuerpo f√≠sico pero no tengo forma! ¬øSoy un c√≠rculo? ¬øUn cuadrado?"*.
5.  A√±ade como hijo de `CharacterBody2D` un nodo llamado `CollisionShape2D`.
    *   En el Inspector, donde dice **Shape**, selecciona `New CircleShape2D`.
    *   **Importante**: Haz clic sobre el recuadro que pone "CircleShape2D" (se expandir√°).
    *   En **Radius**, escribe `40 px`. Esto ajustar√° el tama√±o exacto sin escalar el nodo.
6.  A√±ade otro nodo hijo `Sprite2D` para que se vea bonito (arrastra tu imagen de la nave a la propiedad Texture).
7.  Crea una carpeta llamada `scenes` en la ra√≠z del proyecto y guarda dentro la escena como `player.tscn`.

<Callout type="info" title="Regla de oro: Hitbox vs Sprite">
  En Game Design, hay una regla no escrita: **"Mejor que sobre a que falte"**.
  
  *   Si tu colisi√≥n es **m√°s grande** que la nave, el jugador gritar√° *"¬°Pero si no me ha tocado!"* cuando muera por el aire. Eso se siente **injusto**.
  *   Si tu colisi√≥n es **un poco m√°s peque√±a**, permites que las balas "rocen" la nave sin matarla. Eso genera momentos de *"¬°Uff, casi!"* que se sienten **√©picos**.
  
  Dale siempre un poco de ventaja al jugador. Haz el `CollisionShape` un 10-20% m√°s peque√±o que el dibujo visible.
</Callout>

### 3. Conceptos B√°sicos de GDScript

Antes de escribir c√≥digo, necesitas saber leer el mapa. Si nunca has programado, esto es todo lo que necesitas saber por ahora:

1.  **`extends` (Herencia)**:
    Es la primera l√≠nea. Le dice a Godot: *"Soy una extensi√≥n de..."*.
    
    * `extends CharacterBody2D`: Si extiendes de como en este caso `CharacterBody2D` significar√° que ahora el script tiene todos los m√©todos y propiedades de un CharacterBody2D, m√°s lo que a√±adas.
    
    Esto se llama **Herencia de Clases**. Es un concepto fundamental de programaci√≥n orientada a objetos. Tu script no empieza de cero: hereda un "veh√≠culo" ya funcional con ruedas, motor y volante (`CharacterBody2D`), y t√∫ solo a√±ades la personalizaci√≥n (tu l√≥gica de movimiento).
2.  **`func` (Acci√≥n/Verbo)**:
    Es una orden o tarea. Agrupa una lista de pasos.
    *   `func _physics_process(delta)`: Es una funci√≥n especial que Godot llama a un ritmo fijo (por defecto **60 veces por segundo**). Todo lo que escribas dentro, se repetir√° en bucle para mover cosas.
3.  **`var` (Variable)**:
    Es un lugar donde guardamos informaci√≥n **en la memoria RAM** del ordenador.
    *   `var velocidad = 300`: Hemos reservado un hueco en la memoria, le hemos puesto la etiqueta "velocidad" y hemos guardado el n√∫mero 300 dentro.

<Callout type="warning" title="Peligro: Tabs vs Espacios">
  GODOT NO PERDONA.
  La "sangr√≠a" (esos espacios a la izquierda) define qu√© c√≥digo est√° dentro de qu√© funci√≥n.
  *   Usa siempre **Tabulaciones** (Tecla Tab ‚Üπ), no espacios.
  *   **Nunca mezcles** tabs y espacios en el mismo archivo o tendr√°s errores invisibles.
  *   *Nota: El bot√≥n de copiar de esta web intenta convertir espacios a Tabs autom√°ticamente, pero si ves errores rojos, revisa esto primero.*
</Callout>

### 4. Creando el Script

Nuestra nave es bonita, pero no hace nada. Necesitamos un **Script**.

1.  Crea una carpeta en la ra√≠z llamada `scripts`.
2.  Selecciona el nodo ra√≠z `Player`.
3.  Haz clic en el icono del **Pergamino con un `+` verde** (arriba del panel de escena). O dale click derecho -> **Attach Script**.
4.  Aparecer√° una ventana.
5.  **Template**: D√©jalo en `CharacterBody2D: Basic Movement` si quieres ver mucho c√≥digo complejo, o pon `Empty` para empezar limpio. Nosotros borraremos todo, as√≠ que da igual.
6.  **Path**: Aqu√≠ est√° la clave. No lo tires en la ra√≠z. Escribe `res://scripts/player.gd`.
7.  Dale a **Create**.

Ahora ver√°s un editor de texto. ¬°Bienvenido a tu primer programa!

### 5. El Problema de "Moverse"

Para mover la nave, necesitamos decirle hacia d√≥nde ir. Aqu√≠ entran los **Vectores**.

Un vector no es m√°s que una flecha. En videojuegos, cuando esa flecha nos indica "hacia d√≥nde", la llamamos **Vector de Direcci√≥n**.
*   Si tocas **Derecha**, el vector apunta a `(1, 0)`.
*   Si tocas **Abajo**, el vector apunta a `(0, 1)`.

En Godot, esto se llama `Input.get_vector()`.

Pero obtener el vector no mueve la nave. Solo nos dice "hacia d√≥nde quiere ir el jugador".
Para moverla, necesitamos dos cosas m√°gicas que viven dentro de `CharacterBody2D`:

1.  **`velocity` (Velocidad)**: Es una variable interna. Imag√≠nala como el veloc√≠metro de la nave. T√∫ le dices "Ponte a 300 km/h siguiendo este vector".
2.  **`move_and_slide()`**: Esta funci√≥n es el motor. Le dices "¬°Arranca!". Y ella sola busca la variable `velocity` y mueve la nave esa cantidad, choc√°ndose si hace falta.

**No tienes que pasarle `velocity` a `move_and_slide()`. Lo hace solo.**


Aqu√≠ tienes el c√≥digo completo. **Te recomiendo escribirlo a mano** para memorizar los comandos, pero si tienes prisa, puedes copiarlo.

<CodeTabs
  items={[
    {
      label: 'player.gd',
      lang: 'gdscript',
      code: `extends CharacterBody2D

func _physics_process(delta):
    var direction = Input.get_vector("move_left", "move_right", "move_up", "move_down")
    
    velocity = direction * 400
    move_and_slide()`
    }
  ]}
/>

**Desglose l√≠nea a l√≠nea:**

**1. `extends CharacterBody2D`**

Ya sabemos que esto es herencia. Aqu√≠ lo usamos concretamente para **desbloquear la variable `velocity`**. Si extendi√©ramos de un simple `Node2D`, esta variable no existir√≠a y tendr√≠amos que calcular la f√≠sica manualmente. Al heredar de `CharacterBody2D`, ganamos todo el sistema de colisiones sin tener que reescribir a mano toda una l√≥gica que ya nos da CharacterBody2D.

**2. `func _physics_process(delta):`**

Usamos el bucle de f√≠sicas (y no el `_process` normal) porque `move_and_slide()` necesita una **estabilidad perfecta** para calcular choques. Si us√°ramos el loop visual, la nave podr√≠a atravesar paredes si el juego va lento. Aqu√≠ nos aseguramos de que el movimiento sea s√≥lido como una roca.

**3. `var direction = Input.get_vector(...)`**

| Tecla(s) presionada(s) | Valor de `direction` |
|------------------------|----------------------|
| Ninguna | `(0, 0)` |
| Derecha | `(1, 0)` |
| Abajo | `(0, 1)` |
| Derecha + Abajo | `(0.707, 0.707)` ‚Üê ¬°Normalizado! |

`Input.get_vector()` lee las teclas y construye un vector de direcci√≥n. **Ya viene normalizado** (magnitud 1), as√≠ que moverse en diagonal no es m√°s r√°pido que moverse recto.

**¬øPero qu√© es "move_right"?**
Si intentas ejecutar el c√≥digo ahora, **no funcionar√°**. Godot no sabe qu√© teclas son esas. Tienes que configurarlas t√∫ para definir qu√© significa "mover a la derecha" (puede ser la tecla D, la Flecha Derecha o el Joystick).

**Config√∫ralo ahora:**
1.  Ve a **Project > Project Settings > Input Map**.
2.  Escribe `move_right` en la barra "**Add New Action**" y pulsa **Add**.
3.  Busca la nueva acci√≥n en la lista inferior y pulsa el bot√≥n **+** a su derecha.
4.  Pulsa la tecla **D** (y opcionalmente la tecla Flecha Derecha) y dale a **OK**.
5.  Repite el proceso para el resto:
    *   `move_left`: Tecla **A**.
    *   `move_up`: Tecla **W**.
    *   `move_down`: Tecla **S**.
  
Si quieres, puedes adicionalmente en cada acci√≥n a√±adir por ejemplo el joystick (stick izquierdo) y al cruceta (d-pad).

**4. `velocity = direction * 300`**

La direcci√≥n es un vector de magnitud 1. Al multiplicar por 300, obtenemos "300 p√≠xeles por segundo en esa direcci√≥n". Es como decir: "Apunta hacia all√° y ve a 300 de velocidad".

**5. `move_and_slide()`**

Esta funci√≥n lee `velocity` autom√°ticamente (no hace falta pas√°rselo) y mueve el nodo. Adem√°s, gestiona colisiones: si hay una pared, "desliza" en vez de quedarse pegado. Por eso se llama "move and slide".


### 4. ¬øPor qu√© corres m√°s en diagonal? (Pit√°goras)

Si presionas **Derecha** `(1, 0)` y **Abajo** `(0, 1)` a la vez, Godot suma los vectores. El resultado es `(1, 1)`.

¬øCu√°nto mide ese vector `(1, 1)`? Aqu√≠ es donde entra nuestro amigo griego.

Imagina que est√°s en una ciudad cuadriculada (como el Eixample de Barcelona o Manhattan):
*   Caminar 1 calle al Este cuesta **1 minuto**.
*   Caminar 1 calle al Sur cuesta **1 minuto**.
*   Si caminas Este y luego Sur, tardas **2 minutos** en total.

Pero, **¬øy si atraviesas la calle en diagonal?**
Aqu√≠ entra el se√±or Pit√°goras con su famoso **Teorema**. No te asustes, vamos a diseccionarlo pieza a pieza:

$$
h = \sqrt{a^2 + b^2}
$$

**¬øQu√© significa cada letra?**
*   **$h$ (Hipotenusa)**: Es la distancia larga, la **longitud (magnitud)** del vector.
*   **$a$ y $b$ (Catetos)**: Son los lados rectos. En nuestro caso, el movimiento en **X** (1 paso) y en **Y** (1 paso).

**¬°Saca la calculadora! De verdad, hazlo.**
Vamos a sustituir las letras por nuestros n√∫meros (1 derecha, 1 abajo):

1.  **Elevamos al cuadrado**: $1^2$ significa $1 \times 1$. Sigue siendo $1$.
    
    Resultado:
    $$ h = \sqrt{1 + 1} $$
2.  **Sumamos**: $1 + 1 = 2$.

    Resultado:
    $$ h = \sqrt{2} $$
3.  **Ra√≠z cuadrada**: Busca el bot√≥n $\sqrt{}$ en tu calculadora del m√≥vil y pon $2$.

    Resultado:
    $$ h \approx 1.41421356... $$

<Callout type="info" title="Diccionario Gamer ü§ì">
  En videojuegos y matem√°ticas, a esta longitud $h$ la llamamos **Magnitud** o **M√≥dulo** del vector.
  Tambi√©n es conocida como **Distancia Euclidiana** (la l√≠nea recta entre dos puntos).
  
  Cuando hacemos `input_vector.length()` en Godot, el motor hace este c√°lculo de Pit√°goras por ti.
</Callout>

¬°Ah√≠ lo tienes!
Si no hacemos nada, tu direcci√≥n tiene una fuerza de **1.41**.
Comparado con la fuerza de **1.0** cuando vas recto, **¬°est√°s corriendo un 41% m√°s r√°pido!**

<VectorDemo client:visible />

Esto es un problema cl√°sico ("Speedrunning hack"). En un juego competitivo, todos ir√≠an en diagonal para llegar antes.

#### La Soluci√≥n: Normalizar

Normalizar un vector significa: **"No me importa lo largo que sea el vector (la flecha), c√≥rtalo para que mida exactamente 1, pero mant√©n la direcci√≥n".**

Godot es listo. `Input.get_vector()` **YA normaliza** el resultado por defecto.
Es importante saberlo porque en matem√°ticas de shaders o IA, tendr√°s que usar `.normalized()` manualmente muchas veces cuando solo te importe la **direcci√≥n** ($ \hat{v} $) y no la fuerza.

### 5. ¬øQu√© demonios es `delta`?

Ver√°s `delta` en todos los tutoriales.

<CodeTabs
  items={[
    {
      label: 'ejemplo.gd',
      lang: 'gdscript',
      code: `position += velocity * delta`
    }
  ]}
/>

Imagina que tu juego va a **60 FPS** (im√°genes por segundo). Tu c√≥digo se ejecuta 60 veces por segundo.
Ahora imagina que a tu amigo le va a **144 FPS**. Su c√≥digo se ejecuta 144 veces por segundo.

Si sumas `position += 1` en cada frame:
*   T√∫ avanzas 60 p√≠xeles cada segundo.
*   Tu amigo avanza 144 p√≠xeles cada segundo.

¬°Tu amigo es m√°s r√°pido solo por tener mejor PC! Eso es injusto (y rompe la f√≠sica).

**Delta** es el **tiempo que ha pasado desde el √∫ltimo frame**.
*   Si vas a 60 FPS, delta es `1/60` (aprox 0.016s).
*   Si vas a 144 FPS, delta es `1/144` (aprox 0.006s).

Si multiplicas por delta:
*   T√∫: `1 * 60 veces * 0.016 = 1` metro por segundo.
*   Amigo: `1 * 144 veces * 0.006 = 1` metro por segundo.

**Conclusi√≥n**: Multiplicar por Delta convierte "P√≠xeles por Frame" en "P√≠xeles por Segundo". Hace que el juego vaya igual en un banano que en un PC de la NASA.

<Callout type="tip" title="Nota de Godot">
  `move_and_slide()` usa `delta` autom√°ticamente dentro, por eso en el c√≥digo de arriba no lo ves multiplicando. Pero si mueves cosas manualmente cambiando `position`, SIEMPRE usa delta.
</Callout>

### 6. Script Final (Por ahora)

Antes de copiar, mira dos detalles nuevos:
1.  **`@export`**: Esta palabra m√°gica hace que la variable `speed` aparezca en el **Inspector** de Godot. As√≠ puedes ajustar la velocidad escribiendo un n√∫mero en la cajita sin volver a abrir el script.
2.  **`direction * speed`**: Recuerda que `direction` vale **1** (es un Vector Unitario). Es solo la direcci√≥n pura. Al multiplicarlo por **400**, convertimos ese 1 en 400 p√≠xeles por segundo.
    *   Esto significa: **"Mu√©vete 400 p√≠xeles por segundo en esa direcci√≥n"**.

<CodeTabs
  items={[
    {
      label: 'player.gd',
      lang: 'gdscript',
      code: `extends CharacterBody2D
    
@export var speed = 400

func _physics_process(delta):
    var direction = Input.get_vector("move_left", "move_right", "move_up", "move_down")
    
    velocity = direction * speed
    move_and_slide()`
    }
  ]}
/>

¬°Felicidades! Tienes una nave que se mueve consistentemente en todas direcciones.

### 7. Probando todo: Tu Primer Nivel (Sandbox)

Hasta ahora hemos trabajado en el "taller" (la escena del `Player`). Pero una nave necesita un universo.
Si le das al bot√≥n de **Play (F5)** ahora, te pedir√° una escena principal. Vamos a crearla:

1.  Crea una **Nueva Escena**.
2.  Elige **2D Scene** (Node2D). Esta vez no queremos f√≠sicas, solo un contenedor para el mundo. Ll√°malo `Level` (PascalCase, porque es un Nodo).
3.  Gu√°rdala en `scenes/level.tscn` (snake_case, porque es un archivo).

#### Instanciando al Jugador (El "Link")
Aqu√≠ ocurre la magia de Godot. No vamos a "copiar y pegar" al jugador. Vamos a **referenciarlo**.
1.  Busca tu archivo `player.tscn` en la carpeta `scenes` (abajo a la izquierda).
2.  **Arr√°stralo** desde el explorador de archivos y su√©ltalo dentro del panel de **Escena** (arriba a la izquierda, bajo donde dice `Level`). Esto lo colocar√° autom√°ticamente en la posici√≥n `(0, 0)`, perfectamente centrado.
3.  Ver√°s que aparece con un icono de claqueta de cine üé¨ al lado. Eso significa que es una **Instancia**. Si cambias el `player.tscn` original (ej: lo pintas de rojo), ¬°este tambi√©n cambiar√°!

#### Luz, C√°mara... ¬°Coordenadas!
Para facilitarnos las matem√°ticas (donde 0 es arriba y el m√°ximo es abajo):

1.  En la escena `Level`, a√±ade un nodo hijo **`Camera2D`**.
2.  En el Inspector, busca **Anchor Mode** y c√°mbialo a **`Fixed Top Left`**.
    *   *Esto hace que la esquina superior izquierda sea el (0,0), como en las pantallas de p√≠xeles cl√°sicas.*

#### Centrando la Nave
Ahora que el (0,0) es la esquina, tu nave (que est√° en 0,0) se ver√° cortada arriba a la izquierda.
Vamos a colocarla en el centro exacto usando l√≥gica:

1.  La resoluci√≥n por defecto de Godot es **1152 x 648** (muy ancha para nuestro juego retro). Vamos a cambiarla a **800 x 600**:
    *   Ve a **Project > Project Settings > Display > Window**.
    *   Cambia `Viewport Width` a **800**.
    *   Cambia `Viewport Height` a **600**.
2.  El centro ahora es: `800 / 2 = 400` (X) y `600 / 2 = 300` (Y).
3.  Selecciona el nodo `player` (la instancia).
4.  En Inspector > Transform > Position, escribe:
    *   **X**: `800/2`
    *   **Y**: `600/2`

<Callout type="tip" title="Truco: ¬°Godot sabe matem√°ticas!">
  Puedes escribir literalmente `800/2` en la casilla y √©l har√° la cuenta. O tambi√©n simplemente puedes mover el Player con el rat√≥n hasta donde quieras en la vista 2D.
</Callout>

#### ¬°A Jugar!
1.  Pulsa **F5** (o el bot√≥n de Play arriba a la derecha).
2.  Te preguntar√°: *"No Main Scene defined. Select one?"*. Dile que **Select Current**.
3.  ¬°Ah√≠ lo tienes! Tu nave movi√©ndose en tu nuevo mundo.

<Callout type="tip" title="¬øMi nave se va de la pantalla?">
  ¬°Es normal! A√∫n no hemos puesto l√≠mites (paredes). Tu nave viaja felizmente hacia el infinito de coordenadas matem√°ticas.
  En pr√≥ximos cap√≠tulos le pondremos muros a este universo.
</Callout>
