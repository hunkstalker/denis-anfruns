---
pubDate: '2026-01-11T10:00:00Z'
tags: ['godot', 'gdscript', 'math', 'vectors']
draft: false
new: true
title: 'Godot #1: Vectors i Moviment'
description: Entenent les matem√†tiques darrere del moviment. Per qu√® normalitzem? Qu√® √©s Delta? Explicat per a humans.
series: gamedev-godot-basics
seriesTitle: Game Dev amb Godot
seriesDescription: Aprenem els fonaments del desenvolupament de videojocs (vectors, trigonometria, shaders) usant Godot i un Shoot 'em Up com a excusa pr√†ctica.
lang: ca
---

import Callout from '../../../../components/mdx/Callout.astro';
import CodeTabs from '../../../../components/mdx/CodeTabs.astro';
import VectorDemo from '../../../../components/mdx/interactive/VectorDemo.tsx';

## La Nau i les Matem√†tiques

En aquest cap√≠tol crearem la nostra nau i farem que es mogui. Per√≤ no copiarem un script. Entendrem **per qu√®** es mou. I per aix√≤, hem de parlar de la nostra amiga (o enemiga): **La Fletxa (El Vector)**.

<Callout type="tip" title="Necessites gr√†fics?">
  Per seguir aquest curs, necessitar√†s una nau. Si no en tens una a m√†, et recomanem encaridament el pack gratu√Øt de **[Kenney Space Shooter Extension](https://kenney.nl/assets/space-shooter-extension)**. √âs net, bonic i perfecte per aprendre.
  
  Necessites editar les imatges? No cal piratejar res. Tens la suite **[Affinity Studio](https://www.affinity.studio/)** disponible de forma gratu√Øta a la web.
</Callout>

### 1. L'Escenari (Pla Cartesi√†)

El teu monitor √©s una quadr√≠cula de p√≠xels.
*   **X (Horitzontal)**: Creix cap a la dreta.
*   **Y (Vertical)**: Creix cap a **BAIX**.

<Callout type="warning" title="Compte amb la Y!">
  A les matem√†tiques de l'escola, la Y creix cap amunt. En Game Dev, la Y creix cap avall (perqu√® comencem a dibuixar des de la cantonada superior esquerra). No ho oblidis o la teva nau volar√† cap per avall.
</Callout>

### 2. L'Elecci√≥ del Node (La Teva Nau)

A la intro vam dir que "Tot √©s una Escena". Cert, per√≤... de qu√® est√† feta una escena? **De Nodes**.
Si l'Escena √©s la casa, els Nodes s√≥n els maons. I hi ha molts tipus de maons:

1.  **Node2D**: √âs la base **per al m√≥n 2D**. T√© posici√≥ `(x, y)`, rotaci√≥ i escala. (Si estigu√©ssim en 3D seria `Node3D`, i per a interf√≠cies `Control`, per√≤ aqu√≠ vivim al pla).
2.  **RigidBody2D**: T√© f√≠sica real (gravetat, rebots). Si li dones una puntada de peu, surt volant. Dif√≠cil de controlar per a un personatge principal.
3.  **CharacterBody2D**: El terme mig perfecte. T√© posici√≥ (com Node2D) i sap xocar (com RigidBody), per√≤ **no es mou sol**. TU ets el motor. √âs l'est√†ndard per a personatges en jocs 2D.

#### Prepara els teus Assets
Abans de comen√ßar, necessites una nau. Pots dibuixar-ne una o utilitzar aquesta de prova:

![Nau del Jugador](/assets/gamedev-godot-basics/player.png)

> Clic dret -> Desa la imatge.  
> *Cr√®dits: <a href="https://puszke.itch.io/psx-plane" target="_blank" rel="noopener noreferrer">PSX Plane</a> per **Puck**.*

1.  Crea una carpeta anomenada `sprites` al teu FileSystem.
2.  Arrossega aquesta imatge a dins.

**Passos:**
1.  A l'escena buida que apareix per defecte:
2.  Al panell de "Create Root Node", selecciona **Other Node**.
3.  Escriu `CharacterBody2D` al cercador i fes-li doble clic. Aix√≤ crear√† una nova escena amb aquest node com a arrel. Anomena'l `Player`.
4.  El node es queixar√† amb una alerta ‚ö†Ô∏è. T'est√† dient: *"Ei, tinc cos f√≠sic per√≤ no tinc forma! S√≥c un cercle? Un quadrat?"*.
5.  Afegeix com a fill de `CharacterBody2D` un node anomenat `CollisionShape2D`.
    *   A l'Inspector, on diu **Shape**, selecciona `New CircleShape2D`.
    *   **Important**: Fes clic sobre el requadre que posa "CircleShape2D" (s'expandir√†).
    *   A **Radius**, escriu `40 px`. Aix√≤ ajustar√† la mida exacta sense escalar el node.
6.  Afegeix un altre node fill `Sprite2D` perqu√® es vegi bonic (arrossega la teva imatge de la nau a la propietat Texture).
7.  Crea una carpeta anomenada `scenes` a l'arrel del projecte i desa-hi l'escena com a `player.tscn`.

<Callout type="info" title="Regla d'or: Hitbox vs Sprite">
  En Game Design, hi ha una regla no escrita: **"M√©s val que en sobri que no que en falti"**.
  
  *   Si la teva col¬∑lisi√≥ √©s **m√©s gran** que la nau, el jugador cridar√† *"Per√≤ si no m'ha tocat!"* quan mori per l'aire. Aix√≤ se sent **injust**.
  *   Si la teva col¬∑lisi√≥ √©s **una mica m√©s petita**, permets que les bales "freguin" la nau sense matar-la. Aix√≤ genera moments de *"Ufff, gaireb√©!"* que se senten **√®pics**.
  
  Dona-li sempre una mica d'avantatge al jugador. Fes el `CollisionShape` un 10-20% m√©s petit que el dibuix visible.
</Callout>

### 3. Conceptes B√†sics de GDScript

Abans d'escriure codi, necessites saber llegir el mapa. Si no has programat mai, aix√≤ √©s tot el que necessites saber per ara:

1.  **`extends` (Her√®ncia)**:
    √âs la primera l√≠nia. Li diu a Godot: *"S√≥c una extensi√≥ de..."*.
    
    * `extends CharacterBody2D`: Si estens de com en aquest cas `CharacterBody2D` significar√† que ara l'script t√© tots els m√®todes i propietats d'un CharacterBody2D, m√©s el que afegeixis.
    
    Aix√≤ es diu **Her√®ncia de Classes**. √âs un concepte fonamental de programaci√≥ orientada a objectes. El teu script no comen√ßa de zero: hereta un "vehicle" ja funcional amb rodes, motor i volant (`CharacterBody2D`), i tu nom√©s afegeixes la personalitzaci√≥ (la teva l√≤gica de moviment).
2.  **`func` (Acci√≥/Verb)**:
    √âs una ordre o tasca. Agrupa una llista de passos.
    *   `func _physics_process(delta)`: √âs una funci√≥ especial que Godot crida a un ritme fix (per defecte **60 vegades per segon**). Tot el que escriguis a dins, es repetir√† en bucle per moure coses.
3.  **`var` (Variable)**:
    √âs un lloc on guardem informaci√≥ **a la mem√≤ria RAM** de l'ordinador.
    *   `var speed = 300`: Hem reservat un lloc a la mem√≤ria, li hem posat l'etiqueta "speed" i hem guardat el n√∫mero 300 a dins.

<Callout type="warning" title="Perill: Tabs vs Espais">
  GODOT NO PERDONA.
  La "sagnia" (aquests espais a l'esquerra) defineix quin codi est√† dins de quina funci√≥.
  *   Utilitza sempre **Tabulacions** (Tecla Tab ‚Üπ), no espais.
  *   **Mai barregis** tabs i espais al mateix fitxer o tindr√†s errors invisibles.
  *   *Nota: El bot√≥ de copiar d'aquesta web intenta convertir espais a Tabs autom√†ticament, per√≤ si veus errors vermells, revisa aix√≤ primer.*
</Callout>

### 4. Creant l'Script

La nostra nau √©s bonica, per√≤ no fa res. Necessitem un **Script**.

1.  Crea una carpeta a l'arrel anomenada `scripts`.
2.  Selecciona el node arrel `Player`.
3.  Fes clic a la icona del **Pergam√≠ amb un `+` verd** (a sobre del panell d'escena). O fes clic dret -> **Attach Script**.
4.  Apareixer√† una finestra.
5.  **Template**: Deixa-ho en `CharacterBody2D: Basic Movement` si vols veure molt codi complex, o posa `Empty` per comen√ßar net. Nosaltres ho esborrarem tot, aix√≠ que √©s igual.
6.  **Path**: Aqu√≠ est√† la clau. No el llencis a l'arrel. Escriu `res://scripts/player.gd`.
7.  Dona-li a **Create**.

Ara veur√†s un editor de text. Benvingut al teu primer programa!

### 5. El Problema de "Moure's"

Per moure la nau, necessitem dir-li cap a on anar. Aqu√≠ entren els **Vectors**.

Un vector no √©s m√©s que una fletxa. En videojocs, quan aquesta fletxa ens indica "cap a on", l'anomenem **Vector de Direcci√≥**.
*   Si toques **Dreta**, el vector apunta a `(1, 0)`.
*   Si toques **Avall**, el vector apunta a `(0, 1)`.

En Godot, aix√≤ es diu `Input.get_vector()`.

Per√≤ obtenir el vector no mou la nau. Nom√©s ens diu "cap a on vol anar el jugador".
Per moure-la, necessitem dues coses m√†giques que viuen dins de `CharacterBody2D`:

1.  **`velocity` (Velocitat)**: √âs una variable interna. Imagina-la com el veloc√≠metre de la nau. Tu li dius "Posa't a 300 km/h seguint aquest vector".
2.  **`move_and_slide()`**: Aquesta funci√≥ √©s el motor. Li dius "Arrenca!". I ella sola busca la variable `velocity` i mou la nau aquesta quantitat, xocant si cal.

**No has de passar-li `velocity` a `move_and_slide()`. Ho fa sol.**


Aqu√≠ tens el codi complet. **Et recomano escriure'l a m√†** per memoritzar les comandes, per√≤ si tens pressa, pots copiar-lo.

<CodeTabs
  items={[
    {
      label: 'player.gd',
      lang: 'gdscript',
      code: `extends CharacterBody2D

func _physics_process(delta):
    var direction = Input.get_vector("move_left", "move_right", "move_up", "move_down")
    
    velocity = direction * 400
    move_and_slide()`
    }
  ]}
/>

**Desglossament l√≠nia per l√≠nia:**

**1. `extends CharacterBody2D`**

Ja sabem que aix√≤ √©s her√®ncia. Aqu√≠ ho usem concretament per **desbloquejar la variable `velocity`**. Si estengu√©ssim d'un simple `Node2D`, aquesta variable no existiria i haur√≠em de calcular la f√≠sica manualment. En heretar de `CharacterBody2D`, guanyem tot el sistema de col¬∑lisions sense haver de reescriure a m√† tota una l√≤gica que ja ens dona CharacterBody2D.

**2. `func _physics_process(delta):`**

Usem el bucle de f√≠siques (i no el `_process` normal) perqu√® `move_and_slide()` necessita una **estabilitat perfecta** per calcular xocs. Si us√©ssim el loop visual, la nau podria travessar parets si el joc va lent. Aqu√≠ ens assegurem que el moviment sigui s√≤lid com una roca.

**3. `var direction = Input.get_vector(...)`**

| Tecla/es premuda/es | Valor de `direction` |
|---------------------|----------------------|
| Cap | `(0, 0)` |
| Dreta | `(1, 0)` |
| Avall | `(0, 1)` |
| Dreta + Avall | `(0.707, 0.707)` ‚Üê Normalitzat! |

`Input.get_vector()` llegeix les tecles i construeix un vector de direcci√≥. **Ja ve normalitzat** (magnitud 1), aix√≠ que moure's en diagonal no √©s m√©s r√†pid que moure's recte.

**Per√≤ qu√® √©s "move_right"?**
Si intentes executar el codi ara, **no funcionar√†**. Godot no sap quines tecles s√≥n aquestes. Has de configurar-les tu per definir qu√® significa "moure a la dreta" (pot ser la tecla D, la Fletxa Dreta o el Joystick).

**Configura-ho ara:**
1.  Ves a **Project > Project Settings > Input Map**.
2.  Escriu `move_right` a la barra "**Add New Action**" i prem **Add**.
3.  Busca la nova acci√≥ a la llista de sota i prem el bot√≥ **+** a la seva dreta.
4.  Prem la tecla **D** (i opcionalment la tecla Fletxa Dreta) i dona-li a **OK**.
5.  Repeteix el proc√©s per a la resta:
    *   `move_left`: Tecla **A**.
    *   `move_up`: Tecla **W**.
    *   `move_down`: Tecla **S**.
  
Si vols, pots addicionalment en cada acci√≥ afegir per exemple el joystick (stick esquerre) i al creueta (d-pad).

**4. `velocity = direction * 300`**

La direcci√≥ √©s un vector de magnitud 1. En multiplicar per 300, obtenim "300 p√≠xels per segon en aquesta direcci√≥". √âs com dir: "Apunta cap all√† i ve a 300 de velocitat".

**5. `move_and_slide()`**

Aquesta funci√≥ llegeix `velocity` autom√†ticament (no cal passar-li) i mou el node. A m√©s, gestiona col¬∑lisions: si hi ha una paret, "llisca" en lloc de quedar-se enganxat. Per aix√≤ es diu "move and slide".


### 4. Per qu√® corres m√©s en diagonal? (Pit√†gores)

Si prems **Dreta** `(1, 0)` i **Avall** `(0, 1)` alhora, Godot suma els vectors. El resultat √©s `(1, 1)`.

Quant mesura aquest vector `(1, 1)`? Aqu√≠ √©s on entra el nostre amic grec.

Imagina que ets en una ciutat quadriculada (com l'Eixample de Barcelona o Manhattan):
*   Caminar 1 carrer a l'Est costa **1 minut**.
*   Caminar 1 carrer al Sud costa **1 minut**.
*   Si camines Est i despr√©s Sud, trigues **2 minuts** en total.

Per√≤, **i si travesses el carrer en diagonal?**
Aqu√≠ entra el senyor Pit√†gores amb el seu fam√≥s **Teorema**. No t'espantis, anem a disseccionar-lo pe√ßa a pe√ßa:

$$
h = \sqrt{a^2 + b^2}
$$

**Qu√® significa cada lletra?**
*   **$h$ (Hipotenusa)**: √âs la dist√†ncia llarga, la **longitud (magnitud)** del vector.
*   **$a$ i $b$ (Catets)**: S√≥n els costats rectes. En el nostre cas, el moviment en **X** (1 pas) i en **Y** (1 pas).

**Treu la calculadora! De deb√≤, fes-ho.**
Anem a substituir les lletres per els nostres n√∫meros (1 dreta, 1 avall):

1.  **Elevem al quadrat**: $1^2$ significa $1 \times 1$. Segueix sent $1$.
    
    Resultat:
    $$ h = \sqrt{1 + 1} $$
2.  **Sumem**: $1 + 1 = 2$.

    Resultat:
    $$ h = \sqrt{2} $$
3.  **Arrel quadrada**: Busca el bot√≥ $\sqrt{}$ a la teva calculadora del m√≤bil i posa $2$.

    Resultat:
    $$ h \approx 1.41421356... $$

<Callout type="info" title="Diccionari Gamer ü§ì">
  En videojocs i matem√†tiques, a aquesta longitud $h$ li diem **Magnitud** o **M√≤dul** del vector.
  Tamb√© √©s coneguda com **Dist√†ncia Euclidiana** (la l√≠nia recta entre dos punts).
  
  Quan fem `input_vector.length()` en Godot, el motor fa aquest c√†lcul de Pit√†gores per tu.
</Callout>

Aqu√≠ ho tens!
Si no fem res, la teva direcci√≥ t√© una for√ßa de **1.41**.
Comparat amb la for√ßa de **1.0** quan vas recte, **est√†s corrent un 41% m√©s r√†pid!**

<VectorDemo client:visible />

Aix√≤ √©s un problema cl√†ssic ("Speedrunning hack"). En un joc competitiu, tothom aniria en diagonal per arribar abans.

#### La Soluci√≥: Normalitzar

Normalitzar un vector significa: **"No m'importa com de llarg sigui el vector (la fletxa), talla'l perqu√® mesuri exactament 1, per√≤ mantingues la direcci√≥".**

Godot √©s llest. `Input.get_vector()` **JA normalitza** el resultat per defecte.
√âs important saber-ho perqu√® en matem√†tiques de shaders o IA, haur√†s d'utilitzar `.normalized()` manualment moltes vegades quan nom√©s t'importi la **direcci√≥** ($ \hat{v} $) i no la for√ßa.

### 5. Qu√® dimonis √©s `delta`?

Veur√†s `delta` en tots els tutorials.

<CodeTabs
  items={[
    {
      label: 'exemple.gd',
      lang: 'gdscript',
      code: `position += velocity * delta`
    }
  ]}
/>

Imagina que el teu joc va a **60 FPS** (imatges per segon). El teu codi s'executa 60 vegades per segon.
Ara imagina que al teu amic li va a **144 FPS**. El seu codi s'executa 144 vegades per segon.

Si sumes `position += 1` a cada frame:
*   Tu avances 60 p√≠xels cada segon.
*   El teu amic avan√ßa 144 p√≠xels cada segon.

El teu amic √©s m√©s r√†pid nom√©s per tenir millor PC! Aix√≤ √©s injust (i trenca la f√≠sica).

**Delta** √©s el **temps que ha passat des de l'√∫ltim frame**.
*   Si vas a 60 FPS, delta √©s `1/60` (aprox 0.016s).
*   Si vas a 144 FPS, delta √©s `1/144` (aprox 0.006s).

Si multipliques per delta:
*   Tu: `1 * 60 vegades * 0.016 = 1` metre per segon.
*   Amic: `1 * 144 vegades * 0.006 = 1` metre per segon.

**Conclusi√≥**: Multiplicar per Delta converteix "P√≠xels per Frame" en "P√≠xels per Segon". Fa que el joc vagi igual en una patata que en un PC de la NASA.

<Callout type="tip" title="Nota de Godot">
  `move_and_slide()` utilitza `delta` autom√†ticament a dins, per aix√≤ al codi de dalt no el veus multiplicant. Per√≤ si mous coses manualment canviant `position`, SEMPRE utilitza delta.
</Callout>

### 6. Script Final (Per ara)

Abans de copiar, mira dos detalls nous:
1.  **`@export`**: Aquesta paraula m√†gica fa que la variable `speed` aparegui a l'**Inspector** de Godot. Aix√≠ pots ajustar la velocitat escrivint un n√∫mero a la capseta sense tornar a obrir l'script.
2.  **`direction * speed`**: Recorda que `direction` val **1** (√©s un Vector Unitari). √âs nom√©s la direcci√≥ pura. En multiplicar-lo per **400**, convertim aquest 1 en 400 p√≠xels per segon.
    *   Aix√≤ significa: **"Mou-te 400 p√≠xels per segon en aquesta direcci√≥"**.

<CodeTabs
  items={[
    {
      label: 'player.gd',
      lang: 'gdscript',
      code: `extends CharacterBody2D
    
@export var speed = 400

func _physics_process(delta):
    var direction = Input.get_vector("move_left", "move_right", "move_up", "move_down")
    
    velocity = direction * speed
    move_and_slide()`
    }
  ]}
/>

Felicitats! Tens una nau que es mou consistentment en totes direccions.

### 7. Provant-ho tot: El Teu Primer Nivell (Sandbox)

Fins ara hem treballat al "taller" (l'escena del `Player`). Per√≤ una nau necessita un univers.
Si li dones al bot√≥ de **Play (F5)** ara, et demanar√† una escena principal. Anem a crear-la:

1.  Crea una **Nova Escena**.
2.  Tria **2D Scene** (Node2D). Aquesta vegada no volem f√≠siques, nom√©s un contenidor per al m√≥n. Anomena'l `Level` (PascalCase, perqu√® √©s un Node).
3.  Desa-la a `scenes/level.tscn` (snake_case, perqu√® √©s un fitxer).

#### Instanciant al Jugador (El "Link")
Aqu√≠ passa la m√†gia de Godot. No "copiarem i enganxarem" al jugador. El **referenciarem**.
1.  Busca el teu fitxer `player.tscn` a la carpeta `scenes` (a baix a l'esquerra).
2.  **Arrossega'l** des de l'explorador de fitxers i deixa'l anar dins del panell de **Scene** (a dalt a l'esquerra, sota on diu `Level`). Aix√≤ el col¬∑locar√† autom√†ticament a la posici√≥ `(0, 0)`, perfectament centrat.
3.  Veur√†s que apareix amb una icona de claqueta de cinema üé¨ al costat. Aix√≤ significa que √©s una **Inst√†ncia**. Si canvies el `player.tscn` original (ex: el pintes de vermell), aquest tamb√© canviar√†!

#### Llums, C√†mera... Coordenades!
Per facilitar-nos les matem√†tiques (on 0 √©s a dalt i el m√†xim √©s a baix):

1.  A l'escena `Level`, afegeix un node fill **`Camera2D`**.
2.  A l'Inspector, busca **Anchor Mode** i canvia'l a **`Fixed Top Left`**.
    *   *Aix√≤ fa que la cantonada superior esquerra sigui el (0,0), com a les pantalles de p√≠xels cl√†ssiques.*

#### Centrant la Nau
Ara que el (0,0) √©s la cantonada, la teva nau (que est√† a 0,0) es veur√† tallada a dalt a l'esquerra.
Anem a col¬∑locar-la al centre exacte usant l√≤gica:

1.  La resoluci√≥ per defecte de Godot √©s **1152 x 648** (massa ampla per al nostre joc retro). Anem a canviar-la a **800 x 600**:
    *   Ves a **Project > Project Settings > Display > Window**.
    *   Canvia `Viewport Width` a **800**.
    *   Canvia `Viewport Height` a **600**.
2.  El centre ara √©s: `800 / 2 = 400` (X) i `600 / 2 = 300` (Y).
3.  Selecciona el node `player` (la inst√†ncia).
4.  A Inspector > Transform > Position, escriu:
    *   **X**: `800/2`
    *   **Y**: `600/2`

<Callout type="tip" title="Truc: Godot sap matem√†tiques!">
  Pots escriure literalment `800/2` a la casella i ell far√† el compte. O tamb√© simplement pots moure el Player amb el ratol√≠ fins on vulguis a la vista 2D.
</Callout>

#### A Jugar!
1.  Prem **F5** (o el bot√≥ de Play a dalt a la dreta).
2.  Et preguntar√†: *"No Main Scene defined. Select one?"*. Digues-li que **Select Current**.
3.  Aqu√≠ ho tens! La teva nau movent-se al teu nou m√≥n.

<Callout type="tip" title="La meva nau marxa de la pantalla?">
  √âs normal! Encara no hem posat l√≠mits (parets). La teva nau viatja feli√ßment cap a l'infinit de coordenades matem√†tiques.
  En propers cap√≠tols posarem murs a aquest univers.
</Callout>
