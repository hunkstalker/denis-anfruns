---
pubDate: '2026-02-09T10:00:00Z'
tags: ['godot', 'shaders', 'gpu', 'game-juice']
draft: true
new: true
title: 'Godot #4: Game Juice con Shaders'
description: Introducción al mundo de los Shaders. Arquitectura CPU vs GPU, Uniforms y creación de un efecto de Hit Flash.
series: godot-basics
seriesTitle: Game Dev con Godot
seriesDescription: Aprende Godot creando un Space Shooter desde cero, con énfasis en Matemáticas y Shaders.
lang: es
---

import Callout from '../../../../components/mdx/Callout.astro';
import CodeTabs from '../../../../components/mdx/CodeTabs.astro';

## Buscando el "Game Juice"

En el capítulo anterior logramos que los enemigos murieran y cayeran. Funciona, sí. Pero no *mola*.
Para que un juego se sienta profesional, necesitamos **Feedback Visual**. Necesitamos "Jugo" (Game Juice).

Y la herramienta más potente para ello son los **Shaders**.

## 1. Arquitectura: Serial vs Paralelo

Hasta ahora hemos programado en GDScript (CPU). Pero para pintar píxeles, vamos a usar el otro cerebro de tu ordenador: la GPU.

*   **CPU (Serial)**: Tiene pocos núcleos (4-16) pero muy potentes. Procesa las tareas una detrás de otra (en fila). Es ideal para la lógica del juego.
*   **GPU (Paralelo)**: Tiene miles de núcleos, más simples. Puede procesar miles de tareas a la vez. Es ideal para modificar píxeles masivamente.

Si tu nave mide 100x100 píxeles, la GPU lanzará **10.000 hilos** de ejecución al mismo tiempo (uno para cada píxel).

## 2. Las Herramientas del Shader

Para controlar esos 10.000 hilos, usamos un lenguaje llamado GLSL (similar a C). Vamos a explicar las 4 piezas clave:

### A. La Función Principal
*   **`fragment()`**: Es el código que ejecutará cada uno de los 10.000 hilos.
    *   Tu misión aquí es calcular el color final del píxel y guardarlo en la variable de salida `COLOR`.

### B. Los Datos (Scope)
*   **`vec4`**: Un color son 4 números del 0.0 al 1.0 (Rojo, Verde, Azul, Transparencia).
*   **`uniform` (Global)**: Una variable que es IGUAL para todos los hilos.
    *   La enviamos desde la CPU (GDScript).
    *   Ejemplo: `uniform bool active`. Si activamos esto, los 10.000 hilos reciben `true` a la vez.
*   **`UV` (Local)**: La coordenada específica de *ese* hilo.
    *   **NO** son todos los píxeles. Es la coordenada **individual** de *este* píxel concreto.
    *   **Analogía**: Es como un `self.coordenada`. Cada hilo sabe "dónde está él mismo".
    *   El hilo de la esquina izquierda valdrá `(0,0)`, el del centro `(0.5, 0.5)`.

### C. La Lectura
*   **`texture(imagen, coordenada)`**: Busca el color de un píxel en una imagen.
    *   Le pasamos `TEXTURE` (la imagen de la nave) y `UV` (la coordenada de este hilo).
    *   Así, cada hilo recupera el color exacto que le corresponde, reconstruyendo la imagen completa.

---

## 3. La Misión: Flash Blanco

Queremos que, cuando activemos el `uniform active`, todos los hilos ignoren el color de la textura original y pinten BLANCO PURO.

1.  Selecciona el `Sprite2D` del enemigo.
2.  **Inspector > CanvasItem > Material** -> `New ShaderMaterial`.
3.  Click en el material -> `Shader` -> `New Shader`. Crea la carpeta `shaders` y guárdalo como `shaders/hit_flash.gdshader`.
4.  Copia este código y analízalo con lo que acabas de aprender:

<CodeTabs
  items={[
    {
      label: 'hit_flash.gdshader',
      lang: 'glsl',
      code: `shader_type canvas_item;

// 1. VARIABLE GLOBAL (Uniforme)
// Desde el script del enemigo activaremos esto.
uniform bool active = false;

void fragment() {
    // 2. LEER COLOR (Lookup)
    // Usamos 'self.coordenada' (UV) para leer nuestro trocito de imagen.
    vec4 color_original = texture(TEXTURE, UV);
    
    // 3. LA LÓGICA
    if (active) {
        // Si la variable global es 'true', pintamos BLANCO
        // (1, 1, 1) es blanco. Usamos la transparencia original (.a) para no pintar el cuadrado entero.
        COLOR = vec4(1.0, 1.0, 1.0, color_original.a); 
    } else {
        // Si no, pintamos el color normal de la foto
        COLOR = color_original;
    }
}`
    }
  ]}
/>

## 4. Conectando CPU y GPU

Ahora volvemos al codigo de GDScript (`enemy.gd`). Vamos a cambiar ese cutre `modulate` que pusimos en el capítulo anterior por algo profesional.

Necesitamos una función que "hable" con la GPU y le active ese `uniform bool active`.

<CodeTabs
  items={[
    {
      label: 'enemy.gd',
      lang: 'gdscript',
      code: `func _on_area_entered(area):
    hp -= 1
    hit_flash() # Llamamos a la nueva función
    
    if hp <= 0:
        die()

func hit_flash():
    # 1. Accedemos al Material del Sprite
    var sprite = $Sprite2D
    var material = sprite.material as ShaderMaterial
    
    # 2. Enviamos el dato a la GPU
    material.set_shader_parameter("active", true)
    
    # 3. Esperamos 0.1 segundos (una fracción de instante)
    await get_tree().create_timer(0.1).timeout
    
    # 4. Lo apagamos
    material.set_shader_parameter("active", false)`
    }
  ]}
/>

<Callout type="tip" title="¿Por qué as ShaderMaterial?">
  GDScript necesita saber que `sprite.material` es un `ShaderMaterial` para sugerirte la función `set_shader_parameter`. Sin ese `as ShaderMaterial`, funcionaría igual, pero no tendrías autocompletado.
</Callout>

¡Hecho! Ahora tienes un sistema de daño con feedback visual profesional, y lo más importante: entiendes lo que ocurre "bajo el capó" de la tarjeta gráfica.
