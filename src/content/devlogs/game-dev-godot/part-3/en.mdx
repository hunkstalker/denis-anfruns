---
pubDate: '2026-01-13T10:00:00Z'
tags: ['godot', 'gdscript', 'signals', 'area2d']
draft: false
new: true
title: 'Godot #3: Signals & Enemies'
description: We bring the game to life with enemies. Learn about Area2D, collisions, and signals via code.
series: gamedev-godot-basics
seriesTitle: Game Dev with Godot
seriesDescription: We learn the fundamentals of game development (vectors, trigonometry, shaders) using Godot and a Shoot 'em Up as a practical excuse.
lang: en
---

import Callout from '../../../../components/mdx/Callout.astro';
import CodeTabs from '../../../../components/mdx/CodeTabs.astro';

## Enemies & Signals: Contact!

We are already shooting, but our bullets travel to infinity without hitting anything. It's time to create flying targets.
But first, a vital architectural decision.

## 1. The Area2D Node

For the player, we used `CharacterBody2D` because we wanted precise movement physics (colliding with walls and sliding).
For bullets and simple enemies, we will use **`Area2D`**.

**Why?**
*   **It's cheaper**: Consumes less CPU than a full physics body.
*   **Allows overlapping**: In a *Space Shooter*, you don't want enemies to bounce off you like billiard balls. You want them to *detect* that they touched you and explode. `Area2D` is perfect for that: detects overlaps without pushing.
*   **Physics Superpowers**: A normal `Node2D` is invisible to the physics engine. Even if you give it a shape, Godot will ignore it. You need a node that inherits from `CollisionObject2D` (like this one) for the magic to work.

### Preparing the Enemy Scene

You can use your own sprite or download this one:

![Enemy Sprite](/assets/gamedev-godot-basics/enemy_128.png)

> Right click -> Save image.  
> *Credits: <a href="https://www.freepik.com/free-vector/set-military-aircraft_40063568.htm" target="_blank" rel="noopener noreferrer">Set of military aircraft</a> by **brgfx** on Freepik (Free license with attribution).*

1.  Create New Scene. Root Node: `Area2D`. Name: `Enemy`.
2.  Add `Sprite2D` (your enemy ship).
3.  Add `CollisionShape2D` (circle or rectangle covering the ship).
4.  **Attach a Script** to Area2D: Save it as `enemy.gd`.

<Callout type="warning" title="Don't forget the shape!">
  An `Area2D` without a `CollisionShape2D` is useless. Godot will show you a yellow ⚠️ alert if you forget to put it.
</Callout>

## 2. Preparing the Script

Before writing the code, let's analyze what our enemy needs to do. We are going to mix three concepts:

### A. Signals via Code
In the previous chapter, we used the editor to connect signals. Today we will do it **via Code** so the enemy is autonomous.
*   **What do we use?**: The `area_entered` signal.
*   **Where?**: In `_ready()`, using `connect()`.
*   **Why?**: So each enemy knows how to react without needing to configure it manually in the editor.

### B. Simulated Physics
Since we use `Area2D` and not a physics body (`RigidBody`), gravity doesn't affect us.
If we want the enemy to fall dramatically when dying, we'll have to program that fall manually by modifying its position. It's a very common and cheap visual trick.

### C. State
We'll need to know if the enemy is alive (moving straight) or dying (falling). We will use a variable ("flag") to control this state.

## 3. Programming the Enemy

Let's build the script piece by piece.

### Phase 1: Basic Movement
First, let's make it move to the left. Nothing new here.

<CodeTabs
  items={[
    {
      label: 'enemy.gd',
      lang: 'gdscript',
      code: `extends Area2D

# Export the speed so we can adjust it in the editor
@export var speed = 150

# Ignore _ready() for now
func _ready() -> void:
    pass

# Add movement in _process
func _process(delta):
    position.x -= speed * delta`
    }
  ]}
/>

**Diving deeper into `@export`:**

In Part 1 we saw that `@export` makes the variable appear in the Inspector. But there's more:

1.  **Balancing without recompiling**: You can change `speed` in the Inspector while the game is PAUSED (F7) and see the effect immediately. This is invaluable for adjusting difficulty.
2.  **Per-instance values**: If you have 3 enemies in the scene, each one can have a different `speed` WITHOUT modifying the script. Simple: select one and change its value in the Inspector.
3.  **Implicit documentation**: The variable name appears in the editor, making it clear to others (or future you) what can be adjusted.

### Phase 2: Signal Connection
Now we add the connection. Remember: `connect(who_responds)`.

<CodeTabs
  items={[
    {
      label: 'enemy.gd',
      lang: 'gdscript',
      code: `func _ready():
    # area_entered is a signal from Area2D, with .connect we make it call a 
    # function that we'll define below
    area_entered.connect(_on_area_entered)

# This function will run when something touches the CollisionShape2D of this Area2D
# thanks to the behavior of area_entered
func _on_area_entered(area):
    print("I've been hit!") # <-- This is just temporary`
    }
  ]}
/>

**Where does the `area` parameter come from?**

The `area_entered` signal doesn't just notify about the collision, it also passes information: the **other** `Area2D` that collided with you. In our case, that "other" is the bullet fired by the player.

That's why, inside `_on_area_entered(area)`, the `area` variable contains a direct reference to the bullet node. This allows us to do things like `area.queue_free()` to destroy it.

### Phase 3: Life and Death
We add health (`hp`) and damage logic.

<CodeTabs
  items={[
    {
      label: 'enemy.gd',
      lang: 'gdscript',
      code: `@export var speed = 150
@export var hp = 3 # Add the hp variable to control health and expose it 
                     # in the editor for convenience

# Intermediate code ---

func _on_area_entered(area):
    # The 'area' parameter is the OTHER Area2D that collided, the bullet
    hp -= 1
    # area.queue_free() # If you uncomment this, the bullet will be destroyed (won't pierce)
    
    # A basic 'if' conditional, if hp is less than or equal to 0, call die()
    if hp <= 0:
        die()

func die():
    # As we already explained, queue_free() will delete the Area2D 
    # (puts it in a queue for deletion)
    queue_free()`
    }
  ]}
/>

### Phase 4: Dramatic Death (Fake Physics)
Since we use `Area2D` and not `RigidBody2D`, we don't have real physics. We are going to "fake" falling when dying.
We need an `is_dying` variable to know if we are in "falling mode".

<CodeTabs
  items={[
    {
      label: 'enemy.gd',
      lang: 'gdscript',
      code: `# Define a couple of state variables for the enemy
var is_dying = false # boolean, if dead or not, by default not dead (false)
var fall_speed = 0.0 # number, controls fall speed, by default 0

func _process(delta):
    if is_dying:
        # Fall with simulated gravity, if dead we add speed
        fall_speed += 500 * delta 
        # Now, having the speed we tell it where to move
        position.y += fall_speed * delta # Add vertical speed
        position.x -= speed * 0.5 * delta # Subtract horizontal speed (braking)
        rotation += 5 * delta # Rotate
        # Cleanup is done by die() with a timer, not here
    else:
        position.x -= speed * delta # Normal movement`
    }
  ]}
/>

### Phase 5: Instance Deletion
When `hp` reaches 0, we call `die()`. This function:
1. Activates the `is_dying` state so `_process` executes the fall.
2. Disables collisions to ignore impacts during the animation.
3. Uses a timer to destroy the node after 1 second.

<CodeTabs
  items={[
    {
      label: 'enemy.gd',
      lang: 'gdscript',
      code: `func die():
    is_dying = true
    # set_deferred avoids errors if called during a collision
    $CollisionShape2D.set_deferred("disabled", true)
    # Wait 1 second and destroy
    await get_tree().create_timer(1.0).timeout
    queue_free()`
    }
  ]}
/>

---

## 4. Complete Script

Now put all the pieces together. Here is your final `enemy.gd` file:

<CodeTabs
  items={[
    {
      label: 'enemy.gd',
      lang: 'gdscript',
      code: `extends Area2D

@export var speed = 150
@export var hp = 3

var is_dying = false
var fall_speed = 0.0

func _ready():
    area_entered.connect(_on_area_entered)

func _process(delta):
    if is_dying:
        fall_speed += 500 * delta
        position.y += fall_speed * delta
        position.x -= speed * 0.5 * delta
        rotation += 5 * delta
    else:
        position.x -= speed * delta

func _on_area_entered(area):
    if is_dying:
        return
        
    hp -= 1
    area.queue_free()
    
    if hp <= 0:
        die()

func die():
    is_dying = true
    $CollisionShape2D.set_deferred("disabled", true)
    await get_tree().create_timer(1.0).timeout
    queue_free()`
    }
  ]}
/>

Done! You have created an autonomous enemy that manages its own movement, collisions, and death, all encapsulated in a robust script.

---

## Testing in your World

Before moving on to the next chapter, verify everything works:

1.  Open `world.tscn` (your main scene).
2.  Drag `Enemy.tscn` from the **FileSystem** panel to the viewport.
3.  Position the enemy on the right side of the screen (so it flies toward the player).
4.  Run the game (**F5**).
5.  Shoot the enemy and verify:
    *   Bullets disappear on impact.
    *   The enemy loses HP and eventually falls spinning.
    *   After 1 second of falling, it disappears.

If everything works, congratulations! Your combat system is operational.

---

## Let's Review What We Learned

1.  **`Area2D`**: Node for detecting overlaps without push physics.
2.  **Signals via code**: Using `signal.connect(function)` in `_ready()` to encapsulate logic.
3.  **State (`is_dying`)**: Using "flag" variables to control behavior.
4.  **Simulated physics**: Modifying `position` manually to create falling effects.
5.  **`set_deferred()`**: Disabling collisions safely during physics callbacks.
6.  **`await` + Timer**: Waiting a time before executing code (e.g., destroy after 1 second).

In the **next chapter**, we will learn to give visual feedback with **Shaders** (the famous "Hit Flash").
