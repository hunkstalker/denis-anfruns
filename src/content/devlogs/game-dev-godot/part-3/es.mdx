---
pubDate: '2026-01-13T10:00:00Z'
tags: ['godot', 'gdscript', 'signals', 'area2d']
draft: false
new: true
title: 'Godot #3: Señales y Enemigos'
description: Damos vida al juego con enemigos. Aprende sobre Area2D, colisiones y señales por código.
series: godot-basics
seriesTitle: Game Dev con Godot
seriesDescription: Aprende Godot creando un Space Shooter desde cero, con énfasis en Matemáticas y Shaders.
lang: es
---

import Callout from '../../../../components/mdx/Callout.astro';
import CodeTabs from '../../../../components/mdx/CodeTabs.astro';

## Enemigos y Señales: ¡Contacto!

Ya disparamos, pero nuestras balas viajan hacia el infinito sin golpear nada. Es hora de crear dianas voladoras.
Pero antes, una decisión arquitectónica vital.

## 1. El Nodo Area2D

Para el jugador usamos `CharacterBody2D` porque queríamos física de movimiento precisa (chocar con paredes y deslizarse).
Para las balas y enemigos simples, usaremos **`Area2D`**.

**¿Por qué?**
*   **Es más barato**: Consume menos CPU que un cuerpo físico completo.
*   **Permite atravesar**: En un *Space Shooter*, no quieres que los enemigos reboten contra ti como bolas de billar. Quieres que *detecten* que te han tocado y exploten. `Area2D` es perfecta para eso: detecta solapamientos ("overlap") sin empujar.
*   **Superpoderes Físicos**: Un `Node2D` normal es invisible para el motor de física. Aunque le pongas una forma, Godot la ignorará. Necesitas un nodo que herede de `CollisionObject2D` (como este) para que la magia funcione.

### Preparando la Escena Enemiga

Puedes usar tu propio sprite o descargar este:

![Sprite del Enemigo](/assets/godot-basics/enemy_128.png)

> Clic derecho -> Guardar imagen.
> *Créditos: <a href="https://www.freepik.com/free-vector/set-military-aircraft_40063568.htm" target="_blank" rel="noopener noreferrer">Set of military aircraft</a> por **brgfx** en Freepik (Licencia gratuita con atribución).*

1.  Crea nueva Escena. Nodo raíz: `Area2D`. Nombre: `Enemy`.
2.  Añade `Sprite2D` (tu nave enemiga).
3.  Añade `CollisionShape2D` (círculo o rectángulo que cubra la nave).
4.  **Adjunta un Script** en Area2D: Guárdalo como `enemy.gd`.

<Callout type="warning" title="¡No olvides la forma!">
  Un `Area2D` sin `CollisionShape2D` no sirve para nada. Godot te mostrará una alerta ⚠️ amarilla si se te olvida ponerlo.
</Callout>

## 2. Preparando el Script

Antes de escribir el código, analicemos qué necesita hacer nuestro enemigo. Vamos a mezclar tres conceptos:

### A. Señales por Código
En el capítulo anterior usamos el editor para conectar señales. Hoy lo haremos **por Código** para que el enemigo sea autónomo.
*   **¿Qué usamos?**: La señal `area_entered`.
*   **¿Dónde?**: En `_ready()`, usaremos `connect()`.
*   **¿Por qué?**: Para que cada enemigo sepa reaccionar sin necesidad de configurarlo manualmente en el editor.

### B. Físicas Simuladas
Como usamos `Area2D` y no un cuerpo físico (`RigidBody`), la gravedad no nos afecta.
Si queremos que el enemigo caiga dramáticamente al morir, tendremos que programar esa caída manualmente modificando su posición. Es un truco visual muy común y barato.

### C. Estado
Necesitaremos saber si el enemigo está vivo (moviéndose recto) o muriendo (cayendo). Usaremos una variable ("bandera") para controlar este estado.

## 3. Programando al Enemigo

Vamos a construir el script pieza a pieza.

### Fase 1: Movimiento Básico
Primero, hagamos que se mueva a la izquierda. Nada nuevo aquí.

<CodeTabs
  items={[
    {
      label: 'enemy.gd',
      lang: 'gdscript',
      code: `extends Area2D

# Exportamos la velocidad para que la podamos ajustar en el editor
@export var speed = 150

# Ignoramos por ahora _ready()
func _ready() -> void:
    pass

# Añadimos el movimiento en _process
func _process(delta):
    position.x -= speed * delta`
    }
  ]}
/>

### Fase 2: Conexión de Señales
Ahora añadimos la conexión. Recuerda: `connect(quien_responde)`.

<CodeTabs
  items={[
    {
      label: 'enemy.gd',
      lang: 'gdscript',
      code: `func _ready():
    # area_entered es una señal de Area2D, con .connect haremos que llame a una 
    # función que definiremos ahora más abajo
    area_entered.connect(_on_area_entered)

# Esta función se ejecutará cuando algo toque este el CollisionShape2D de este Area2D
# gracias al comportamiento de area_entered
func _on_area_entered(area):
    print("¡Me han dado!") # <-- Esto es solo temporal`
    }
  ]}
/>

### Fase 3: Vida y Muerte
Añadimos vida (`hp`) y la lógica de recibir daño.

<CodeTabs
  items={[
    {
      label: 'enemy.gd',
      lang: 'gdscript',
      code: `@export var speed = 150
@export var hp = 3 # Añadimos la variable hp para controlar la vida y la exponemos 
                     # en el editor por comodidad

# Código intermedio ---

func _on_area_entered(area):
    # El parámetro 'area' es el OTRO Area2D que ha colisionado, la bala
    hp -= 1
    # area.queue_free() # Si lo descomentas, la bala se destruirá (no atravesará)
    
    # Un condicional 'if' básico, si hp es menor o igual a 0, llama a die()
    if hp <= 0:
        die()

func die():
    # Como ya explicamos, queue_free() eliminará al Area2D 
    # (lo mete en una cola para eliminarlo )
    queue_free()`
    }
  ]}
/>

### Fase 4: Muerte Dramática (Físicas Fake)
Como usamos `Area2D` y no `RigidBody2D`, no tenemos física real. Vamos a "fingir" que caemos al morir.
Necesitamos una variable `is_dying` para saber si estamos en "modo caída".

<CodeTabs
  items={[
    {
      label: 'enemy.gd',
      lang: 'gdscript',
      code: `# Definimos variables un par de variables de estado del enemigo
var is_dying = false # booleano, si está muerto o no, por defecto no está muerto (false)
var fall_speed = 0.0 # número, controla la velocidad de caída, por defecto 0

func _process(delta):
    if is_dying:
        # Caída con gravedad simulada, si muere le añadimos velocidad
        fall_speed += 500 * delta 
        # Ahora, teniendo la velocidad le decimos hacia dónde moverse
        position.y += fall_speed * delta # Le añadimos velocidad vertical
        position.x -= speed * 0.5 * delta # Le restamos velocidad horizontal (frenada)
        rotation += 5 * delta # Giramos
        # La limpieza la hace die() con un timer, no aquí
    else:
        position.x -= speed * delta # Movimiento normal`
    }
  ]}
/>

### Fase 5: Eliminación de la Instancia
Cuando `hp` llega a 0, llamamos a `die()`. Esta función:
1. Activa el estado `is_dying` para que `_process` ejecute la caída.
2. Desactiva las colisiones para ignorar impactos durante la animación.
3. Usa un timer para destruir el nodo después de 1 segundo.

<CodeTabs
  items={[
    {
      label: 'enemy.gd',
      lang: 'gdscript',
      code: `func die():
    is_dying = true
    # set_deferred evita errores si se llama durante una colisión
    $CollisionShape2D.set_deferred("disabled", true)
    # Espera 1 segundo y destruye
    await get_tree().create_timer(1.0).timeout
    queue_free()`
    }
  ]}
/>

---

## 4. Script Completo

Ahora junta todas las piezas. Así queda tu archivo `enemy.gd` final:

<CodeTabs
  items={[
    {
      label: 'enemy.gd',
      lang: 'gdscript',
      code: `extends Area2D

@export var speed = 150
@export var hp = 3

var is_dying = false
var fall_speed = 0.0

func _ready():
    area_entered.connect(_on_area_entered)

func _process(delta):
    if is_dying:
        fall_speed += 500 * delta
        position.y += fall_speed * delta
        position.x -= speed * 0.5 * delta
        rotation += 5 * delta
    else:
        position.x -= speed * delta

func _on_area_entered(area):
    if is_dying:
        return
        
    hp -= 1
    area.queue_free()
    
    if hp <= 0:
        die()

func die():
    is_dying = true
    $CollisionShape2D.set_deferred("disabled", true)
    await get_tree().create_timer(1.0).timeout
    queue_free()`
    }
  ]}
/>

¡Hecho! Has creado un enemigo autónomo que gestiona su propio movimiento, sus colisiones y su muerte, todo encapsulado en un script robusto.

---

## Repasemos lo aprendido

1.  **`Area2D`**: Nodo para detectar solapamientos sin física de empuje.
2.  **Señales por código**: Usar `signal.connect(función)` en `_ready()` para encapsular la lógica.
3.  **Estado (`is_dying`)**: Usar variables "bandera" para controlar el comportamiento.
4.  **Físicas simuladas**: Modificar `position` manualmente para crear efectos de caída.
5.  **`set_deferred()`**: Desactivar colisiones de forma segura durante callbacks de física.
6.  **`await` + Timer**: Esperar un tiempo antes de ejecutar código (ej: destruir tras 1 segundo).

En el **próximo capítulo**, aprenderemos a dar feedback visual con **Shaders** (el famoso "Hit Flash").

