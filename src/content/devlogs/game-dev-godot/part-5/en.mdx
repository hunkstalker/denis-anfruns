---
pubDate: '2026-01-14T15:00:00Z'
tags: ['godot', 'gdscript', 'math', 'trigonometry', 'gamedev']
draft: false
new: true
title: 'Godot #5: Combat Trigonometry'
description: Enemies that wave, orbit and execute mathematical patterns. Learn how to use Sine and Cosine for classic arcade movements.
series: gamedev-godot-basics
seriesTitle: Godot Game Dev
seriesDescription: We learn the fundamentals of game development (vectors, trigonometry, shaders) using Godot and a Shoot 'em Up as a practical excuse.
lang: en
---

import Callout from '../../../../components/mdx/Callout.astro';
import CodeTabs from '../../../../components/mdx/CodeTabs.astro';
import SineWaveDemo from '../../../../components/mdx/interactive/SineWaveDemo.tsx';

## Predictable Enemies are Boring Enemies

Until now, our enemies only move in a straight line. It works, but it doesn't impress.
Classic shooters like *Galaga*, *Gradius*, or *R-Type* feature enemies that **wave**, **orbit**, and execute **choreographed patterns**.

The key to these movements is two mathematical functions: **Sine** and **Cosine**.

## 1. Sine: The Wave

The **Sine** (`sin`) is a function that returns values between **-1** and **1** in a cyclical manner.

If we graph `sin(x)` where `x` goes from 0 to 2π (a full circle), we get a **wave**:

| Value of x | sin(x) |
|------------|--------|
| 0 | 0 |
| π/2 (90°) | 1 (maximum) |
| π (180°) | 0 |
| 3π/2 (270°) | -1 (minimum) |
| 2π (360°) | 0 |

After 2π, the cycle repeats infinitely.

<SineWaveDemo client:load />

### How is this useful in a game?

If we use **time** as the input for sine, we get a value that oscillates smoothly:

<CodeTabs
  items={[
    {
      label: 'example.gd',
      lang: 'gdscript',
      code: `var offset_y = sin(time) # Oscillates between -1 and 1`
    }
  ]}
/>

Multiplying by an **amplitude**, we control how much it moves:

<CodeTabs
  items={[
    {
      label: 'example.gd',
      lang: 'gdscript',
      code: `var offset_y = sin(time) * 50 # Oscillates between -50 and 50 pixels`
    }
  ]}
/>

---

## 2. A New Enemy: The Chopper

We're going to keep our basic plane (`enemy.gd`) as is, moving straight. For these new patterns, we'll create a new enemy, the **Chopper**, of which we'll make **3 versions**:
1.  **Wave**: Moves making waves.
2.  **Orbit**: Turns in perfect circles.
3.  **Ellipse**: Turns in ovals.

![Chopper Sprite](/assets/gamedev-godot-basics/chopper_128.png)

> Right click -> Save image.  
> *Credits: <a href="https://wenrexa.itch.io/laser2020" target="_blank" rel="noopener noreferrer">Assets Free Laser Bullets Pack 2020</a> by **Wenrexa** (<a href="https://creativecommons.org/publicdomain/zero/1.0/" target="_blank" rel="noopener noreferrer">CC0 1.0</a>).*

### Step 1: The Wave Chopper

1.  Create a new scene inherited from `Area2D` (or duplicate your enemy and change the sprite).
2.  Set the chopper sprite.
3.  Create a new script named `enemy_wave.gd`.

### The Wave Script

We want this enemy to move vertically while advancing horizontally. We'll reuse the basic movement and damage logic, adding the magic of `sin`.

<CodeTabs
  items={[
    {
      label: 'enemy_wave.gd',
      lang: 'gdscript',
      code: `extends Area2D

@export var speed = 200
@export var hp = 3
@export var wave_amplitude = 100.0  # (new) How much it goes up/down (in pixels)
@export var wave_frequency = 3.0    # (new) How fast it waves

var is_dying = false
var fall_speed = 0.0
var time = 0.0                      # (new) Time accumulator
var start_y = 0.0                   # (new) Initial Y position

func _ready():
    start_y = position.y              # (new) Save initial Y
    area_entered.connect(_on_area_entered)

func _process(delta):
    if is_dying:
      fall_speed += 500 * delta
      position.y += fall_speed * delta
      position.x -= speed * 0.5 * delta 
    else:
      time += delta                   # (new) Accumulate time

      # Horizontal movement
      position.x -= speed * delta
          
      # (new) Vertical wave movement
      position.y = start_y + sin(time * wave_frequency) * wave_amplitude

func _on_area_entered(area):
    if is_dying:
      return
    
    # Standard damage logic
    hp -= 1
    area.queue_free()   # Deletes the projectile/bullet
    hit_flash()         # Impact flash-shader

    if hp <= 0:
      die()

  func hit_flash():
    # Same impact flash-shader code ...
    
  func die():
    # Same death code ...`
    }
  ]}
/>

**Formula breakdown:**
*   `time += delta`: We accumulate the elapsed time. Since `delta` represents the seconds since the last frame, `time` becomes a **clock in real seconds**. This is crucial: if we used `time += 1`, the enemy would wave faster on powerful PCs (more FPS = more increments per second).
*   `time * wave_frequency`: The higher the frequency, the faster it completes the cycle.
*   `sin(...)`: Returns a value between -1 and 1.
*   `* wave_amplitude`: Converts that range to real pixels.
*   `start_y + ...`: Centers the oscillation on the initial position.

---

## 3. Cosine: The Phased Sibling

The **Cosine** (`cos`) is identical to Sine, but **phased by 90°** (π/2 radians).

| Value of x | sin(x) | cos(x) |
|------------|--------|--------|
| 0 | 0 | 1 |
| π/2 | 1 | 0 |
| π | 0 | -1 |
| 3π/2 | -1 | 0 |
| 2π | 0 | 1 |

When `sin` is at 0, `cos` is at its maximum (or minimum), and vice versa.

### What is it useful for?

If we use `cos` for the **X axis** and `sin` for the **Y axis**, we get **circular** movement.

---

## 4. Circular Movement (Orbit)

An enemy orbiting around a point uses both functions: `cos` for X and `sin` for Y.

### Practical Implementation

For these orbital enemies, we'll keep using our **Chopper**.

> You can duplicate the chopper scene from the previous section (call it `EnemyOrbital.tscn`) and change its script, or just change the script in the same scene to test.

Create a script named `enemy_orbital.gd`:

<CodeTabs
  items={[
    {
      label: 'enemy_orbital.gd',
      lang: 'gdscript',
      code: `extends Area2D

@export var speed = 200
@export var hp = 3
@export var orbit_radius = 100.0   # (new) Circle radius
@export var orbit_speed = 2.0      # (new) Angular speed

var is_dying = false
var velocity = Vector2.ZERO        # (new) To calculate inertia
var time = 0.0
var center = Vector2.ZERO          # (new) Orbit center

func _ready():
    center = position              # (new) Save where we started
    area_entered.connect(_on_area_entered)

func _process(delta):
    if is_dying:
        # (new) Gravity over accumulated velocity
        velocity.y += 1000 * delta
        position += velocity * delta
        rotate(5 * delta)
    else:
        var prev_pos = position    # (new) Save previous position
        time += delta
    
        # (new) Circle Formula
        position.x = center.x + cos(time * orbit_speed) * orbit_radius
        position.y = center.y + sin(time * orbit_speed) * orbit_radius
        
        # (new) Calculate real velocity (Inertia)
        velocity = (position - prev_pos) / delta

func _on_area_entered(area):
    if is_dying:
      # same death code ...

    if hp <= 0:
      die()                        # Same damage code ...

    func hit_flash():
      # Same impact flash-shader code ...

    func die():
      # Same death code ...`
    }
  ]}
/>

### Understanding the Code

1.  **Base Logic**: We keep `hp`, `_ready` with signal connection, and damage functions. An enemy that doesn't die is useless!
2.  **`orbit_radius`**: Defines how big the circle is.
3.  **`orbit_speed`**: Controls how fast it spins.
4.  **`center`**: We need a fixed point to spin around.
5.  **`time += delta`**: Our internal "clock".
6.  **The Magic Formula**:
    *   `cos(time)` gives us the X coordinate.
    *   `sin(time)` gives us the Y coordinate.
    *   Multiply by the radius to make it bigger than 1 pixel.
    *   Add `center` so it spins around that point, not the game origin (0,0).

This enemy spins in place. In the future, we'll use this to create squads that enter and stay orbiting in formation.

---

## 5. Ellipses: Stretched Circles

A circle has the same radius in X and Y. An **ellipse** has different radii.

> **Tip:** You don't need to look for another sprite. You can duplicate your chopper scene (`EnemyOrbital.tscn`) and replace its script with this new one.

Create a script named `enemy_ellipse.gd`:


<CodeTabs
  items={[
    {
      label: 'enemy_ellipse.gd',
      lang: 'gdscript',
      code: `extends Area2D

@export var speed = 200
@export var hp = 3
@export var radius_x = 150.0  # Horizontal radius (wider)
@export var radius_y = 50.0   # Vertical radius (narrower)
@export var orbit_speed = 1.5

var is_dying = false
var time = 0.0
var velocity = Vector2.ZERO
var center = Vector2.ZERO

func _ready():
    center = position
    area_entered.connect(_on_area_entered)

func _process(delta):
    if is_dying:
      # Gravity over accumulated velocity
      velocity.y += 1000 * delta
      position += velocity * delta
    else:
      var prev_pos = position # Save previous position
      time += delta
      
      # (new) Ellipse Formula
      position.x = center.x + cos(time * orbit_speed) * radius_x
      position.y = center.y + sin(time * orbit_speed) * radius_y
      
      # (new) Calculate real instantaneous velocity (Derivative)
      # This gives us the exact direction it was moving
      velocity = (position - prev_pos) / delta

func _on_area_entered(area):
    hp -= 1
    area.queue_free()
    
    if hp <= 0:
        die()

func die():
    queue_free()`
    }
  ]}
/>

### What changes here?

1.  **Separated Radii**: Instead of `orbit_radius`, we have `radius_x` and `radius_y`.
    *   If `radius_x > radius_y`, the ellipse is **horizontal** (squashed).
    *   If `radius_y > radius_x`, the ellipse is **vertical** (tall and thin).

---

## 6. Reference Table

| Pattern | X Formula | Y Formula |
|--------|-----------|-----------|
| **Vertical Wave** | `x -= speed * delta` | `start_y + sin(t * freq) * amp` |
| **Horizontal Wave** | `start_x + sin(t * freq) * amp` | `y -= speed * delta` |
| **Circle** | `center_x + cos(t) * radius` | `center_y + sin(t) * radius` |
| **Ellipse** | `center_x + cos(t) * radius_x` | `center_y + sin(t) * radius_y` |
| **Spiral** | `center_x + cos(t) * (radius + t*k)` | `center_y + sin(t) * (radius + t*k)` |

---

## Testing in your World

1.  Open `world.tscn`.
2.  Duplicate your `Enemy.tscn` scene as `EnemyWave.tscn`.
3.  Modify the script with the wave code.
4.  Drag `EnemyWave.tscn` to the viewport.
5.  Adjust `wave_amplitude` and `wave_frequency` in the Inspector.
6.  Run (**F5**) and observe how it waves.

Experiment with different values:
*   `wave_amplitude = 100`, `wave_frequency = 2` → Slow and wide wave.
*   `wave_amplitude = 30`, `wave_frequency = 8` → Fast and short vibration.

---

## Let's review what we learned

1.  **`sin(x)`**: Function that moves between -1 and 1. Ideal for waving movement.
2.  **`cos(x)`**: Same as sin, but phased by 90°.
3.  **Time as input**: using `time += delta` to feed the functions.
4.  **Amplitude**: Multiplier that defines the range of movement.
5.  **Frequency**: Multiplier that defines the speed of the cycle.
6.  **Circle**: `cos` for X, `sin` for Y, same radius.
7.  **Ellipse**: `cos` for X, `sin` for Y, different radii.
8.  **States**: Combining patterns with `match` and timers.

In the **next chapter**, we will learn how to create **Combat Formations**: groups of enemies that move coordinately.
