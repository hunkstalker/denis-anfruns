---
pubDate: '2026-01-14T15:00:00Z'
tags: ['godot', 'gdscript', 'math', 'trigonometry', 'gamedev']
draft: false
new: true
title: 'Godot #5: Trigonometria de Combat'
description: Enemics que ondulen, orbiten i executen patrons matemàtics. Aprèn a fer servir Sinus i Cosinus per a moviments clàssics d'arcade.
series: gamedev-godot-basics
seriesTitle: Game Dev amb Godot
seriesDescription: Aprenem els fonaments del desenvolupament de videojocs (vectors, trigonometria, shaders) usant Godot i un Shoot 'em Up com a excusa pràctica.
lang: ca
---

import Callout from '../../../../components/mdx/Callout.astro';
import CodeTabs from '../../../../components/mdx/CodeTabs.astro';
import SineWaveDemo from '../../../../components/mdx/interactive/SineWaveDemo.tsx';

## Enemics Predictibles són Enemics Avorrits

Fins ara, els nostres enemics només es mouen en línia recta. Funciona, però no impressiona.
Els shooters clàssics com *Galaga*, *Gradius* o *R-Type* tenen enemics que **ondulen**, **orbiten** i executen **patrons coreografiats**.

La clau d'aquests moviments són dues funcions matemàtiques: **Sinus** i **Cosinus**.

## 1. El Sinus: L'Ona

El **Sinus** (`sin`) és una funció que retorna valors entre **-1** i **1** de forma cíclica.

Si grafiquem `sin(x)` on `x` va de 0 a 2π (una volta completa), obtenim una **ona**:

| Valor de x | sin(x) |
|------------|--------|
| 0 | 0 |
| π/2 (90°) | 1 (màxim) |
| π (180°) | 0 |
| 3π/2 (270°) | -1 (mínim) |
| 2π (360°) | 0 |

Després de 2π, el cicle es repeteix infinitament.

<SineWaveDemo client:load />

### Per a què serveix en un joc?

Si fem servir el **temps** com a entrada del sinus, obtenim un valor que oscil·la suaument:

<CodeTabs
  items={[
    {
      label: 'exemple.gd',
      lang: 'gdscript',
      code: `var offset_y = sin(temps) # Oscil·la entre -1 i 1`
    }
  ]}
/>

Multiplicant per una **amplitud**, controlem quant es mou:

<CodeTabs
  items={[
    {
      label: 'exemple.gd',
      lang: 'gdscript',
      code: `var offset_y = sin(temps) * 50 # Oscil·la entre -50 i 50 píxels`
    }
  ]}
/>

---

## 2. Un Nou Enemic: L'Helicòpter

Deixarem el nostre avió bàsic (`enemy.gd`) tal com està, movent-se recte. Per a aquests nous patrons, crearem un nou enemic, l'**Helicòpter**, del qual en farem **3 versions**:
1.  **Ona**: Es mou fent onades.
2.  **Òrbita**: Gira en cercles perfectes.
3.  **El·lipse**: Gira en ovals.

![Sprite de l'Helicòpter](/assets/gamedev-godot-basics/chopper_128.png)

> Clic dret -> Guardar imatge.  
> *Crèdits: <a href="https://wenrexa.itch.io/laser2020" target="_blank" rel="noopener noreferrer">Assets Free Laser Bullets Pack 2020</a> per **Wenrexa** (<a href="https://creativecommons.org/publicdomain/zero/1.0/" target="_blank" rel="noopener noreferrer">CC0 1.0</a>).*

### Pas 1: L'Helicòpter d'Ona

1.  Crea una nova escena heretada d'`Area2D` (o duplica el teu enemic i canvia l'sprite).
2.  Posa-li l'sprite de l'helicòpter.
3.  Crea un nou script anomenat `enemy_wave.gd`.

### L'Script de l'Ona

Volem que aquest enemic onduli verticalment mentre avança. Reutilitzarem la lògica bàsica de moviment i dany, afegint la màgia del `sin`.

<CodeTabs
  items={[
    {
      label: 'enemy_wave.gd',
      lang: 'gdscript',
      code: `extends Area2D

@export var speed = 200
@export var hp = 3
@export var wave_amplitude = 100.0  # (nou) Quant puja/baixa (en píxels)
@export var wave_frequency = 3.0    # (nou) Que tan ràpid ondula

var is_dying = false
var fall_speed = 0.0
var time = 0.0                      # (nou) Acumulador de temps
var start_y = 0.0                   # (nou) Posició Y inicial

func _ready():
    start_y = position.y              # (nou) Guardem la Y inicial
    area_entered.connect(_on_area_entered)

func _process(delta):
    if is_dying:
      fall_speed += 500 * delta
      position.y += fall_speed * delta
      position.x -= speed * 0.5 * delta 
    else:
      time += delta                   # (nou) Acumulem temps

      # Moviment horitzontal
      position.x -= speed * delta
          
      # (nou) Moviment vertical ondulatori
      position.y = start_y + sin(time * wave_frequency) * wave_amplitude

func _on_area_entered(area):
    if is_dying:
      return
    
    # Lògica de dany estàndard
    hp -= 1
    area.queue_free()   # Elimina el projectil/bala
    hit_flash()         # Flash-shader d'impacte

    if hp <= 0:
      die()

  func hit_flash():
    # El mateix codi de flash-shader d'impacte ...
    
  func die():
    # El mateix codi de mort ...`
    }
  ]}
/>

**Desglossament de la fórmula:**
*   `time += delta`: Acumulem el temps transcorregut. Com que `delta` representa els segons des de l'últim frame, `time` es converteix en un **rellotge en segons reals**. Això és crucial: si féssim servir `time += 1`, l'enemic ondularia més ràpid en PCs potents (més FPS = més increments per segon).
*   `time * wave_frequency`: Com més gran sigui la freqüència, més ràpid completa el cicle.
*   `sin(...)`: Retorna un valor entre -1 i 1.
*   `* wave_amplitude`: Converteix aquest rang a píxels reals.
*   `start_y + ...`: Centrem l'oscil·lació en la posició inicial.

---

## 3. El Cosinus: El Germà Desfasat

El **Cosinus** (`cos`) és idèntic al Sinus, però **desfasat 90°** (π/2 radians).

| Valor de x | sin(x) | cos(x) |
|------------|--------|--------|
| 0 | 0 | 1 |
| π/2 | 1 | 0 |
| π | 0 | -1 |
| 3π/2 | -1 | 0 |
| 2π | 0 | 1 |

Quan `sin` està a 0, `cos` està al seu màxim (o mínim), i viceversa.

### Per a què serveix?

Si fem servir `cos` per a l'**eix X** i `sin` per a l'**eix Y**, obtenim moviment **circular**.

---

## 4. Moviment Circular (Òrbita)

Un enemic que orbita al voltant d'un punt fa servir les dues funcions: `cos` per a X i `sin` per a Y.

### Implementació Pràctica

Per a aquests enemics orbitals, seguirem fent servir el nostre **Helicòpter**.

> Pots duplicar l'escena de l'helicòpter de la secció anterior (anomena-la `EnemyOrbital.tscn`) i canviar-li l'script, o simplement canviar l'script a la mateixa escena per provar.

Crea un script anomenat `enemy_orbital.gd`:

<CodeTabs
  items={[
    {
      label: 'enemy_orbital.gd',
      lang: 'gdscript',
      code: `extends Area2D

@export var speed = 200
@export var hp = 3
@export var orbit_radius = 100.0   # (nou) Radi del cercle
@export var orbit_speed = 2.0      # (nou) Velocitat angular

var is_dying = false
var velocity = Vector2.ZERO        # (nou) Per calcular inèrcia
var time = 0.0
var center = Vector2.ZERO          # (nou) Centre de l'òrbita

func _ready():
    center = position              # (nou) Guardem on hem començat
    area_entered.connect(_on_area_entered)

func _process(delta):
    if is_dying:
        # (nou) Gravetat sobre la velocitat acumulada
        velocity.y += 1000 * delta
        position += velocity * delta
        rotate(5 * delta)
    else:
        var prev_pos = position    # (nou) Guardem posició prèvia
        time += delta
    
        # (nou) Fórmula del Cercle
        position.x = center.x + cos(time * orbit_speed) * orbit_radius
        position.y = center.y + sin(time * orbit_speed) * orbit_radius
        
        # (nou) Calculem velocitat real (Inèrcia)
        velocity = (position - prev_pos) / delta

func _on_area_entered(area):
    if is_dying:
      # el mateix codi de mort ...

    if hp <= 0:
      die()                        # El mateix codi de dany ...

    func hit_flash():
      # El mateix codi de flash-shader d'impacte ...

    func die():
      # El mateix codi de mort ...`
    }
  ]}
/>

### Entenent el Codi

1.  **Lògica Base**: Mantenim `hp`, `_ready` amb la connexió del senyal, i les funcions de dany. Un enemic que no mor no serveix!
2.  **`orbit_radius`**: Defineix com de gran és el cercle.
3.  **`orbit_speed`**: Controla que tan ràpid fa voltes.
4.  **`center`**: Necessitem un punt fix al voltant del qual girar.
5.  **`time += delta`**: El nostre "rellotge" intern.
6.  **La Fórmula Màgica**:
    *   `cos(time)` ens dona la coordenada X.
    *   `sin(time)` ens dona la coordenada Y.
    *   Multipliquem pel radi per fer-ho més gran que 1 píxel.
    *   Sumem `center` perquè giri al voltant d'aquell punt, no de l'origen (0,0) del joc.

Aquest enemic es queda girant al lloc. En el futur, farem servir això per crear esquadrons que entren i es queden orbitant en formació.

---

## 5. El·lipses: Cercles Estirats

Un cercle té el mateix radi a X i Y. Una **el·lipse** té radis diferents.

> **Tip:** No necessites buscar un altre sprite. Pots duplicar la teva escena de l'helicòpter (`EnemyOrbital.tscn`) i reemplaçar el seu script per aquest nou.

Crea un script anomenat `enemy_ellipse.gd`:


<CodeTabs
  items={[
    {
      label: 'enemy_ellipse.gd',
      lang: 'gdscript',
      code: `extends Area2D

@export var speed = 200
@export var hp = 3
@export var radius_x = 150.0  # Radi horitzontal (més ample)
@export var radius_y = 50.0   # Radi vertical (més estret)
@export var orbit_speed = 1.5

var is_dying = false
var time = 0.0
var velocity = Vector2.ZERO
var center = Vector2.ZERO

func _ready():
    center = position
    area_entered.connect(_on_area_entered)

func _process(delta):
    if is_dying:
      # Apliquem gravetat sobre la velocitat que portàvem
      velocity.y += 1000 * delta
      position += velocity * delta
    else:
      var prev_pos = position # Guardem posició abans de moure
      time += delta
      
      # (nou) Fórmula de l'El·lipse
      position.x = center.x + cos(time * orbit_speed) * radius_x
      position.y = center.y + sin(time * orbit_speed) * radius_y
      
      # (nou) Calculem la velocitat real instantània (Derivada)
      # Això ens dona la direcció exacta en la que es movia
      velocity = (position - prev_pos) / delta

func _on_area_entered(area):
    hp -= 1
    area.queue_free()
    
    if hp <= 0:
        die()

func die():
    queue_free()`
    }
  ]}
/>

### Què canvia aquí?

1.  **Radis Separats**: En lloc d'`orbit_radius`, tenim `radius_x` i `radius_y`.
    *   Si `radius_x > radius_y`, l'el·lipse és **horitzontal** (aixafada).
    *   Si `radius_y > radius_x`, l'el·lipse és **vertical** (alta i prima).

---

## 6. Taula de Referència

| Patró | Fórmula X | Fórmula Y |
|--------|-----------|-----------|
| **Ona vertical** | `x -= speed * delta` | `start_y + sin(t * freq) * amp` |
| **Ona horitzontal** | `start_x + sin(t * freq) * amp` | `y -= speed * delta` |
| **Cercle** | `centre_x + cos(t) * radi` | `centre_y + sin(t) * radi` |
| **El·lipse** | `centre_x + cos(t) * radi_x` | `centre_y + sin(t) * radi_y` |
| **Espiral** | `centre_x + cos(t) * (radi + t*k)` | `centre_y + sin(t) * (radi + t*k)` |

---

## Provant al teu Món

1.  Obre `world.tscn`.
2.  Duplica la teva escena `Enemy.tscn` com a `EnemyWave.tscn`.
3.  Modifica l'script amb el codi d'ondulació.
4.  Arrossega `EnemyWave.tscn` al viewport.
5.  Ajusta `wave_amplitude` i `wave_frequency` a l'Inspector.
6.  Executa (**F5**) i observa com ondula.

Experimenta amb valors diferents:
*   `wave_amplitude = 100`, `wave_frequency = 2` → Ondulació lenta i àmplia.
*   `wave_amplitude = 30`, `wave_frequency = 8` → Vibració ràpida i curta.

---

## Repassem el que hem après

1.  **`sin(x)`**: Funció que oscil·la entre -1 i 1. Ideal per a moviment ondulatori.
2.  **`cos(x)`**: Igual que sin, però desfasat 90°.
3.  **Temps com a entrada**: Fer servir `time += delta` per alimentar les funcions.
4.  **Amplitud**: Multiplicador que defineix el rang de moviment.
5.  **Freqüència**: Multiplicador que defineix la velocitat del cicle.
6.  **Cercle**: `cos` per a X, `sin` per a Y, mateix radi.
7.  **El·lipse**: `cos` per a X, `sin` per a Y, radis diferents.
8.  **Estats**: Combinar patrons amb `match` i temporitzadors.

En el **proper capítol**, aprendrem a crear **Formacions de Combat**: grups d'enemics que es mouen coordinadament.
