---
pubDate: '2026-01-12T10:00:00Z'
tags: ['godot', 'gdscript', 'instances', 'pooling']
draft: false
new: true
title: 'Godot #2: Instanciación y Balas'
description: 'Aprende a crear objetos dinámicamente: instanciar balas, rotaciones y el concepto de Object Pooling para optimizar tu juego.'
series: gamedev-godot-basics
seriesTitle: Game Dev con Godot
seriesDescription: Aprendemos los fundamentos del desarrollo de videojuegos (vectores, trigonometría, shaders) usando Godot y un Shoot 'em Up como excusa práctica.
lang: es
---

import Callout from '../../../../components/mdx/Callout.astro';
import CodeTabs from '../../../../components/mdx/CodeTabs.astro';
import VectorDemo from '../../../../components/mdx/interactive/VectorDemo.tsx';

## Instanciación: El arte de crear cosas de la nada

En la parte anterior movimos nuestra nave. Ahora toca que la nave haga algo más que pasear: **Disparar**.

## ¿Qué vamos a aprender?
1.  **Instanciar Escenas**: Usar `preload` y `instantiate` para crear balas.
2.  **Scene Tree**: Entender dónde poner esas balas (`add_child`) para que no se muevan con la nave.
3.  **Local vs Global**: Coordenadas para que la bala salga del cañón, no del origen del mundo.
4.  **Limpieza**: Usar `VisibleOnScreenNotifier2D` para borrar balas y no fundir la RAM.


## 1. Receta: La Bala (`bullet.tscn`)

Antes de disparar nada, necesitamos algo que disparar.
Vamos a crear una bala que sepa moverse y morir cuando salga de la pantalla.

Igual que hicimos con la nave, si quieres puedes descargar esta imagen para la bala:

![Sprite de la Bala (Atlas)](/assets/gamedev-godot-basics/shot-atlas.png)

> Clic derecho -> Guardar imagen.  
> *Créditos: <a href="https://mattwalkden.itch.io/lunar-battle-pack" target="_blank" rel="noopener noreferrer">Lunar Battle Pack</a> por **MattWalkden** (<a href="https://creativecommons.org/publicdomain/zero/1.0/" target="_blank" rel="noopener noreferrer">CC0 1.0</a>).*


1.  Crea una **Nueva Escena**.
2.  Nodo raíz: **`Area2D`** (¡Ojo! No queremos físicas complejas como chocarse y rebotar, solo detectar si *tocamos* algo). Llámalo `Bullet`.
3.  Hijo: **`CollisionShape2D`** (con forma de rectángulo o cápsula pequeña que cubra el sprite).
4.  Hijo: **`AnimatedSprite2D`**: [NUEVO] ¡Vamos a darle vida! No usaremos una imagen estática.
    *   En el **Inspector**, busca la propiedad `Sprite Frames` -> Pulsa donde pone `<empty>` -> Selecciona **`New SpriteFrames`**.
    *   Haz clic de nuevo sobre el texto `SpriteFrames` que acabas de crear para abrir el panel inferior de edición.
    *   En el panel inferior, busca el icono de **rejilla** ("Add frames from sprite sheet") y púlsalo.

    ![Rejilla de SpriteFrames](/assets/gamedev-godot-basics/screenshot_3.webp)

    *   Selecciona el archivo `shot-atlas.png`.
    *   En la ventana emergente verás tu imagen. Configura las divisiones: **Horizontal: 3**, **Vertical: 1**.
    *   Selecciona los 3 cuadros (haz clic o arrastra) para iluminarlos y pulsa **Add 3 frames**.
    *   **Configuración de la Animación**:
        *   Busca el botón **"Loop"** (icono de flechas giratorias) en el panel izquierdo y **DESACTÍVALO**. Queremos que crezca una vez y se quede grande, no que palpite.
        *   Cambia **FPS** (Speed) a **12**. Como son solo 3 frames, esto hará que "crezca" súper rápido (en 0.25 segundos).
    *   Finalmente, en el **Inspector** del nodo `AnimatedSprite2D`, activa el botón **"Autoplay on Load"** (icono con una `A` y una flecha junto a la propiedad Animation). Esto asegura que la animación arranque sola al disparar.
5.  Hijo: **`VisibleOnScreenNotifier2D`**: Este nodo es mágico. Nos avisa cuando el objeto sale de la pantalla.
    *   *Asegúrate de que el rectángulo rosa de este nodo cubra todo el sprite.*


#### 1.1 Limpieza Automática (Señales)

Antes de programar el movimiento, vamos a asegurarnos de que la bala se borre al salir de pantalla.
Para esto usaremos una **Señal**.

El nodo `VisibleOnScreenNotifier2D` emite la señal `screen_exited` cuando sale de la pantalla.
Nosotros (el script) conectaremos esa señal a una función para reaccionar.

**Pasos para conectar el cable:**
1.  Añade un script a la bala (`bullet.gd`) si no lo has hecho.
2.  Selecciona el nodo `VisibleOnScreenNotifier2D`.
3.  Ve a la pestaña **Node** (a la derecha, junto al Inspector).
4.  Haz doble clic en la señal `screen_exited`.
5.  Dale a **Connect**.
6.  Godot escribirá automáticamente una función llamada `_on_visible_on_screen_notifier_2d_screen_exited` en tu script.

Usar el panel **Node** es la "vía rápida" o de prototipado. Es visual y excelente para empezar.
Sin embargo, en proyectos serios o para lógicas complejas, solemos conectar las señales por **Código** para tener mayor control y que nada dependa de clicks en el editor.

Para esta bala sencilla, el método visual es perfecto. En el **próximo capítulo** aprenderemos la forma por código ("La forma Profesional") cuando creemos a los enemigos.

Ahora que tenemos la conexión, completemos el código:

<CodeTabs
  items={[
    {
      label: 'bullet.gd',
      lang: 'gdscript',
      code: `extends Area2D

var speed = 1500

func _physics_process(delta: float) -> void:
    position.x += speed * delta

func _on_visible_on_screen_notifier_2d_screen_exited() -> void:
    queue_free()`
    }
  ]}
/>

**Desglose del Script:**

**1. `extends Area2D`**
Heredamos de `Area2D` porque solo necesitamos detectar si la bala "toca" algo. No necesitamos rebotes físicos (RigidBody) ni movimiento complejo de personaje (CharacterBody).

**2. `position.x += speed * delta`**
Queremos que la bala avance sola hacia la derecha (X positivo). Para ello, sumamos velocidad a su posición en cada fotograma. Multiplicamos por `speed` para definir la rapidez y por `delta` para asegurar que el movimiento sea fluido y consistente en cualquier ordenador (evitando que vaya más rápido si tienes más FPS).

**3. `_on_..._screen_exited()`**
Las balas infinitas consumen memoria hasta que el juego explota. Necesitamos detectar cuándo la bala sale de la cámara y deja de ser útil. Usamos la señal del nodo `VisibleOnScreenNotifier2D` para avisarnos y llamamos a `queue_free()` para eliminarla limpiamente.

> **Nota sobre Rendimiento (El mito de `queue_free`)**:
> `queue_free()` le dice a la RAM: *"Borra esto y libera espacio"*. Y al disparar de nuevo: *"Busca espacio y asigna memoria"*.
> En un juego normal, no pasa nada. Pero en un **Bullet Hell** con 5.000 balas, hacer esto constantemente causaría tirones (lag) porque el procesador se saturaría limpiando basura.
> *Solución futura*: En capítulos avanzados veremos **Object Pooling** (reciclar balas en lugar de borrarlas). Por ahora, `queue_free()` es perfecto.

¿Qué significa queue_free()?

Traducido literal: **"Poner en cola para liberar"**.

En programación de videojuegos, borrar algo mientras se está usando es peligroso (puede cerrar el juego de golpe).
`queue_free()` es la forma segura de hacerlo:

1.  Marcas el objeto para borrar.
2.  Godot espera a terminar de dibujar el fotograma actual (Frame).
3.  En el momento seguro ("Idle time"), borra el objeto de la memoria.

Usa siempre `queue_free()` en lugar de `free()` para evitar errores.

## 2. El Plano y el Objeto (PackedScene)

En Godot, hay una distinción fundamental:
*   **`.tscn` (La Escena)**: Es el montaje original. Define qué nodos lo componen y cómo funcionan.
*   **La Instancia**: Es una **copia viva** de esa escena. El juego crea estas copias para usarlas (una copia para el jugador, 10 copias para balas, etc.).

Cuando juegas, interactúas con estas copias.
Para disparar, necesitamos crear una **nueva copia** de la escena `bullet.tscn` cada vez que pulsas espacio.

### El proceso de construcción
En GDScript, crear algo nuevo tiene 3 pasos:
1.  **Cargar el Plano**: `preload("res://bullet.tscn")`.
2.  **Instanciar**: `plano.instantiate()`. Construyes el objeto en la memoria RAM, pero **aún no existe en el mundo visible**.
3.  **Añadir al Árbol**: `add_child(bala)`. Aquí colocas el objeto en el universo del juego.

**¿Por qué `preload` y no `load`?**

Godot tiene dos formas de cargar recursos:
*   **`preload("ruta")`**: Carga la escena **cuando el juego arranca**. Es más rápido en ejecución porque ya está en memoria, pero consume RAM desde el inicio.
*   **`load("ruta")`**: Carga la escena **bajo demanda**, en el momento exacto que se ejecuta esa línea. Ahorra RAM inicial, pero puede causar tirones (micro-parones) si el recurso es pesado.

Para balas (archivos pequeños que usaremos constantemente), `preload` es la elección correcta.

## 3. Implementando el Disparo

### ¿Cómo preguntamos al juego?
Para disparar, necesitamos que el script tome decisiones. Usamos dos herramientas nuevas:
1.  **`if` (Condicional)**: "SI pasa esto... haz esto otro".
2.  **`Input`**: En el capítulo anterior usamos `get_vector`. Ahora usaremos `is_action_pressed` ("¿Está la tecla mantenida?").

Pero cuidado: `_physics_process` se ejecuta 60 veces por segundo. Si disparamos cada vez que la tecla está "mantenida", crearemos una línea sólida de 60 balas en un segundo. 

Necesitamos un **Limitador de Cadencia** (Cooldown). Una forma sencilla es usar una variable "bandera" (`can_shoot`) y un temporizador.

Veamos un ejemplo (que tiene un problema):


<CodeTabs
  items={[
    {
      label: 'player.gd',
      lang: 'gdscript',
      code: `
extends CharacterBody2D

@export var speed = 400
@export var fire_rate = 0.125 # Cadencia rápida
var bullet_scene = preload("res://scenes/bullet.tscn")

var can_shoot = true
var shoot_timer = 0.0

func _physics_process(delta: float) -> void:
    # Movimiento
    var direction = Input.get_vector("move_left", "move_right", "move_up", "move_down")
    velocity = direction * speed
    move_and_slide()
    
    # Cooldown (Timer)
    if not can_shoot:
        shoot_timer -= delta
        if shoot_timer <= 0.0:
            can_shoot = true

    # Disparo
    if Input.is_action_pressed("shoot") and can_shoot:
        shoot()

func shoot():
    can_shoot = false
    shoot_timer = fire_rate
    
    var bala = bullet_scene.instantiate()
    add_child(bala) # <--- EL ERROR (Canguro)`
    }
  ]}
/>

Aquí hemos creado una función propia `shoot()` para organizar el código. Usamos `shoot_timer` para controlar el ritmo de disparo de forma precisa y sincronizada con el motor de físicas.

### El Problema de la Jerarquía

**¡Prueba el juego ahora (F5)!**
Muévete con la nave mientras disparas ráfagas. ¿Notas algo raro?
Las balas se mueven contigo. Si avanzas, las balas te siguen.

Esto ocurre porque la bala es **hija de la nave**. Hereda su movimiento.

La bala será **hija de la nave**.
*   Si la nave avanza, la bala avanza con ella (más su propia velocidad).
*   Si la nave rota, la bala rotará orbitando alrededor de la nave.

¡Queremos que la bala sea independiente! Una vez disparada, no debería importarle qué hace la nave.

### La Solución: Divorcio de Coordenadas
La bala debe nacer en el **Mundo**, no en la Nave. Pero necesitamos que nazca *donde está la nave*.

<CodeTabs
  items={[
    {
      label: 'player.gd',
      lang: 'gdscript',
      code: `func shoot():
    can_shoot = false
    shoot_timer = fire_rate
    
    var bala = bullet_scene.instantiate()
    # 1. Añadir al "Padre" (el Mundo) PRIMERO
    get_parent().add_child(bala)
     
    # 2. COLOCAR
    bala.global_position = global_position`
    }
  ]}
/>
**Desglose de la Inyección:**

**1. `var bala = bullet_scene.instantiate()`**
`bullet_scene` es solo el plano (el molde). No existe en el juego. Para tener una bala real, usamos `.instantiate()`, que crea una copia tangible en la memoria lista para ser usada. Guardamos esta nueva bala en una variable.

**2. `get_parent().add_child(bala)`**
Si usáramos `add_child(bala)` directamente, la bala sería hija de la Nave. Esto causaría que rotara y se moviera con ella (como si estuviera pegada al casco).
Para "divorciarla", pedimos el padre de la nave (`get_parent()`, que es el Mundo) y le entregamos la bala a él. Así ambos viven en el mismo universo pero se mueven independientes.

**3. `bala.global_position = global_position`**
Al nacer en el Mundo, la bala aparecería en el origen (0,0) por defecto. Necesitamos teletransportarla a la boca del cañón.
Al igualar la `global_position` de la bala con la nuestra (o la del `Muzzle`), nos aseguramos de que empiece su viaje exactamente donde estamos nosotros en el universo.

**4. Velocidad y Física**
Como nuestras balas van muy rápido (1500), no necesitamos calcular inercias complejas. La propia velocidad hace que el "efecto doppler" sea invisible. Es la ventaja de los juegos Arcade: a veces, la solución más bruta es la mejor.

### 4. Ajustando la Posición de Salida (Marker2D)

Ahora mismo la bala sale del centro de la nave (su barriga). Queda feo.
Para arreglarlo, usaremos un nodo invisible que sirva de "referencia".

1.  Añade un nodo hijo **`Marker2D`** a tu Player.
2.  Llámalo **`Muzzle`** (Boquilla).
3.  Muévelo visualmente hasta la punta del cañón (o donde quieras que salgan las balas).

Ahora actualizamos el código para usar este marcador:

<CodeTabs
  items={[
    {
      label: 'player.gd',
      lang: 'gdscript',
      code: `func shoot():
    can_shoot = false
    shoot_timer = fire_rate
    
    var bala = bullet_scene.instantiate()
    
    get_parent().add_child(bala)
     
    # Usamos la posición del Muzzle
    bala.global_position = $Muzzle.global_position`
    }
  ]}
/>

### Resumen y Retos

Hoy has aprendido uno de los conceptos fundamentales del desarrollo de software: **Instanciación** (crear objetos dinámicamente).

Repasemos los conceptos clave:
1.  **Escenas (`.tscn`)**: Son los planos (moldes) de tus objetos.
2.  **Instanciar**: Convertir esos planos en objetos vivos en el juego (`.instantiate()`).
3.  **Nodos Marker2D**: Puntos de referencia invisibles vitales para `spawns`.
4.  **Señales**: Cables invisibles para que los objetos hablen (`screen_exited`).
5.  **`queue_free()`**: La forma segura de borrar basura de la memoria.

En el **próximo capítulo**, convertiremos este campo de tiro vacío en una batalla real. Crearemos **Enemigos** que gestionan su propia vida y detectan colisiones. ¡Prepara la munición!
