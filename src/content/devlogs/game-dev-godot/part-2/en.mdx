---
pubDate: '2026-01-12T10:00:00Z'
tags: ['godot', 'gdscript', 'instances', 'pooling']
draft: false
new: true
title: 'Godot #2: Instancing & Bullets'
description: 'Learn to create objects dynamically: instancing bullets, rotations, and the concept of Object Pooling to optimize your game.'
series: gamedev-godot-basics
seriesTitle: Game Dev with Godot
seriesDescription: We learn the fundamentals of game development (vectors, trigonometry, shaders) using Godot and a Shoot 'em Up as a practical excuse.
lang: en
---

import Callout from '../../../../components/mdx/Callout.astro';
import CodeTabs from '../../../../components/mdx/CodeTabs.astro';
import VectorDemo from '../../../../components/mdx/interactive/VectorDemo.tsx';

## Instancing: The art of creating things from nothing

In the previous part, we moved our ship. Now it's time for the ship to do more than just wander around: **Shoot**.

## What will we learn?
1.  **Instancing Scenes**: Using `preload` and `instantiate` to create bullets.
2.  **Scene Tree**: Understanding where to place those bullets (`add_child`) so they don't move with the ship.
3.  **Local vs Global**: Coordinates so the bullet comes out of the cannon, not the world origin.
4.  **Cleanup**: Using `VisibleOnScreenNotifier2D` to delete bullets and not melt the RAM.
5.  **Bonus: Object Pooling**: Introduction to recycling bullets for extreme performance.

## 1. Recipe: The Bullet (`bullet.tscn`)

Before firing anything, we need something to fire.
We're going to create a bullet that knows how to move and die when it leaves the screen.

Just like we did with the ship, if you want you can download this image for the bullet:

![Bullet Sprite](/assets/gamedev-godot-basics/shot.png)

> Right click -> Save image.  
> *Credits: <a href="https://wenrexa.itch.io/laser2020" target="_blank" rel="noopener noreferrer">Assets Free Laser Bullets Pack 2020</a> by **Wenrexa** (<a href="https://creativecommons.org/publicdomain/zero/1.0/" target="_blank" rel="noopener noreferrer">CC0 1.0</a>).*


1.  Create a **New Scene**.
2.  Root Node: **`Area2D`** (Note! We don't want complex physics like colliding and bouncing, just detecting if we *touch* something). Call it `Bullet`.
3.  Child: **`CollisionShape2D`** (with a rectangle or small capsule shape).
4.  Child: **`Sprite2D`** (use a small rectangle or your bullet image, and put it in the sprites folder).
5.  Child: **`VisibleOnScreenNotifier2D`**: This node is magic. It warns us when the object leaves the screen.
    *   *Make sure the pink rectangle of this node covers the sprite.*


#### 1.1 Automatic Cleanup (Signals)

Before programming the movement, let's make sure the bullet is deleted when leaving the screen.
For this, we'll use a **Signal**.

The `VisibleOnScreenNotifier2D` node emits the `screen_exited` signal when it leaves the screen.
We (the script) will connect that signal to a function to react.

**Steps to connect the cable:**
1.  Add a script to the bullet (`bullet.gd`) if you haven't done so.
2.  Select the `VisibleOnScreenNotifier2D` node.
3.  Go to the **Node** tab (on the right, next to Inspector).
4.  Double click on the `screen_exited` signal.
5.  Click on **Connect**.
6.  Godot will automatically write a function called `_on_visible_on_screen_notifier_2d_screen_exited` in your script.

Using the **Node** panel is the "fast track" or prototyping way. It's visual and excellent for starting out.
However, in serious projects or for complex logic, we usually connect signals via **Code** to have more control so nothing depends on clicks in the editor.

For this simple bullet, the visual method is perfect. In the **next chapter**, we will learn the code way ("The Professional Way") when we create enemies.

Now that we have the connection, let's complete the code:

<CodeTabs
  items={[
    {
      label: 'bullet.gd',
      lang: 'gdscript',
      code: `extends Area2D

var speed = 600

func _process(delta):
    position.x += speed * delta # Move to the RIGHT (Positive X is right in Godot)

# This function was created automatically by Godot when connecting the signal.
# We only write what's inside.
func _on_visible_on_screen_notifier_2d_screen_exited():
    queue_free() # If we leave the screen, we self-destruct`
    }
  ]}
/>

What does queue_free() mean?

Literally translated: **"Queue to free"**.

In video game programming, deleting something while it is being used is dangerous (it can crash the game suddenly).
`queue_free()` is the safe way to do it:

1.  Mark the object for deletion.
2.  Godot waits to finish drawing the current frame (Frame).
3.  At the safe moment ("Idle time"), it deletes the object from memory.

Always use `queue_free()` instead of `free()` to avoid errors.

## 2. The Blueprint and the Object (PackedScene)

In Godot, there is a fundamental distinction:
*   **`.tscn` (The Scene)**: It's the original blueprint. It defines what nodes compose it and how they work.
*   **The Instance**: It's a **living copy** of that scene. The game creates these copies to use them (one copy for the player, 10 copies for bullets, etc.).

When you play, you interact with these copies.
To shoot, we need to create a **new copy** of the `bullet.tscn` scene every time you press space.

### The construction process
In GDScript, creating something new has 3 steps:
1.  **Load the Blueprint**: `preload("res://bullet.tscn")`.
2.  **Instantiate**: `blueprint.instantiate()`. You build the object in RAM memory, but **it doesn't exist in the visible world yet**.
3.  **Add to Tree**: `add_child(bullet)`. Here you place the object in the game universe.

**Why `preload` and not `load`?**

Godot has two ways to load resources:
*   **`preload("path")`**: Loads the scene **when the game starts**. It's faster in execution because it's already in memory, but consumes RAM from the start.
*   **`load("path")`**: Loads the scene **on demand**, at the exact moment that line executes. Saves initial RAM, but can cause stutters (micro-freezes) if the resource is heavy.

For bullets (small files we'll use constantly), `preload` is the right choice.

## 3. Implementing the Shot

### How do we ask the game?
To shoot, we need the script to make decisions. We use two new tools:
1.  **`if` (Conditional)**: Means **"IF"**. "IF this happens... do this other thing".
2.  **`Input` (The Ear)**: It's who listens to your keyboard. `is_action_just_pressed` returns `true` only at the exact instant you press down the finger. Ideal for single-shot firing.

Let's look at an example (which has a problem):


<CodeTabs
  items={[
    {
      label: 'player.gd',
      lang: 'gdscript',
      code: `extends CharacterBody2D

@export var speed = 400
# Load the Bullet "Blueprint"
var bullet_scene = preload("res://scenes/bullet.tscn")

func _physics_process(delta):
    # 1. Movement (What you already had)
    var direction = Input.get_vector("ui_left", "ui_right", "ui_up", "ui_down")
    velocity = direction * speed
    move_and_slide()

    # 2. Shooting (The NEW stuff)
    if Input.is_action_just_pressed("ui_accept"): # Space bar
        var bullet = bullet_scene.instantiate()
        add_child(bullet) # <--- THE ERROR (Kangaroo)`
    }
  ]}
/>

### The Hierarchy Problem

**Test the game now (F5)!**
Move with the ship while firing bursts. Notice anything weird?
The bullets move with you. If you advance, the bullets follow you.

This happens because the bullet is a **child of the ship**. It inherits its movement.

The bullet will be a **child of the ship**.
*   If the ship advances, the bullet advances with it (plus its own speed).
*   If the ship rotates, the bullet will rotate orbiting around the ship.

We want the bullet to be independent! Once fired, it shouldn't care what the ship does.

### The Solution: Coordinate Divorce
The bullet must be born in the **World**, not in the Ship. But we need it to be born *where the ship is*.

<CodeTabs
  items={[
    {
      label: 'player.gd',
      lang: 'gdscript',
      code: `# Correct: Using the parent (The World Scene)
    if Input.is_action_just_pressed("ui_accept"):
        var bullet = bullet_scene.instantiate()
        
        # 1. Add to the "Parent" (the World) FIRST
        # We need the bullet to have a parent so it can calculate its global coordinates
        get_parent().add_child(bullet)
         
        # 2. PLACE
        # Now that it's in the world, we tell it "put yourself where I am"
        bullet.global_position = global_position`
    }
  ]}
/>
In the line `bullet.global_position = global_position`:
*   The `global_position` on the left is the **Bullet's**.
*   The `global_position` on the right is **the Ship's** (the script where we are writing).

We are saying: *"Bullet, place yourself in the world EXACTLY where I (the Ship) am right now"*.

If we used `bullet.position = position`, we would be saying *"Bullet, place yourself relative to the World (bullet's parent) the same way I am relative to the World"*. If the ship is at (100, 100), the bullet would appear at (100, 100). This seems correct!

Always using **Global** avoids headaches: we treat universal coordinates equally.

### Pro Tip: Shooting from the Cannon (`Marker2D`)
Right now the bullet comes out of the center of the ship (its belly). It looks ugly.
You could try adding magic numbers (`global_position + Vector2(50, 0)`), but if you change the ship sprite, you'll have to change the code.

The elegant solution:
1.  Add a child node **`Marker2D`** to your Player.
2.  Move it visually to the tip of the cannon. Call it `Muzzle`.
3.  In the code, use the position of that marker:

#### Marker Position
<CodeTabs
  items={[
    {
      label: 'player.gd',
      lang: 'gdscript',
      code: `# Instead of using my position, I use the marker's
bullet.global_position = $Muzzle.global_position `
    }
  ]}
/>
<Callout type="info" title="What is that Dollar sign?">
  Writing `$Muzzle` is the short and fast way to say `get_node("Muzzle")`.
  You are telling Godot: *"Search among my direct children for the one named Muzzle"*.
</Callout>

Now the bullet will always come out of the right place, even if you change the ship!

## 4. Optimization: The myth of `queue_free()`

When a bullet leaves the screen, we usually do:

<CodeTabs
  items={[
    {
      label: 'bullet.gd',
      lang: 'gdscript',
      code: `func _on_visible_on_screen_notifier_2d_screen_exited():
    queue_free() # Goodbye, bullet.`
    }
  ]}
/>

*(Note: The function name may vary depending on how you name your Notifier/Enabler node. Godot generates it automatically when connecting the signal).*

This tells the RAM: *"Delete this data and free up space"*. And when you shoot again: *"Search for free space and assign new memory"*.

In a normal game, nothing happens.
In a **Bullet Hell** with 5,000 bullets per minute, this is suicide.
The "Garbage Collector" of the CPU will become saturated cleaning and creating memory, causing stutters (micro-stuttering).

Let's review what we learned:
1.  **Scenes (`.tscn`)**: They are the blueprints of your objects.
2.  **Instantiating**: Converting those blueprints into living objects in the game.
3.  **Signals**: Invisible cables for objects to talk (`screen_exited`).
4.  **`queue_free()`**: The safe way to delete garbage.

Congratulations! You have created your first semi-functional weapon. For now we can shoot it, but it damages nothing.

In the **next chapter**, we will give them something to shoot at.
We will create **Enemies** that will fly towards you and we will learn to detect when a bullet hits them.
