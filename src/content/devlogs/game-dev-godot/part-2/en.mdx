---
pubDate: '2026-01-12T10:00:00Z'
tags: ['godot', 'gdscript', 'instances', 'pooling']
draft: false
new: true
title: 'Godot #2: Instancing and Bullets'
description: 'Learn to create objects dynamically: instancing bullets, rotations and the concept of Object Pooling to optimize your game.'
series: gamedev-godot-basics
seriesTitle: Game Dev with Godot
seriesDescription: We learn the fundamentals of video game development (vectors, trigonometry, shaders) using Godot and a Shoot em Up as a practical excuse.
lang: en
---

import Callout from '../../../../components/mdx/Callout.astro';
import CodeTabs from '../../../../components/mdx/CodeTabs.astro';
import VectorDemo from '../../../../components/mdx/interactive/VectorDemo.tsx';

## Instancing: The art of creating things from nothing

In the previous part we moved our ship. Now it's time for the ship to do something more than taking a walk: **Shoot**.

## What will we learn?
1.  **Instancing Scenes**: Use `preload` and `instantiate` to create bullets.
2.  **Scene Tree**: Understand where to put those bullets (`add_child`) so they don't move with the ship.
3.  **Local vs Global**: Coordinates so the bullet exits the cannon, not the origin of the world.
4.  **Cleanup**: Use `VisibleOnScreenNotifier2D` to delete bullets and not melt the RAM.


## 1. Recipe: The Bullet (`bullet.tscn`)

Before shooting anything, we need something to shoot.
We are going to create a bullet that knows how to move and die when it leaves the screen.

Same as we did with the ship, if you want you can download this image for the bullet:

![Bullet Sprite (Atlas)](/assets/gamedev-godot-basics/shot-atlas.png)

> Right click -> Save image.  
> *Credits: <a href="https://mattwalkden.itch.io/lunar-battle-pack" target="_blank" rel="noopener noreferrer">Lunar Battle Pack</a> by **MattWalkden** (<a href="https://creativecommons.org/publicdomain/zero/1.0/" target="_blank" rel="noopener noreferrer">CC0 1.0</a>).*


1.  Create a **New Scene**.
2.  Root Node: **`Area2D`** (Careful! We don't want complex physics like colliding and bouncing, only detecting if we *touch* something). Name it `Bullet`.
3.  Child: **`CollisionShape2D`** (with rectangle or capsule shape covering the sprite).
4.  Child: **`AnimatedSprite2D`**: [NEW] We are going to give it life! We won't use a static image.
    *   In the **Inspector**, seek the property `Sprite Frames` -> Click where it says `<empty>` -> Select **`New SpriteFrames`**.
    *   Click again on the text `SpriteFrames` you just created to open the bottom edition panel.
    *   In the bottom panel, look for the **grid** icon ("Add frames from sprite sheet") and click it.

    ![SpriteFrames Grid](/assets/gamedev-godot-basics/screenshot_3.webp)

    *   Select the file `shot-atlas.png`.
    *   In the popup window you will see your image. Configure the divisions: **Horizontal: 3**, **Vertical: 1**.
    *   Select the 3 frames (click or drag) to highlight them and press **Add 3 frames**.
    *   **Animation Configuration**:
        *   Look for the **"Loop"** button (rotating arrows icon) on the left panel and **DISABLE IT**. We want it to grow once and stay big, not pulsate.
        *   Change **FPS** (Speed) to **12**. Since there are only 3 frames, this will make it "grow" super fast (in 0.25 seconds).
    *   Finally, in the **Inspector** of the `AnimatedSprite2D` node, activate the **"Autoplay on Load"** button (icon with an `A` and an arrow next to the Animation property). This ensures the animation starts alone when shooting.
5.  Child: **`VisibleOnScreenNotifier2D`**: This node is magic. It warns us when the object leaves the screen.
    *   *Make sure the pink rectangle of this node covers the entire sprite.*


#### 1.1 Automatic Cleanup (Signals)

Before programming the movement, let's make sure the bullet deletes itself when leaving the screen.
For this we will use a **Signal**.

The node `VisibleOnScreenNotifier2D` emits the signal `screen_exited` when it leaves the screen.
We (the script) will connect that signal to a function to react.

**Steps to connect the cable:**
1.  Add a script to the bullet (`bullet.gd`) if you haven't done it.
2.  Select the node `VisibleOnScreenNotifier2D`.
3.  Go to the **Node** tab (on the right, next to Inspector).
4.  Double click on the signal `screen_exited`.
5.  Hit **Connect**.
6.  Godot will automatically write a function named `_on_visible_on_screen_notifier_2d_screen_exited` in your script.

Using the **Node** panel is the "fast way" or prototyping way. It is visual and excellent to start.
However, in serious projects or for complex logics, we usually connect signals by **Code** to have greater control and nothing depends on clicks in the editor.

For this simple bullet, the visual method is perfect. In the **next chapter** we will learn the way by code ("The Professional Way") when we create the enemies.

Now that we have the connection, let's complete the code:

<CodeTabs
  items={[
    {
      label: 'bullet.gd',
      lang: 'gdscript',
      code: `extends Area2D

var speed = 1500

func _physics_process(delta: float) -> void:
    position.x += speed * delta

func _on_visible_on_screen_notifier_2d_screen_exited() -> void:
    queue_free()`
    }
  ]}
/>

**Script Breakdown:**

**1. `extends Area2D`**
We inherit from `Area2D` because we only need to detect if the bullet "touches" something. We don't need physical bounces (RigidBody) nor complex character movement (CharacterBody).

**2. `position.x += speed * delta`**
We want the bullet to advance alone to the right (positive X). To do this, we add speed to its position in each frame. We multiply by `speed` to define the quickness and by `delta` to ensure the movement is fluid and consistent on any computer (avoiding it going faster if you have more FPS).

**3. `_on_..._screen_exited()`**
Infinite bullets consume memory until the game explodes. We need to detect when the bullet leaves the camera and stops being useful. We use the signal of the node `VisibleOnScreenNotifier2D` to warn us and we call `queue_free()` to eliminate it cleanly.

> **Note on Performance (The myth of `queue_free`)**:
> `queue_free()` tells RAM: *"Delete this and free space"*. And when shooting again: *"Search space and assign memory"*.
> In a normal game, nothing happens. But in a **Bullet Hell** with 5,000 bullets, doing this constantly would cause stutters (lag) because the processor would saturate cleaning garbage.
> *Future solution*: In advanced chapters we will see **Object Pooling** (recycle bullets instead of deleting them). For now, `queue_free()` is perfect.

What does queue_free() mean?

Translated literally: **"Put in queue to free"**.

In video game programming, deleting something while it is being used is dangerous (can crash the game abruptly).
`queue_free()` is the safe way to do it:

1.  You mark the object for deletion.
2.  Godot waits to finish drawing the current frame.
3.  In the safe moment ("Idle time"), it deletes the object from memory.

Always use `queue_free()` instead of `free()` to avoid errors.

## 2. The Blueprint and the Object (PackedScene)

In Godot, there is a fundamental distinction:
*   **`.tscn` (The Scene)**: It is the original assembly. Defines what nodes compose it and how they work.
*   **The Instance**: It is a **living copy** of that scene. The game creates these copies to use them (one copy for the player, 10 copies for bullets, etc.).

When you play, you interact with these copies.
To shoot, we need to create a **new copy** of the scene `bullet.tscn` every time you press space.

### The construction process
In GDScript, creating something new has 3 steps:
1.  **Load the Blueprint**: `preload("res://bullet.tscn")`.
2.  **Instantiate**: `blueprint.instantiate()`. You construct the object in RAM, but **it doesn't exist in the visible world yet**.
3.  **Add to Tree**: `add_child(bullet)`. Here you place the object in the game universe.

**Why `preload` and not `load`?**

Godot has two ways to load resources:
*   **`preload("path")`**: Loads the scene **when the game starts**. It is faster in execution because it is already in memory, but consumes RAM from the start.
*   **`load("path")`**: Loads the scene **on demand**, at the exact moment that line executes. Saves initial RAM, but can cause stutters (micro-stops) if the resource is heavy.

For bullets (small files that we will use constantly), `preload` is the right choice.

## 3. Implementing the Shot

### How do we ask the game?
To shoot, we need the script to take decisions. We use two new tools:
1.  **`if` (Conditional)**: "IF this happens... do this other thing".
2.  **`Input`**: In the previous chapter we used `get_vector`. Now we will use `is_action_pressed` ("Is the key held?").

But careful: `_physics_process` runs 60 times per second. If we shoot every time the key is "held", we will create a solid line of 60 bullets in a second. 

We need a **Rate Limiter** (Cooldown). A simple way is to use a "flag" variable (`can_shoot`) and a timer.

Let's see an example (that has a problem):


<CodeTabs
  items={[
    {
      label: 'player.gd',
      lang: 'gdscript',
      code: `
extends CharacterBody2D

@export var speed = 400
@export var fire_rate = 0.125 # Fast fire rate
var bullet_scene = preload("res://scenes/bullet.tscn")

var can_shoot = true
var shoot_timer = 0.0

func _physics_process(delta: float) -> void:
    # Movement
    var direction = Input.get_vector("move_left", "move_right", "move_up", "move_down")
    velocity = direction * speed
    move_and_slide()
    
    # Cooldown (Timer)
    if not can_shoot:
        shoot_timer -= delta
        if shoot_timer <= 0.0:
            can_shoot = true

    # Shot
    if Input.is_action_pressed("shoot") and can_shoot:
        shoot()

func shoot():
    can_shoot = false
    shoot_timer = fire_rate
    
    var bala = bullet_scene.instantiate()
    add_child(bala) # <--- THE ERROR (Kangaroo)`
    }
  ]}
/>

Here we have created a custom function `shoot()` to organize the code. We use `shoot_timer` to control the fire rhythm precisely and synchronized with the physics engine.

### The Problem of Hierarchy

**Test the game now (F5)!**
Move with the ship while shooting bursts. Do you notice something weird?
The bullets move with you. If you advance, the bullets follow you.

This happens because the bullet is a **child of the ship**. It inherits its movement.

The bullet will be **child of the ship**.
*   If the ship advances, the bullet advances with it (plus its own speed).
*   If the ship rotates, the bullet will rotate orbiting around the ship.

We want the bullet to be independent! Once shot, it shouldn't care what the ship does.

### The Solution: Coordinate Divorce
The bullet must be born in the **World**, not in the Ship. But we need it to be born *where the ship is*.

<CodeTabs
  items={[
    {
      label: 'player.gd',
      lang: 'gdscript',
      code: `func shoot():
    can_shoot = false
    shoot_timer = fire_rate
    
    var bala = bullet_scene.instantiate()
    # 1. Add to "Parent" (the World) FIRST
    get_parent().add_child(bala)
     
    # 2. PLACE
    bala.global_position = global_position`
    }
  ]}
/>
**Injection Breakdown:**

**1. `var bala = bullet_scene.instantiate()`**
`bullet_scene` is just the blueprint (the mold). It doesn't exist in the game. To have a real bullet, we use `.instantiate()`, which creates a tangible copy in memory ready to be used. We save this new bullet in a variable.

**2. `get_parent().add_child(bala)`**
If we used `add_child(bala)` directly, the bullet would be a child of the Ship. This would cause it to rotate and move with it (as if it were glued to the hull).
To "divorce" it, we ask for the parent of the ship (`get_parent()`, which is the World) and hand the bullet to him. Thus both live in the same universe but move independently.

**3. `bala.global_position = global_position`**
When born in the World, the bullet would appear at the origin (0,0) by default. We need to teleport it to the muzzle of the cannon.
By equating the `global_position` of the bullet with ours (or the one of `Muzzle`), we ensure it starts its trip exactly where we are in the universe.

**4. Speed and Physics**
Since our bullets go very fast (1500), we don't need to calculate complex inertia. The speed itself makes the "doppler effect" invisible. It is the advantage of Arcade games: sometimes, the brute solution is the best.

### 4. Adjusting the Output Position (Marker2D)

Right now the bullet exits from the center of the ship (its belly). It looks ugly.
To fix it, we will use an invisible node that serves as "reference".

1.  Add a child node **`Marker2D`** to your Player.
2.  Name it **`Muzzle`**.
3.  Move it visually to the tip of the cannon (or where you want bullets to exit).

Now we update the code to use this marker:

<CodeTabs
  items={[
    {
      label: 'player.gd',
      lang: 'gdscript',
      code: `func shoot():
    can_shoot = false
    shoot_timer = fire_rate
    
    var bala = bullet_scene.instantiate()
    
    get_parent().add_child(bala)
     
    # We use the position of the Muzzle
    bala.global_position = $Muzzle.global_position`
    }
  ]}
/>

### Summary and Challenges

Today you have learned one of the fundamental concepts of software development: **Instancing** (creating objects dynamically).

Let's review the key concepts:
1.  **Scenes (`.tscn`)**: They are the blueprints (molds) of your objects.
2.  **Instance**: Convert those blueprints into living objects in the game (`.instantiate()`).
3.  **Marker2D Nodes**: Invisible reference points vital for `spawns`.
4.  **Signals**: Invisible cables for objects to speak (`screen_exited`).
5.  **`queue_free()`**: The safe way to delete garbage from memory.

In the **next chapter**, we will turn this empty shooting range into a real battle. We will create **Enemies** that manage their own life and detect collisions. Prepare the ammo!
