---
pubDate: '2026-01-15T15:00:00Z'
tags: ['godot', 'gdscript', 'spawner', 'patterns', 'gamedev']
draft: false
new: true
title: 'Godot #6: El SpawnPoint - Formaciones Lineales'
description: Creamos un sistema de spawn configurable que controla el movimiento de los enemigos. Patrones LINE y WAVE con aviones.
series: gamedev-godot-basics
seriesTitle: Game Dev con Godot
seriesDescription: Aprendemos los fundamentos del desarrollo de videojuegos (vectores, trigonometría, shaders) usando Godot y un Shoot 'em Up como excusa práctica.
lang: es
---

import Callout from '../../../../components/mdx/Callout.astro';
import CodeTabs from '../../../../components/mdx/CodeTabs.astro';

## El Problema: Enemigos que Se Mandan Solos

En los capítulos anteriores, cada enemigo tenía su **propio script de movimiento**. El avión se movía recto, el helicóptero ondulaba o orbitaba. Cada uno decidía cómo moverse.

Esto funciona para demos, pero tiene un problema fundamental: **no hay coordinación**.

Si queremos crear una *oleada de 5 aviones* que entren en formación, ¿quién decide dónde van? ¿Cada avión por su cuenta? Eso es caos, no una formación.

**La solución**: Un **director de orquesta** que controle el movimiento de todos sus enemigos. En lugar de que el enemigo sepa moverse, será un nodo externo (el `SpawnPoint`) quien le diga dónde ir.

### El Cambio de Paradigma

| Antes | Después |
|-------|---------|
| Enemigo decide su movimiento | Enemigo es "tonto", solo tiene stats |
| Múltiples scripts de movimiento | Un solo `SpawnPoint` con patrones configurables |
| Movimiento hardcodeado | Movimiento inyectado desde fuera |

Este capítulo lo dedicaremos a construir ese sistema. Pero antes, necesitamos 
pulir algunas cosas.

---

## 1. Mejorando: Todos los Enemigos Flashean a la Vez

Ahora si instancias varios helicópteros y disparas a **uno solo**, todos ejecutan el efecto de `hit_flash` simultáneamente. ¿Por qué?

### La Causa: Recursos Compartidos

Cuando creas una escena en el Editor de Godot y le asignas un `ShaderMaterial` al `Sprite2D`, ese material se guarda como un **recurso único** en el archivo `.tscn`.

Al usar `enemy_scene.instantiate()`, Godot **no duplica** los recursos. Solo crea referencias al mismo archivo.

```text
enemy.tscn
   └── Sprite2D
        └── Material: ShaderMaterial (archivo único)
               ↑        ↑        ↑
          Enemigo 1  Enemigo 2  Enemigo 3
          (todos apuntan al MISMO material)
```

Cuando uno llama a `set_shader_parameter("flash_active", true)`, **cambia la variable para todos** porque es literalmente el mismo objeto en memoria.

### La Solución: Duplicar el Material

La solución es hacer una **copia independiente** del material en el `_ready()` de cada enemigo:

<CodeTabs
  items={[
    {
      label: 'enemy.gd',
      lang: 'gdscript',
      code: `func _ready():
  # Creamos una copia ÚNICA del material para ESTA instancia
  $Sprite2D.material = $Sprite2D.material.duplicate()
  
  # Resto del código...
  area_entered.connect(_on_area_entered)`
    }
  ]}
/>

**¿Qué hace `.duplicate()`?**

El método `duplicate()` crea una **copia profunda** del recurso. Ahora cada enemigo tiene su propio `ShaderMaterial` independiente:

```text
Enemigo 1 → Material Copia A (independiente)
Enemigo 2 → Material Copia B (independiente)
Enemigo 3 → Material Copia C (independiente)
```

Cuando disparas a uno, solo **su** material recibe el cambio.

<Callout type="tip" title="Alternativas más eficientes">
**`duplicate()`** es simple pero crea copias del material en memoria. Para proyectos grandes hay opciones mejores:

1. **`Resource → Local to Scene`**: Activa esta opción en el Inspector del `ShaderMaterial`. Godot duplicará automáticamente el material al instanciar, sin código extra.

2. **`instance uniform`** (Godot 4): Permite que todas las instancias compartan el mismo shader pero con valores diferentes. Lo veremos en un capítulo avanzado de optimización.

Para este curso, `duplicate()` es suficiente y más explícito didácticamente.
</Callout>

> **Aplica este cambio** a todos tus scripts de enemigos (`enemy.gd`, `enemy_wave.gd`, `enemy_orbital.gd`, etc.) añadiendo la línea de `duplicate()` al inicio de `_ready()`.

---

## 2. Mejorando: Colisiones Entre Enemigos

Si los enemigos vuelan muy cerca unos de otros, pueden chocar entre sí y destruirse. Podríamos usar grupos (`is_in_group("enemy")`) para filtrar colisiones en código, pero hay una solución mejor y más eficiente: **Collision Layers**.

### ¿Qué son las Collision Layers?

Godot tiene un sistema de **capas de colisión** que funciona como filtros. Cada objeto tiene:

- **Layer** (capa): "Yo **soy** de esta capa"
- **Mask** (máscara): "Yo **detecto** objetos de estas capas"

El evento `area_entered` **solo se dispara** si la capa del objeto entrante coincide con la máscara del objeto receptor.

<Callout type="info" title="Límite de 32 capas">
Godot usa un bitmask de 32 bits, lo que limita a **32 capas** por sistema. En la práctica es más que suficiente si usas categorías genéricas (player, enemy, bullet) en lugar de una capa por tipo específico. Si necesitas más granularidad, puedes combinar Layers con Groups.
</Callout>

### Configuración para Nuestro Juego

Vamos a definir 3 capas:

| Bit | Nombre | Quién está aquí |
|-----|--------|-----------------|
| 1 | Player | La nave del jugador |
| 2 | Enemy | Aviones, helicópteros, todos los enemigos |
| 3 | PlayerBullet | Las balas que dispara el jugador |

**Configuración de cada objeto:**

| Objeto | Layer (soy) | Mask (detecto) |
|--------|-------------|----------------|
| Player | 1 | - |
| Enemy | 2 | 3 (solo balas del player) |
| PlayerBullet | 3 | 2 (solo enemigos) |

Con esta configuración:
- Los enemigos **solo detectan** balas del player (capa 3).
- Si un enemigo toca a otro enemigo (ambos en capa 2), **no pasa nada** porque la máscara del enemigo no incluye la capa 2.
- Por ahora Player no detecta colisiones con enemigos porque por ahora es invencible, si detectásemos la colisión todavía no tendríamos nada que hacer con ella.

### Cómo Configurarlo en Godot

**Paso 1: Nombrar las capas**

1. Ve a **Project → Project Settings → Layer Names → 2D Physics**.
2. Nombra las capas:
   - Layer 1: `player`
   - Layer 2: `enemy`
   - Layer 3: `player_bullet`

**Paso 2: Configurar el Enemigo**

1. Abre tu escena de enemigo (`enemy.tscn`).
2. Selecciona el nodo raíz (`Area2D`).
3. En el Inspector, busca **Collision → Layer**.
4. Desactiva la capa 1, activa solo la **capa 2** (enemy).
5. En **Collision → Mask**, desactiva la capa 1, activa solo la **capa 3** (player_bullet).

**Paso 3: Configurar la Bala**

1. Abre tu escena de bala (`bullet.tscn`).
2. Selecciona el nodo raíz (`Area2D`).
3. **Layer**: Solo capa 3 (player_bullet).
4. **Mask**: Solo capa 2 (enemy).

> **Resultado**: Con esta configuración, la señal `area_entered` del enemigo **solo se dispara** cuando una bala del player lo toca. No necesitas verificar manualmente qué tipo de objeto colisionó; el motor ya lo filtró por ti.

Tu función `_on_area_entered` del Capítulo 3 queda limpia:

<CodeTabs
  items={[
    {
      label: 'enemy.gd',
      lang: 'gdscript',
      code: `func _on_area_entered(area):
  if is_dying:
    return
  
  # Gracias a Collision Layers, aquí solo llegan balas del player
  # El motor ya filtró las colisiones por nosotros
  
  hp -= 1
  area.queue_free()
  hit_flash()  # Definido en Capítulo 4
  
  if hp <= 0:
    die()  # Definido en Capítulo 3`
    }
  ]}
/>

---

## 3. El SpawnPoint: Estructura Base

Ahora que los enemigos están preparados, vamos a crear el `SpawnPoint`. Este será un `Node2D` que:

1. Usaremos una escena de enemigo (`PackedScene`).
2. Instanciaremos N enemigos al inicio.
3. Controlaremos su movimiento cada frame según el patrón seleccionado.

### Definiendo los Patrones con Enum

Primero, necesitamos una forma de seleccionar qué patrón usar. En GDScript, usamos un `enum`:

<CodeTabs
  items={[
    {
      label: 'Concepto: Enum',
      lang: 'gdscript',
      code: `enum MovementPattern {
  LINE,       # Fila india
  WAVE,       # Fila con ondulación
  ORBIT,      # Movimiento circular (Part 7)
  LINE_TO_ORBIT  # Transición (Part 7)
}`
    }
  ]}
/>

**¿Qué es un `enum`?**

Un `enum` (enumeración) es una forma de definir un conjunto de **constantes con nombre**. Internamente, cada valor es un número:

| Nombre | Valor Interno |
|--------|---------------|
| `LINE` | 0 |
| `WAVE` | 1 |
| `ORBIT` | 2 |
| `LINE_TO_ORBIT` | 3 |

La ventaja es que en el código escribes `MovementPattern.WAVE` en lugar de recordar qué significa el número `1`. Además, en el Inspector de Godot aparece un **desplegable** con los nombres.

Ahora vamos a construir el SpawnPoint paso a paso, empezando con el patrón más simple.

---

## 4. Patrón LINE: Fila India

El patrón más simple. Los enemigos entran en fila india (uno detrás del otro) y avanzan hacia la izquierda.

```text
← enemy_0 ← enemy_1 ← enemy_2 ← enemy_3 ← enemy_4
   (todos en línea horizontal, moviéndose a la izquierda)
```

![Patrón de movimiento LINE: fila india](public/assets/gamedev-godot-basics/line.webp)

### Script Simplificado (Solo LINE)

<CodeTabs
  items={[
    {
      label: 'spawn_point.gd (LINE)',
      lang: 'gdscript',
      code: `extends Node2D

@export var enemy_scene: PackedScene
@export var formation_size: int = 5
@export var spawn_spacing: float = 150.0
@export var speed: float = 150.0

var enemies: Array = []

func _ready():
    spawn_formation()

func spawn_formation():
    for i in range(formation_size):
      var enemy = enemy_scene.instantiate()

      # Fila india: el primero en X=0, los demás detrás
      enemy.position = Vector2(i * spawn_spacing, 0)

      enemies.append(enemy)
      call_deferred("add_child", enemy)

func _process(delta):
    for enemy in enemies:
      if is_instance_valid(enemy):
        enemy.position.x -= speed * delta`
    }
  ]}
/>

**¿Qué hace `spawn_formation()`?**

1. `enemy_scene.instantiate()` — Crea una copia del enemigo.
2. `enemy.position = Vector2(i * spawn_spacing, 0)` — Lo posiciona en fila india.
3. `enemies.append(enemy)` — Lo guarda en el array para poder accederlo después en `_process()`.
4. `call_deferred("add_child", enemy)` — Lo añade como hijo del SpawnPoint (de forma segura).

### Probando el Patrón LINE

1. Crea un nuevo `Node2D` en tu escena `world.tscn`.
2. Renómbralo a `SpawnPoint`.
3. Añádele el script `spawn_point.gd`.
4. En el Inspector:
   - **Enemy Scene**: Arrastra `enemy.tscn` (el avión).
   - **Formation Size**: `5`.
   - **Spawn Spacing**: `60`.
   - **Speed**: `150`.
5. Posiciona el `SpawnPoint` a la derecha de la pantalla (ej: X=1200, Y=300).
6. Ejecuta (F5).

**Resultado esperado**: 5 aviones en fila india avanzan hacia la izquierda.

---

## 5. Patrón WAVE: La Serpiente

Ahora queremos que la fila india **ondule** verticalmente mientras avanza. El truco es que cada enemigo debe seguir **exactamente la misma ruta** que el que tiene delante, como los segmentos de una serpiente.

![Patrón de movimiento WAVE: serpiente](public/assets/gamedev-godot-basics/wave.webp)

### El Secreto: Ondulación Basada en Posición X

La clave es que la posición Y se calcula a partir de la posición X:

Como todos los enemigos pasan por las mismas coordenadas X (solo que en momentos diferentes), todos siguen exactamente la misma curva.

### Script Completo (LINE + WAVE)

<CodeTabs
  items={[
    {
      label: 'spawn_point.gd',
      lang: 'gdscript',
      code: `
extends Node2D

enum MovementPattern { LINE, WAVE }

@export var enemy_scene: PackedScene
@export var pattern: MovementPattern = MovementPattern.LINE
@export var formation_size: int = 5
@export var spawn_spacing: float = 60.0
@export var speed: float = 150.0

# Parámetros WAVE
@export var wave_amplitude: float = 80.0
@export var wave_frequency: float = 0.02

var enemies: Array = []

func _ready():
    spawn_formation()

func spawn_formation():
    for i in range(formation_size):
      var enemy = enemy_scene.instantiate()
      enemy.position = Vector2(i * spawn_spacing, 0)
      enemies.append(enemy)
      call_deferred("add_child", enemy)

func _process(delta):
    for enemy in enemies:
      if not is_instance_valid(enemy):
        continue
      
      match pattern:
        MovementPattern.LINE:
          move_line(enemy, delta)
        MovementPattern.WAVE:
          move_wave(enemy, delta)

func move_line(enemy: Node2D, delta: float):
    enemy.position.x -= speed * delta

func move_wave(enemy: Node2D, delta: float):
    enemy.position.x -= speed * delta
    enemy.position.y = sin(enemy.position.x * wave_frequency) * wave_amplitude`
    }
  ]}
/>

### Explicación del Código

Fíjate que aquí cambiamos el estilo del `if`: en LINE usamos `if is_instance_valid(enemy):` y anidamos el código dentro. Aquí usamos `if not ... continue` para saltar los enemigos eliminados. Ambos hacen lo mismo, pero este estilo evita anidación extra con el `match`.

**`move_line()`** hace exactamente lo mismo que en el script de LINE: mover al enemigo hacia la izquierda.

<CodeTabs
  items={[
    {
      label: 'move_line',
      lang: 'gdscript',
      code: `
func move_line(enemy: Node2D, delta: float):
    enemy.position.x -= speed * delta`
    }
  ]}
/>

**`move_wave()`** añade una línea extra: además de avanzar hacia la izquierda, calcula la posición Y usando `sin()`.

<CodeTabs
  items={[
    {
      label: 'move_wave',
      lang: 'gdscript',
      code: `
func move_wave(enemy: Node2D, delta: float):
    enemy.position.x -= speed * delta
    enemy.position.y = sin(enemy.position.x * wave_frequency) * wave_amplitude`
    }
  ]}
/>

- `enemy.position.x * wave_frequency`: Convierte la posición X en un ángulo para `sin()`.
- `wave_amplitude`: Escala el resultado (de -1 a 1) a píxeles.

La Y se **reasigna** cada frame, no se acumula. Por eso no hay problema de "volar al infinito".

### Probando el Patrón WAVE

1. Cambia el `Pattern` a `WAVE` en el Inspector.
2. Configura:
    - **Formation Size**: `8`
    - **Spawn Spacing**: `120`
    - **Speed**: `50`
    - **Wave Amplitude**: `150`
    - **Wave Frequency**: `0.01`
3. Ejecuta (F5).

**Resultado**: Los helicópteros avanzan ondulando arriba y abajo.

**Experimenta:**
- `wave_frequency = 0.01`: Ondas largas.
- `wave_frequency = 0.05`: Ondas cortas.
- `wave_amplitude = 150`: Ondas altas.
---

## Repasemos lo aprendido

1. **Mejora del Shader**: Los recursos se comparten entre instancias. Solución: `material.duplicate()`.
2. **Mejora de la colisión**: Filtrar colisiones a nivel de motor es más eficiente que hacerlo en código.
3. **SpawnPoint**: Un nodo que controla el spawn y movimiento de sus enemigos.
4. **Enum**: Constantes con nombre para seleccionar opciones en el Inspector.
5. **Patrón LINE**: Fila india avanzando con `position.x -= speed * delta`.
6. **Patrón WAVE**: Ondulación basada en posición X: `position.y = sin(position.x * freq) * amp`. Todos siguen la misma curva.

En el **próximo capítulo**, añadiremos el patrón **ORBIT** (helicópteros girando) y **LINE_TO_ORBIT** (transición de fila a órbita).

