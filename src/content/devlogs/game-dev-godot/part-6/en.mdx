---
pubDate: '2026-01-15T15:00:00Z'
tags: ['godot', 'gdscript', 'spawner', 'patterns', 'gamedev']
draft: false
new: true
title: 'Godot #6: The SpawnPoint - Linear Formations'
description: We create a configurable spawn system that controls enemy movement. LINE and WAVE patterns with planes.
series: gamedev-godot-basics
seriesTitle: Game Dev with Godot
seriesDescription: We learn the fundamentals of game development (vectors, trigonometry, shaders) using Godot and a Shoot 'em Up as a practical excuse.
lang: en
---

import Callout from '../../../../components/mdx/Callout.astro';
import CodeTabs from '../../../../components/mdx/CodeTabs.astro';

## The Problem: Enemies That Control Themselves

In previous chapters, each enemy had its **own movement script**. The plane moved straight, the helicopter waved or orbited. Each one decided how to move.

This works for demos, but has a fundamental problem: **there's no coordination**.

If we want to create a *wave of 5 planes* entering in formation, who decides where they go? Each plane on its own? That's chaos, not a formation.

**The solution**: An **orchestra conductor** that controls the movement of all its enemies. Instead of the enemy knowing how to move, an external node (the `SpawnPoint`) will tell it where to go.

### The Paradigm Shift

| Before | After |
|--------|-------|
| Enemy decides its movement | Enemy is "dumb", only has stats |
| Multiple movement scripts | A single `SpawnPoint` with configurable patterns |
| Hardcoded movement | Movement injected from outside |

This chapter we'll dedicate to building that system. But first, we need to polish some things.

---

## 1. Improving: All Enemies Flash at Once

Now if you instantiate several helicopters and shoot **just one**, they all execute the `hit_flash` effect simultaneously. Why?

### The Cause: Shared Resources

When you create a scene in the Godot Editor and assign a `ShaderMaterial` to the `Sprite2D`, that material is saved as a **unique resource** in the `.tscn` file.

When using `enemy_scene.instantiate()`, Godot **doesn't duplicate** the resources. It only creates references to the same file.

```text
enemy.tscn
   └── Sprite2D
        └── Material: ShaderMaterial (unique file)
               ↑        ↑        ↑
          Enemy 1    Enemy 2    Enemy 3
          (all point to the SAME material)
```

When one calls `set_shader_parameter("flash_active", true)`, it **changes the variable for all** because it's literally the same object in memory.

### The Solution: Duplicate the Material

The solution is to make an **independent copy** of the material in each enemy's `_ready()`:

<CodeTabs
  items={[
    {
      label: 'enemy.gd',
      lang: 'gdscript',
      code: `func _ready():
  # We create a UNIQUE copy of the material for THIS instance
  $Sprite2D.material = $Sprite2D.material.duplicate()
  
  # Rest of the code...
  area_entered.connect(_on_area_entered)`
    }
  ]}
/>

**What does `.duplicate()` do?**

The `duplicate()` method creates a **deep copy** of the resource. Now each enemy has its own independent `ShaderMaterial`:

```text
Enemy 1 → Material Copy A (independent)
Enemy 2 → Material Copy B (independent)
Enemy 3 → Material Copy C (independent)
```

When you shoot one, only **its** material receives the change.

<Callout type="tip" title="More efficient alternatives">
**`duplicate()`** is simple but creates copies of the material in memory. For large projects there are better options:

1. **`Resource → Local to Scene`**: Enable this option in the `ShaderMaterial` Inspector. Godot will automatically duplicate the material when instantiating, without extra code.

2. **`instance uniform`** (Godot 4): Allows all instances to share the same shader but with different values. We'll see this in an advanced optimization chapter.

For this course, `duplicate()` is sufficient and more explicitly didactic.
</Callout>

> **Apply this change** to all your enemy scripts (`enemy.gd`, `enemy_wave.gd`, `enemy_orbital.gd`, etc.) by adding the `duplicate()` line at the start of `_ready()`.

---

## 2. Improving: Collisions Between Enemies

If enemies fly very close to each other, they can collide and destroy each other. We could use groups (`is_in_group("enemy")`) to filter collisions in code, but there's a better and more efficient solution: **Collision Layers**.

### What are Collision Layers?

Godot has a **collision layer** system that works like filters. Each object has:

- **Layer**: "I **am** in this layer"
- **Mask**: "I **detect** objects from these layers"

The `area_entered` event **only fires** if the entering object's layer matches the receiver object's mask.

<Callout type="info" title="32 layer limit">
Godot uses a 32-bit bitmask, which limits to **32 layers** per system. In practice this is more than enough if you use generic categories (player, enemy, bullet) instead of one layer per specific type. If you need more granularity, you can combine Layers with Groups.
</Callout>

### Configuration for Our Game

We'll define 3 layers:

| Bit | Name | Who's here |
|-----|------|------------|
| 1 | Player | The player's ship |
| 2 | Enemy | Planes, helicopters, all enemies |
| 3 | PlayerBullet | Bullets fired by the player |

**Configuration for each object:**

| Object | Layer (I am) | Mask (I detect) |
|--------|--------------|-----------------|
| Player | 1 | - |
| Enemy | 2 | 3 (only player bullets) |
| PlayerBullet | 3 | 2 (only enemies) |

With this configuration:
- Enemies **only detect** player bullets (layer 3).
- If an enemy touches another enemy (both in layer 2), **nothing happens** because the enemy's mask doesn't include layer 2.
- For now Player doesn't detect collisions with enemies because for now it's invincible, if we detected the collision we wouldn't have anything to do with it yet.

### How to Configure It in Godot

**Step 1: Name the layers**

1. Go to **Project → Project Settings → Layer Names → 2D Physics**.
2. Name the layers:
   - Layer 1: `player`
   - Layer 2: `enemy`
   - Layer 3: `player_bullet`

**Step 2: Configure the Enemy**

1. Open your enemy scene (`enemy.tscn`).
2. Select the root node (`Area2D`).
3. In the Inspector, look for **Collision → Layer**.
4. Disable layer 1, enable only **layer 2** (enemy).
5. In **Collision → Mask**, disable layer 1, enable only **layer 3** (player_bullet).

**Step 3: Configure the Bullet**

1. Open your bullet scene (`bullet.tscn`).
2. Select the root node (`Area2D`).
3. **Layer**: Only layer 3 (player_bullet).
4. **Mask**: Only layer 2 (enemy).

> **Result**: With this configuration, the enemy's `area_entered` signal **only fires** when a player bullet touches it. You don't need to manually check what type of object collided; the engine already filtered it for you.

Your `_on_area_entered` function from Chapter 3 stays clean:

<CodeTabs
  items={[
    {
      label: 'enemy.gd',
      lang: 'gdscript',
      code: `func _on_area_entered(area):
  if is_dying:
    return
  
  # Thanks to Collision Layers, only player bullets arrive here
  # The engine already filtered collisions for us
  
  hp -= 1
  area.queue_free()
  hit_flash()  # Defined in Chapter 4
  
  if hp <= 0:
    die()  # Defined in Chapter 3`
    }
  ]}
/>

---

## 3. The SpawnPoint: Base Structure

Now that the enemies are ready, let's create the `SpawnPoint`. This will be a `Node2D` that:

1. We'll use an enemy scene (`PackedScene`).
2. We'll instantiate N enemies at start.
3. We'll control their movement each frame according to the selected pattern.

### Defining Patterns with Enum

First, we need a way to select which pattern to use. In GDScript, we use an `enum`:

<CodeTabs
  items={[
    {
      label: 'Concept: Enum',
      lang: 'gdscript',
      code: `enum MovementPattern {
  LINE,       # Single file
  WAVE,       # File with wave
  ORBIT,      # Circular movement (Part 7)
  LINE_TO_ORBIT  # Transition (Part 7)
}`
    }
  ]}
/>

**What is an `enum`?**

An `enum` (enumeration) is a way to define a set of **named constants**. Internally, each value is a number:

| Name | Internal Value |
|------|----------------|
| `LINE` | 0 |
| `WAVE` | 1 |
| `ORBIT` | 2 |
| `LINE_TO_ORBIT` | 3 |

The advantage is that in code you write `MovementPattern.WAVE` instead of remembering what number `1` means. Plus, in Godot's Inspector a **dropdown** appears with the names.

Now let's build the SpawnPoint step by step, starting with the simplest pattern.

---

## 4. LINE Pattern: Single File

The simplest pattern. Enemies enter in single file (one behind the other) and advance to the left.

```text
← enemy_0 ← enemy_1 ← enemy_2 ← enemy_3 ← enemy_4
   (all in horizontal line, moving to the left)
```

![LINE movement pattern: single file](public/assets/gamedev-godot-basics/line.webp)

### Simplified Script (LINE Only)

<CodeTabs
  items={[
    {
      label: 'spawn_point.gd (LINE)',
      lang: 'gdscript',
      code: `extends Node2D

@export var enemy_scene: PackedScene
@export var formation_size: int = 5
@export var spawn_spacing: float = 150.0
@export var speed: float = 150.0

var enemies: Array = []

func _ready():
    spawn_formation()

func spawn_formation():
    for i in range(formation_size):
      var enemy = enemy_scene.instantiate()

      # Single file: the first at X=0, the others behind
      enemy.position = Vector2(i * spawn_spacing, 0)

      enemies.append(enemy)
      call_deferred("add_child", enemy)

func _process(delta):
    for enemy in enemies:
      if is_instance_valid(enemy):
        enemy.position.x -= speed * delta`
    }
  ]}
/>

**What does `spawn_formation()` do?**

1. `enemy_scene.instantiate()` — Creates a copy of the enemy.
2. `enemy.position = Vector2(i * spawn_spacing, 0)` — Positions it in single file.
3. `enemies.append(enemy)` — Stores it in the array to access it later in `_process()`.
4. `call_deferred("add_child", enemy)` — Adds it as a child of SpawnPoint (safely).

### Testing the LINE Pattern

1. Create a new `Node2D` in your `world.tscn` scene.
2. Rename it to `SpawnPoint`.
3. Add the `spawn_point.gd` script to it.
4. In the Inspector:
   - **Enemy Scene**: Drag `enemy.tscn` (the plane).
   - **Formation Size**: `5`.
   - **Spawn Spacing**: `60`.
   - **Speed**: `150`.
5. Position the `SpawnPoint` on the right side of the screen (e.g.: X=1200, Y=300).
6. Run (F5).

**Expected result**: 5 planes in single file advance to the left.

---

## 5. WAVE Pattern: The Snake

Now we want the single file to **wave** vertically while advancing. The trick is that each enemy must follow **exactly the same path** as the one in front, like the segments of a snake.

![WAVE movement pattern: snake](public/assets/gamedev-godot-basics/wave.webp)

### The Secret: Wave Based on X Position

The key is that the Y position is calculated from the X position:

Since all enemies pass through the same X coordinates (just at different times), they all follow exactly the same curve.

### Complete Script (LINE + WAVE)

<CodeTabs
  items={[
    {
      label: 'spawn_point.gd',
      lang: 'gdscript',
      code: `
extends Node2D

enum MovementPattern { LINE, WAVE }

@export var enemy_scene: PackedScene
@export var pattern: MovementPattern = MovementPattern.LINE
@export var formation_size: int = 5
@export var spawn_spacing: float = 60.0
@export var speed: float = 150.0

# WAVE Parameters
@export var wave_amplitude: float = 80.0
@export var wave_frequency: float = 0.02

var enemies: Array = []

func _ready():
    spawn_formation()

func spawn_formation():
    for i in range(formation_size):
      var enemy = enemy_scene.instantiate()
      enemy.position = Vector2(i * spawn_spacing, 0)
      enemies.append(enemy)
      call_deferred("add_child", enemy)

func _process(delta):
    for enemy in enemies:
      if not is_instance_valid(enemy):
        continue
      
      match pattern:
        MovementPattern.LINE:
          move_line(enemy, delta)
        MovementPattern.WAVE:
          move_wave(enemy, delta)

func move_line(enemy: Node2D, delta: float):
    enemy.position.x -= speed * delta

func move_wave(enemy: Node2D, delta: float):
    enemy.position.x -= speed * delta
    enemy.position.y = sin(enemy.position.x * wave_frequency) * wave_amplitude`
    }
  ]}
/>

### Code Explanation

Notice that here we change the `if` style: in LINE we use `if is_instance_valid(enemy):` and nest the code inside. Here we use `if not ... continue` to skip deleted enemies. Both do the same thing, but this style avoids extra nesting with the `match`.

**`move_line()`** does exactly the same as in the LINE script: move the enemy to the left.

<CodeTabs
  items={[
    {
      label: 'move_line',
      lang: 'gdscript',
      code: `
func move_line(enemy: Node2D, delta: float):
    enemy.position.x -= speed * delta`
    }
  ]}
/>

**`move_wave()`** adds an extra line: besides advancing to the left, it calculates the Y position using `sin()`.

<CodeTabs
  items={[
    {
      label: 'move_wave',
      lang: 'gdscript',
      code: `
func move_wave(enemy: Node2D, delta: float):
    enemy.position.x -= speed * delta
    enemy.position.y = sin(enemy.position.x * wave_frequency) * wave_amplitude`
    }
  ]}
/>

- `enemy.position.x * wave_frequency`: Converts the X position into an angle for `sin()`.
- `wave_amplitude`: Scales the result (from -1 to 1) to pixels.

The Y is **reassigned** each frame, not accumulated. That's why there's no "flying to infinity" problem.

### Testing the WAVE Pattern

1. Change the `Pattern` to `WAVE` in the Inspector.
2. Configure:
    - **Formation Size**: `8`
    - **Spawn Spacing**: `120`
    - **Speed**: `50`
    - **Wave Amplitude**: `150`
    - **Wave Frequency**: `0.01`
3. Run (F5).

**Result**: The helicopters advance waving up and down.

**Experiment:**
- `wave_frequency = 0.01`: Long waves.
- `wave_frequency = 0.05`: Short waves.
- `wave_amplitude = 150`: Tall waves.
---

## Let's Review What We Learned

1. **Shader Improvement**: Resources are shared between instances. Solution: `material.duplicate()`.
2. **Collision Improvement**: Filtering collisions at engine level is more efficient than doing it in code.
3. **SpawnPoint**: A node that controls the spawn and movement of its enemies.
4. **Enum**: Named constants to select options in the Inspector.
5. **LINE Pattern**: Single file advancing with `position.x -= speed * delta`.
6. **WAVE Pattern**: Wave based on X position: `position.y = sin(position.x * freq) * amp`. All follow the same curve.

In the **next chapter**, we'll add the **ORBIT** pattern (helicopters spinning) and **LINE_TO_ORBIT** (transition from file to orbit).
