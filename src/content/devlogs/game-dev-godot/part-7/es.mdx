---
pubDate: '2026-01-16T15:00:00Z'
tags: ['godot', 'gdscript', 'spawner', 'patterns', 'gamedev']
draft: true
new: true
title: 'Godot #7: El SpawnPoint - Formaciones Orbitales'
description: Helicópteros que orbitan y transiciones de fila a círculo. Completamos el sistema de spawn con patrones ORBIT y LINE_TO_ORBIT.
series: gamedev-godot-basics
seriesTitle: Game Dev con Godot
seriesDescription: Aprendemos los fundamentos del desarrollo de videojuegos (vectores, trigonometría, shaders) usando Godot y un Shoot 'em Up como excusa práctica.
lang: es
---

import Callout from '../../../../components/mdx/Callout.astro';
import CodeTabs from '../../../../components/mdx/CodeTabs.astro';

## Continuamos con el SpawnPoint

En el capítulo anterior construimos el sistema `SpawnPoint` con dos patrones:
- **LINE**: Enemigos en fila india.
- **WAVE**: Fila con ondulación (efecto serpiente).

Ahora añadiremos dos patrones más complejos:
- **ORBIT**: Enemigos girando alrededor del SpawnPoint.
- **LINE_TO_ORBIT**: Enemigos que entran en fila y transicionan a órbita.

Pero antes de añadirlos, necesitamos mejorar la arquitectura del código que escribimos en el capítulo anterior.

---

## 1. Refactorización: Datos por Enemigo

### El Problema

En el capítulo 6, WAVE calculaba la ondulación usando la posición X del enemigo:

```gdscript
# Cap 6: WAVE original
enemy.position.y = sin(enemy.position.x * wave_frequency) * wave_amplitude
```

Esto funcionaba, pero tiene una limitación: **si el enemigo deja de avanzar, la onda se congela** (porque `position.x` no cambia).

Para ORBIT, cada enemigo necesita empezar en un **punto diferente** del círculo. Si 4 helicópteros orbitan, queremos que estén distribuidos como las horas de un reloj: uno a las 3, otro a las 12, otro a las 9, otro a las 6.

| Enemigo | Posición inicial |
|---------|------------------|
| 0 | Derecha (3:00) |
| 1 | Arriba (12:00) |
| 2 | Izquierda (9:00) |
| 3 | Abajo (6:00) |

Esto significa que cada enemigo tiene un **ángulo inicial diferente** que llamamos `phase_offset`. Este valor se calcula **una sola vez** al nacer y debe recordarse para siempre.

### La Solución: `enemy_data`

El enemigo es "tonto" – solo sabe recibir daño y morir. No tiene una variable `phase_offset`. Toda la lógica de movimiento vive en el SpawnPoint.

La solución: un **array paralelo** que guarde datos únicos de cada enemigo.

<CodeTabs
  items={[
    {
      label: 'spawn_point.gd (añadir a las variables)',
      lang: 'gdscript',
      code: `
var enemies: Array = []       # Las instancias de los nodos (ya existía)
var enemy_data: Array = []    # (nuevo) diccionarios con datos únicos de cada enemigo
var time: float = 0.0         # (nuevo) acumulador de tiempo`
    }
  ]}
/>

Ahora tenemos dos arrays que funcionan en paralelo:
- `enemies[2]` → El nodo del tercer enemigo
- `enemy_data[2]` → El diccionario con sus datos (desfases, distancias, etc.)

### Actualizando `spawn_formation()`

Ahora cada enemigo crea un diccionario `data` que se guarda en `enemy_data`:

<CodeTabs
  items={[
    {
      label: 'spawn_point.gd (reemplazar spawn_formation)',
      lang: 'gdscript',
      code: `
func spawn_formation():
    var perpendicular = Vector2(-direction.y, direction.x)
    
    for i in range(formation_size):
        var enemy = enemy_scene.instantiate()
        var data = {}
        
        match pattern:
            MovementPattern.LINE:
                var formation_offset = (i - (formation_size - 1) / 2.0) * spawn_spacing
                enemy.position = perpendicular * formation_offset
            
            MovementPattern.WAVE:
                var formation_offset = (i - (formation_size - 1) / 2.0) * spawn_spacing
                enemy.position = perpendicular * formation_offset
                data["start_perpendicular_offset"] = formation_offset  # Guardar posición inicial
                data["distance"] = 0.0                                 # Distancia recorrida
        
        enemy_data.append(data)
        enemies.append(enemy)
        call_deferred("add_child", enemy)`
    }
  ]}
/>

**¿Qué es `perpendicular`?**

Si los enemigos avanzan hacia la izquierda (`direction = (-1, 0)`), querremos que la fila sea vertical (uno encima del otro).

El vector perpendicular se calcula intercambiando X e Y y negando uno:
- `direction = (-1, 0)` → `perpendicular = (0, -1)` → fila vertical

**¿Por qué `(i - (formation_size - 1) / 2.0)`?**

Esto centra la formación. Con 5 enemigos:
```text
i=0: (0 - 2) = -2  → arriba
i=1: (1 - 2) = -1
i=2: (2 - 2) =  0  → centro
i=3: (3 - 2) = +1
i=4: (4 - 2) = +2  → abajo
```

### Actualizando `move_wave()`

Ahora que tenemos `time` y `phase_offset`, WAVE puede usar ondulación basada en tiempo (no se congela):

<CodeTabs
  items={[
    {
      label: 'spawn_point.gd (reemplazar move_wave)',
      lang: 'gdscript',
      code: `
func move_wave(enemy: Node2D, index: int, delta: float):
    var data = enemy_data[index]
    
    # Acumulamos la distancia recorrida
    data.distance += speed * delta
    
    # Posición base: avance en la dirección de movimiento
    var base_position = direction * data.distance
    
    # Ondulación basada en tiempo + desfase
    var phase = time * wave_frequency + index * phase_increment
    var wave_offset = sin(phase) * wave_amplitude
    
    # Sumamos el offset inicial de formación + la ondulación
    var total_perpendicular = data.start_perpendicular_offset + wave_offset
    
    # Aplicamos todo
    var perpendicular = Vector2(-direction.y, direction.x)
    enemy.position = base_position + perpendicular * total_perpendicular`
    }
  ]}
/>

**Desglose:**

**1. `data.distance += speed * delta`**

Acumulamos cuántos píxeles ha recorrido este enemigo desde que nació. Esto reemplaza la multiplicación directa `position += direction * speed * delta` porque necesitamos la distancia para calcular la posición base.

**2. `var base_position = direction * data.distance`**

La posición "de avance" puro, sin ondulación. Si `distance = 300` y `direction = (-1, 0)`, entonces `base_position = (-300, 0)`.

**3. `var phase = time * wave_frequency + index * phase_increment`**

| Componente | Qué representa |
|------------|----------------|
| `time * wave_frequency` | Cuántas oscilaciones han pasado |
| `index * phase_increment` | Desfase según posición en la formación |

Con `phase_increment = 0.4` y 4 enemigos, cada uno está desfasado 0.4 radianes respecto al anterior. Esto crea el efecto serpiente.

**4. `data.start_perpendicular_offset + wave_offset`**

Sumamos dos cosas:
- `start_perpendicular_offset`: Dónde estaba este enemigo en la fila inicial (para mantener separación)
- `wave_offset`: La ondulación actual calculada con `sin(phase)`

**5. `enemy.position = base_position + perpendicular * total_perpendicular`**

Combinamos el avance horizontal con la posición vertical (que incluye formación + ondulación).

### Actualizando `move_line()`

Para consistencia, `move_line` también recibe `index` aunque no use `enemy_data` actualmente:

<CodeTabs
  items={[
    {
      label: 'spawn_point.gd (reemplazar move_line)',
      lang: 'gdscript',
      code: `
func move_line(enemy: Node2D, index: int, delta: float):
    enemy.position += direction * speed * delta`
    }
  ]}
/>

Añadimos `index` por uniformidad. Si en el futuro LINE necesita datos por enemigo, ya tenemos la infraestructura.

### Actualizando `_process()`

Añadimos `time` y pasamos `index` a las funciones:

<CodeTabs
  items={[
    {
      label: 'spawn_point.gd (reemplazar _process)',
      lang: 'gdscript',
      code: `
func _process(delta):
    time += delta
    
    for i in range(enemies.size()):
        var enemy = enemies[i]
        
        if not is_instance_valid(enemy):
            continue
        
        match pattern:
            MovementPattern.LINE:
                move_line(enemy, i, delta)
            MovementPattern.WAVE:
                move_wave(enemy, i, delta)`
    }
  ]}
/>

**¿Por qué `time += delta`?**

Acumulamos el tiempo transcurrido en segundos. Esto nos da un "reloj" que avanza igual independientemente de los FPS.

---

## 2. Patrón ORBIT: Movimiento Circular

Ahora que tenemos `enemy_data`, añadir ORBIT es sencillo.

### Añadiendo el Patrón y sus Parámetros

<CodeTabs
  items={[
    {
      label: 'spawn_point.gd (modificar enum y añadir exports)',
      lang: 'gdscript',
      code: `
enum MovementPattern { LINE, WAVE, ORBIT }

# --- Parámetros de Órbita (ORBIT) ---
@export var orbit_radius_x: float = 100.0   # Radio horizontal
@export var orbit_radius_y: float = 100.0   # Radio vertical (si diferente = elipse)
@export var orbit_speed: float = 2.0        # Velocidad angular (radianes/segundo)
@export var auto_distribute: bool = true    # Distribuir equidistantes en el círculo`
    }
  ]}
/>

**¿Por qué dos radios?**

Si `orbit_radius_x == orbit_radius_y`, los enemigos describen un **círculo perfecto**.
Si son diferentes, describen una **elipse**. Esto nos da flexibilidad sin necesidad de un patrón separado.

### Calculando el `phase_offset`

Un círculo completo son **2π radianes** (≈ 6.28). Si queremos distribuir `N` enemigos equidistantes, dividimos el círculo entre `N`:

```text
phase_offset = (2π / N) * índice_del_enemigo

Con 4 enemigos:
2π / 4 = π/2 = 90°

Enemigo 0: (π/2) × 0 = 0      → 0° (derecha)
Enemigo 1: (π/2) × 1 = π/2    → 90° (arriba)
Enemigo 2: (π/2) × 2 = π      → 180° (izquierda)
Enemigo 3: (π/2) × 3 = 3π/2   → 270° (abajo)
```

### La Función `move_orbit()`

<CodeTabs
  items={[
    {
      label: 'spawn_point.gd (añadir función)',
      lang: 'gdscript',
      code: `
func move_orbit(enemy: Node2D, index: int):
    var data = enemy_data[index]
    
    var angle = time * orbit_speed + data.phase_offset
    
    var x = cos(angle) * orbit_radius_x
    var y = sin(angle) * orbit_radius_y
    
    enemy.position = Vector2(x, y)`
    }
  ]}
/>

**Desglose línea a línea:**

**1. `var data = enemy_data[index]`**

Recuperamos el diccionario de datos de este enemigo. Contiene `phase_offset`: su ángulo inicial en el círculo.

**2. `var angle = time * orbit_speed + data.phase_offset`**

| Componente | Qué representa | Ejemplo |
|------------|----------------|---------|
| `time` | Segundos desde que empezó | 2.5s |
| `orbit_speed` | Radianes por segundo | 2.0 rad/s |
| `time * orbit_speed` | Cuánto ha girado en total | 5.0 rad |
| `data.phase_offset` | Dónde empezó este enemigo | π/2 (90°) |
| **Total** | Ángulo actual | 5.0 + 1.57 = 6.57 rad |

Todos los enemigos giran con `time`, pero cada uno está **desplazado** por su `phase_offset`. Por eso siguen separados aunque usen la misma fórmula.

**3. `var x = cos(angle) * orbit_radius_x`**

El **coseno** de un ángulo nos da la coordenada X en un círculo unitario (radio 1). Multiplicamos por el radio real para escalar.

| Ángulo | cos(ángulo) | Con radio 100 |
|--------|-------------|---------------|
| 0° | 1 | 100 (derecha) |
| 90° | 0 | 0 |
| 180° | -1 | -100 (izquierda) |
| 270° | 0 | 0 |

**4. `var y = sin(angle) * orbit_radius_y`**

El **seno** hace lo mismo pero para la coordenada Y.

| Ángulo | sin(ángulo) | Con radio 100 |
|--------|-------------|---------------|
| 0° | 0 | 0 |
| 90° | 1 | 100 (arriba) |
| 180° | 0 | 0 |
| 270° | -1 | -100 (abajo) |

Si `orbit_radius_x ≠ orbit_radius_y`, el resultado es una **elipse** en vez de un círculo.

**5. `enemy.position = Vector2(x, y)`**

Asignamos la posición calculada. Como el enemigo es **hijo** del SpawnPoint, esta posición es **relativa al padre**. Godot convierte automáticamente a coordenadas globales al renderizar.


### Actualizando `spawn_formation()` para ORBIT

Añadimos el caso ORBIT:

<CodeTabs
  items={[
    {
      label: 'spawn_point.gd (añadir caso ORBIT a spawn_formation)',
      lang: 'gdscript',
      code: `
        match pattern:
            MovementPattern.LINE:
                var formation_offset = (i - (formation_size - 1) / 2.0) * spawn_spacing
                enemy.position = perpendicular * formation_offset
            
            MovementPattern.WAVE:
                var formation_offset = (i - (formation_size - 1) / 2.0) * spawn_spacing
                enemy.position = perpendicular * formation_offset
                data["phase_offset"] = i * phase_increment
            
            MovementPattern.ORBIT:
                # Distribuir equidistantes en el círculo
                if auto_distribute:
                    data["phase_offset"] = (2 * PI / formation_size) * i
                else:
                    data["phase_offset"] = i * phase_increment
                
                # Posición inicial en el círculo
                var angle = data["phase_offset"]
                enemy.position = Vector2(
                    cos(angle) * orbit_radius_x,
                    sin(angle) * orbit_radius_y
                )`
    }
  ]}
/>

**Desglose del caso ORBIT:**

**1. `data["phase_offset"] = (2 * PI / formation_size) * i`**

Calculamos el ángulo inicial de cada enemigo. `PI` es una constante global de GDScript que vale 3.14159...

- `2 * PI` = 6.28 radianes = 360° (un círculo completo)
- Dividimos entre `formation_size` para obtener la separación entre enemigos
- Multiplicamos por `i` para que cada enemigo tenga su propio ángulo

**2. Posición inicial**

Usamos la misma fórmula que `move_orbit()`:
- `cos(angle) * radius_x` para X
- `sin(angle) * radius_y` para Y

Esto coloca al enemigo en su punto correcto del círculo desde el primer frame.

### Actualizando `_process()` para ORBIT

<CodeTabs
  items={[
    {
      label: 'spawn_point.gd (añadir caso ORBIT a _process)',
      lang: 'gdscript',
      code: `
func _process(delta):
    time += delta
    
    for i in range(enemies.size()):
        var enemy = enemies[i]
        
        if not is_instance_valid(enemy):
            continue
        
        match pattern:
            MovementPattern.LINE:
                move_line(enemy, i, delta)
            MovementPattern.WAVE:
                move_wave(enemy, i, delta)
            MovementPattern.ORBIT:
                move_orbit(enemy, i)`
    }
  ]}
/>

Nota que `move_orbit()` no necesita `delta` porque calcula la posición absoluta basándose en `time`, no un desplazamiento incremental.

### Probando el Patrón ORBIT

1. Crea un nuevo `SpawnPoint` en `world.tscn`.
2. En el Inspector:
   - **Enemy Scene**: Arrastra la escena del helicóptero.
   - **Pattern**: `ORBIT`.
   - **Formation Size**: `4`.
   - **Orbit Radius X**: `100`.
   - **Orbit Radius Y**: `100`.
   - **Orbit Speed**: `2`.
   - **Auto Distribute**: `true`.
3. Posiciona el SpawnPoint en el centro de la pantalla.
4. Ejecuta (F5).

**Resultado esperado**: 4 helicópteros girando en círculo, equidistantes como las horas de un reloj.

### Variación: Elipse

Cambia los radios:
- `Orbit Radius X = 150`, `Orbit Radius Y = 50` → Elipse horizontal (achatada).
- `Orbit Radius X = 50`, `Orbit Radius Y = 150` → Elipse vertical (alargada).

---

## 3. Patrón LINE_TO_ORBIT: La Transición

Este es el patrón más complejo. Los enemigos:
1. Entran en **fila** (como LINE).
2. Al llegar a una posición X determinada, **transicionan** a órbita.

### Estados del SpawnPoint

Necesitamos un **estado interno** que indique en qué fase estamos:

<CodeTabs
  items={[
    {
      label: 'spawn_point.gd (añadir)',
      lang: 'gdscript',
      code: `enum SpawnState { ENTERING, ORBITING }

var state: SpawnState = SpawnState.ENTERING

# Parámetro de transición
@export var transition_x: float = 600.0  # Coordenada X donde empieza la órbita`
    }
  ]}
/>

**¿Por qué posición X y no distancia recorrida?**

En los shooters clásicos (Galaga, R-Type), el diseñador de niveles colocaba "triggers" en posiciones fijas del mapa. Los enemigos entraban y, al cruzar cierta coordenada, cambiaban de comportamiento.

Esto facilita el diseño: "Quiero que empiecen a orbitar cuando lleguen al centro de la pantalla" → `transition_x = 640` (mitad de 1280px).

> **Nota para el futuro**: Podríamos añadir un modo de transición por distancia recorrida, útil si el SpawnPoint se mueve. Lo dejamos como mejora futura.

### La Lógica de Transición

<CodeTabs
  items={[
    {
      label: 'spawn_point.gd (LINE_TO_ORBIT)',
      lang: 'gdscript',
      code: `# Añadir al enum
enum MovementPattern { LINE, WAVE, ORBIT, LINE_TO_ORBIT }

func _process(delta):
    time += delta
    
    for i in range(enemies.size()):
        var enemy = enemies[i]
        
        if not is_instance_valid(enemy):
            continue
        
        match pattern:
            MovementPattern.LINE:
                move_line(enemy, delta)
            MovementPattern.WAVE:
                move_wave(enemy, i, delta)
            MovementPattern.ORBIT:
                move_orbit(enemy, i)
            MovementPattern.LINE_TO_ORBIT:
                move_line_to_orbit(enemy, i, delta)

func move_line_to_orbit(enemy: Node2D, index: int, delta: float):
    var data = enemy_data[index]
    
    match state:
        SpawnState.ENTERING:
            # Fase 1: Moverse en línea recta
            enemy.position += direction * speed * delta
            
            # Comprobar si hemos llegado al punto de transición
            # Usamos la posición GLOBAL porque el SpawnPoint puede estar en cualquier lugar
            var global_x = global_position.x + enemy.position.x
            
            # Si avanzamos hacia la izquierda, transition_x es el límite inferior
            if direction.x < 0 and global_x <= transition_x:
                start_orbit_transition(index, enemy)
            # Si avanzamos hacia la derecha, es el límite superior
            elif direction.x > 0 and global_x >= transition_x:
                start_orbit_transition(index, enemy)
                
        SpawnState.ORBITING:
            # Fase 2: Orbitar normalmente
            move_orbit(enemy, index)

func start_orbit_transition(index: int, enemy: Node2D):
    # Solo transicionamos una vez
    if state == SpawnState.ORBITING:
        return
    
    # Cambiamos el estado GLOBAL del spawner
    state = SpawnState.ORBITING
    
    # Guardamos el centro de órbita como la posición actual del primer enemigo
    # Esto hace que orbiten alrededor de donde estaban cuando transicionaron
    var orbit_center = enemy.position
    
    # Recalculamos los datos de todos los enemigos para orbitar
    for i in range(enemies.size()):
        if not is_instance_valid(enemies[i]):
            continue
            
        # Calculamos el ángulo inicial basándonos en la posición relativa al centro
        var relative_pos = enemies[i].position - orbit_center
        var initial_angle = atan2(relative_pos.y, relative_pos.x)
        
        enemy_data[i]["phase_offset"] = initial_angle
        enemy_data[i]["orbit_center"] = orbit_center
    
    # Reiniciamos el tiempo para que la órbita empiece desde 0
    time = 0.0`
    }
  ]}
/>

### Desglose del Código

**1. Estados con `SpawnState`:**
```gdscript
enum SpawnState { ENTERING, ORBITING }
var state: SpawnState = SpawnState.ENTERING
```
El spawner empieza en estado `ENTERING` (entrando). Al cruzar `transition_x`, cambia a `ORBITING`.

**2. Detección de transición:**
```gdscript
var global_x = global_position.x + enemy.position.x
if direction.x < 0 and global_x <= transition_x:
```
Calculamos la posición X global del enemigo. Si avanza hacia la izquierda (`direction.x < 0`), la transición ocurre cuando `global_x` cae **por debajo** de `transition_x`.

**3. `atan2()` - Convertir posición a ángulo:**
```gdscript
var initial_angle = atan2(relative_pos.y, relative_pos.x)
```
`atan2(y, x)` es la función inversa de sin/cos. Dado un punto (x, y), devuelve el ángulo en radianes.

| Posición | atan2(y, x) |
|----------|-------------|
| (1, 0) derecha | 0 |
| (0, 1) arriba | π/2 (90°) |
| (-1, 0) izquierda | π (180°) |
| (0, -1) abajo | -π/2 (-90°) |

Esto nos permite que cada enemigo empiece a orbitar **desde donde estaba** cuando ocurrió la transición, en lugar de saltar a una posición calculada.

**4. Centro de órbita dinámico:**
```gdscript
enemy_data[i]["orbit_center"] = orbit_center
```
Guardamos dónde estaba el primer enemigo cuando transicionó. Todos orbitan alrededor de ese punto, no del SpawnPoint original.

### Modificar move_orbit para usar el centro dinámico

<CodeTabs
  items={[
    {
      label: 'spawn_point.gd (move_orbit actualizado)',
      lang: 'gdscript',
      code: `func move_orbit(enemy: Node2D, index: int):
    var data = enemy_data[index]
    
    var angle = time * orbit_speed + data.phase_offset
    
    # Usamos el centro guardado si existe (LINE_TO_ORBIT), si no, (0,0)
    var center = data.get("orbit_center", Vector2.ZERO)
    
    var x = center.x + cos(angle) * orbit_radius_x
    var y = center.y + sin(angle) * orbit_radius_y
    
    enemy.position = Vector2(x, y)`
    }
  ]}
/>

### Probando LINE_TO_ORBIT

1. Crea un `SpawnPoint` a la derecha de la pantalla (ej: X=1100).
2. En el Inspector:
   - **Enemy Scene**: Helicóptero.
   - **Pattern**: `LINE_TO_ORBIT`.
   - **Formation Size**: `5`.
   - **Spawn Spacing**: `50`.
   - **Speed**: `200`.
   - **Direction**: `(-1, 0)`.
   - **Transition X**: `500`.
   - **Orbit Radius X/Y**: `80`.
   - **Orbit Speed**: `2`.
3. Ejecuta (F5).

**Resultado esperado**: Los helicópteros entran en fila desde la derecha. Al cruzar X=500, empiezan a orbitar en círculo alrededor del punto donde el primero llegó.

---

## 4. Script Completo del SpawnPoint

<CodeTabs
  items={[
    {
      label: 'spawn_point.gd (completo)',
      lang: 'gdscript',
      code: `extends Node2D

# --- Enumeraciones ---
enum MovementPattern { LINE, WAVE, ORBIT, LINE_TO_ORBIT }
enum SpawnState { ENTERING, ORBITING }

# --- Configuración General ---
@export var enemy_scene: PackedScene
@export var pattern: MovementPattern = MovementPattern.LINE
@export var formation_size: int = 5
@export var spawn_spacing: float = 60.0

# --- Parámetros LINE/WAVE ---
@export var speed: float = 150.0
@export var direction: Vector2 = Vector2(-1, 0)

# --- Parámetros WAVE ---
@export var wave_amplitude: float = 80.0
@export var wave_frequency: float = 3.0
@export var phase_increment: float = 0.4

# --- Parámetros ORBIT ---
@export var orbit_radius_x: float = 100.0
@export var orbit_radius_y: float = 100.0
@export var orbit_speed: float = 2.0
@export var auto_distribute: bool = true

# --- Parámetros LINE_TO_ORBIT ---
@export var transition_x: float = 600.0

# --- Variables Internas ---
var enemies: Array = []
var enemy_data: Array = []
var time: float = 0.0
var state: SpawnState = SpawnState.ENTERING

func _ready():
    direction = direction.normalized()
    spawn_formation()

func spawn_formation():
    var perpendicular = Vector2(-direction.y, direction.x)
    
    for i in range(formation_size):
        var enemy = enemy_scene.instantiate()
        var data = {}
        
        match pattern:
            MovementPattern.LINE, MovementPattern.WAVE, MovementPattern.LINE_TO_ORBIT:
                var formation_offset = (i - (formation_size - 1) / 2.0) * spawn_spacing
                enemy.position = perpendicular * formation_offset
                data["start_perpendicular_offset"] = formation_offset
                data["distance"] = 0.0
                data["phase_offset"] = 0.0
                
            MovementPattern.ORBIT:
                if auto_distribute:
                    data["phase_offset"] = (2 * PI / formation_size) * i
                else:
                    data["phase_offset"] = i * phase_increment
                
                var angle = data["phase_offset"]
                enemy.position = Vector2(
                    cos(angle) * orbit_radius_x,
                    sin(angle) * orbit_radius_y
                )
        
        enemy_data.append(data)
        enemies.append(enemy)
        call_deferred("add_child", enemy)

func _process(delta):
    time += delta
    
    for i in range(enemies.size()):
        var enemy = enemies[i]
        
        if not is_instance_valid(enemy):
            continue
        
        match pattern:
            MovementPattern.LINE:
                move_line(enemy, i, delta)
            MovementPattern.WAVE:
                move_wave(enemy, i, delta)
            MovementPattern.ORBIT:
                move_orbit(enemy, i)
            MovementPattern.LINE_TO_ORBIT:
                move_line_to_orbit(enemy, i, delta)

func move_line(enemy: Node2D, index: int, delta: float):
    enemy.position += direction * speed * delta

func move_wave(enemy: Node2D, index: int, delta: float):
    var data = enemy_data[index]
    data.distance += speed * delta
    
    var base_position = direction * data.distance
    
    var phase = time * wave_frequency + index * phase_increment
    var wave_offset = sin(phase) * wave_amplitude
    
    var total_perpendicular = data.start_perpendicular_offset + wave_offset
    
    var perpendicular = Vector2(-direction.y, direction.x)
    enemy.position = base_position + perpendicular * total_perpendicular

func move_orbit(enemy: Node2D, index: int):
    var data = enemy_data[index]
    
    var angle = time * orbit_speed + data.phase_offset
    var center = data.get("orbit_center", Vector2.ZERO)
    
    enemy.position = Vector2(
        center.x + cos(angle) * orbit_radius_x,
        center.y + sin(angle) * orbit_radius_y
    )

func move_line_to_orbit(enemy: Node2D, index: int, delta: float):
    var data = enemy_data[index]
    
    match state:
        SpawnState.ENTERING:
            enemy.position += direction * speed * delta
            
            var global_x = global_position.x + enemy.position.x
            
            if direction.x < 0 and global_x <= transition_x:
                start_orbit_transition()
            elif direction.x > 0 and global_x >= transition_x:
                start_orbit_transition()
                
        SpawnState.ORBITING:
            move_orbit(enemy, index)

func start_orbit_transition():
    if state == SpawnState.ORBITING:
        return
    
    state = SpawnState.ORBITING
    
    # El centro de órbita será la posición media de todos los enemigos
    var center = Vector2.ZERO
    var valid_count = 0
    for enemy in enemies:
        if is_instance_valid(enemy):
            center += enemy.position
            valid_count += 1
    center /= valid_count
    
    # Recalculamos datos para orbitar
    for i in range(enemies.size()):
        if not is_instance_valid(enemies[i]):
            continue
        
        var relative_pos = enemies[i].position - center
        enemy_data[i]["phase_offset"] = atan2(relative_pos.y, relative_pos.x)
        enemy_data[i]["orbit_center"] = center
    
    time = 0.0`
    }
  ]}
/>

---

## 5. Tabla de Referencia de Patrones

| Patrón | Enemigo Típico | Parámetros Clave | Resultado Visual |
|--------|----------------|------------------|------------------|
| **LINE** | Avión | `speed`, `direction` | Fila avanzando |
| **WAVE** | Avión | `wave_amplitude`, `phase_increment` | Serpiente ondulante |
| **ORBIT** | Helicóptero | `orbit_radius_x/y`, `orbit_speed` | Círculo/elipse girando |
| **LINE_TO_ORBIT** | Helicóptero | `transition_x` | Entrada → órbita |

---

## Repasemos lo aprendido

1. **Patrón ORBIT**: `cos(angle) * radio` para X, `sin(angle) * radio` para Y.
2. **Distribución equidistante**: `(2 * PI / n) * i` para n enemigos.
3. **Elipse**: Usar radios diferentes en X e Y.
4. **Estados del Spawner**: `enum SpawnState` para manejar transiciones.
5. **Transición por posición X**: Detectar cuándo un enemigo cruza una coordenada.
6. **`atan2(y, x)`**: Convertir una posición cartesiana a un ángulo.
7. **Centro de órbita dinámico**: Guardar dónde ocurrió la transición.

En el **próximo capítulo**, aprenderemos a crear **comportamientos secuenciales**: enemigos que cambian de estado automáticamente (entrar → atacar → huir) usando Enums y Timers.
