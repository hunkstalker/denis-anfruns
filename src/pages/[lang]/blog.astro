---
import BaseLayout from '../../layouts/BaseLayout.astro'
import Nav from '../../components/layout/Nav.astro'
import { type CollectionEntry } from 'astro:content'
import { getBlogPosts, type BlogPost } from '../../utils/blog-content'
import { getLangFromSlug, getBaseSlug, type SupportedLang } from '../../utils/blogi18n'
import { languages } from '../../i18n/ui'
import { useTranslations } from '../../i18n/utils'
import TilAside from '../../components/blog/TilAside.astro'
import DevLogCard from '../../components/blog/DevLogCard.astro'

export async function getStaticPaths() {
	return Object.keys(languages)
		.filter((lang) => lang !== 'es')
		.map((lang) => ({ params: { lang: lang as SupportedLang } }))
}

const { lang } = Astro.params
const rawPosts = (
	await getBlogPosts()
).filter((p) => getLangFromSlug(p.slug) === lang && p.data.pubDate)
const t = useTranslations(lang)

const seriesMap = new Map<string, BlogPost[]>()
const soloPosts: BlogPost[] = []

for (const post of rawPosts) {
	if (post.data.series) {
		const list = seriesMap.get(post.data.series) || []
		list.push(post)
		seriesMap.set(post.data.series, list)
	} else {
		soloPosts.push(post)
	}
}

// Proceso de seriesMap
// La intención es obtener todos los post cabeza de serie para mostrarlos en la página de blog
// 1. Ordenar por fecha de publicación
// 2. Obtener el primer post de cada serie
// 3. Utiliza la fecha de la última publicación (más reciente) para ordenar el feed.
const finalSeriesPosts = Array.from(seriesMap.values()).map((list) => {
	list.sort(
		(a: BlogPost, b: BlogPost) => {
            if (!a.data.pubDate || !b.data.pubDate) {
                return 0
            }
			return a.data.pubDate.valueOf() - b.data.pubDate.valueOf()
        },
	)

	const part1 = list[0]
	const latestPart = list[list.length - 1]

	// Actualizamos la fecha del artículo cabeza de serie para que se muestre por orden en el feed
	const entry = {
		...part1,
		data: {
			...part1.data,
			pubDate: latestPart.data.pubDate,
		},
	}
	return entry
})

const articles = [...soloPosts, ...finalSeriesPosts].sort(
	(a, b) => {
        if (!a.data.pubDate || !b.data.pubDate) {
             return 0
        }
        return b.data.pubDate.valueOf() - a.data.pubDate.valueOf()
    })
---

<BaseLayout siteTitle={t('blog.title')} lang={lang}>
	<Nav lang={lang as 'es' | 'en' | 'ca'} />
	<div class="container mx-auto px-3 py-6 pt-20 sm:px-4 sm:py-8 md:pt-28">
		<div class="grid grid-cols-1 gap-6 sm:gap-8 lg:grid-cols-12 lg:gap-12">
			<!-- Columna principal: DevLogs -->
			<div class="space-y-12 lg:col-span-8">
				<h2
					class="mb-6 flex items-center gap-2 border-b border-zinc-200 pb-2 text-2xl font-bold dark:border-zinc-700 dark:text-zinc-200"
				>
					{t('blog.series')}
				</h2>

				<p class="mb-6 mt-2 text-base text-zinc-500">{t('blog.devLogDescription')}</p>

				{articles.length === 0 && <p class="italic text-zinc-500">{t('blog.withoutArticles')}</p>}

				<div class="grid gap-4 sm:gap-6 lg:gap-8">
					{articles.map((post, index) => <DevLogCard post={post} lang={lang as 'es' | 'en' | 'ca'} delay={index * 100} />)}
				</div>
			</div>

			<!-- Columna lateral: TILs -->
			<TilAside lang={lang} />
		</div>
	</div>
</BaseLayout>
