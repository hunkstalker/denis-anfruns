---
import BaseLayout from '../layouts/BaseLayout.astro'
import Nav from '../components/layout/Nav.astro'

import { getDevlogs, type DevlogPost } from '../utils/devlog-content'
import { getLangFromSlug } from '../utils/blogi18n'
import { useTranslations } from '../i18n/utils'
import TilAside from '../components/blog/TilAside.astro'
import BlogDevLogList from '../components/blog/BlogDevLogList'

const lang = 'es'
const t = useTranslations(lang)
const rawPosts = (await getDevlogs()).filter(
	p => getLangFromSlug(p.slug) === lang && p.data.pubDate,
)

const seriesMap = new Map<string, DevlogPost[]>()
const soloPosts: DevlogPost[] = []

for (const post of rawPosts) {
	if (post.data.series) {
		const list = seriesMap.get(post.data.series) || []
		list.push(post)
		seriesMap.set(post.data.series, list)
	} else {
		soloPosts.push(post)
	}
}

// Proceso de seriesMap
// La intención es obtener todos los post cabeza de serie para mostrarlos en la página de blog
// 1. Ordenar por fecha de publicación
// 2. Obtener el primer post de cada serie
// 3. Utiliza la fecha de la última publicación (más reciente) para ordenar el feed.
const finalSeriesPosts = Array.from(seriesMap.values()).map(list => {
	list.sort((a: DevlogPost, b: DevlogPost) => {
		if (!a.data.pubDate || !b.data.pubDate) {
			return 0
		}
		return a.data.pubDate.valueOf() - b.data.pubDate.valueOf()
	})

	const part1 = list[0]
	const latestPart = list[list.length - 1]

	// Actualizamos la fecha del artículo cabeza de serie para que se muestre por orden en el feed
	const entry = {
		...part1,
		data: {
			...part1.data,
			pubDate: latestPart.data.pubDate,
		},
	}
	return entry
})

const articles = [...soloPosts, ...finalSeriesPosts].sort((a, b) => {
	if (!a.data.pubDate || !b.data.pubDate) {
		return 0
	}
	return b.data.pubDate.valueOf() - a.data.pubDate.valueOf()
})
---

<BaseLayout siteTitle='Jardín Digital' lang={lang}>
	<Nav lang={lang} />
	<div class='container mx-auto px-3 py-6 pt-20 sm:px-4 sm:py-8 md:pt-28'>
		<h3 class="mb-4 text-xs font-bold uppercase tracking-wider text-zinc-500 dark:text-zinc-400 lg:pl-6">{t('blog.recent')}</h3>
		<div class='grid grid-cols-1 gap-6 sm:gap-8 lg:grid-cols-12 lg:gap-12'>
			<!-- Columna principal: DevLogs -->
			<div class='space-y-12 lg:col-span-8'>
				<!-- Contenedor "invisible" para alinear con TilAside (p-0 sm:p-0 mobile / lg:p-6 desktop) -->
				<div class='rounded-xl p-0 lg:border lg:border-transparent lg:p-6'>

					<div class="flex items-center justify-between border-b border-zinc-200 pb-2 dark:border-zinc-700">
						<h2 class='text-xl font-bold dark:text-zinc-200'>
							DevLogs
						</h2>
						<a href="/devlog/" class="group flex items-center gap-1 text-sm font-medium text-zinc-500 transition-colors hover:text-zinc-900 dark:hover:text-[--tangerine]">
							{t('blog.viewAll')}
							<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="transition-transform group-hover:translate-x-1"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg>
						</a>
					</div>

					<p class="mb-6 mt-2 text-base text-zinc-500">{t('blog.devLogDescription')}</p>

					{articles.length === 0 && <p class='italic text-zinc-500'>No hay DevLogs todavía.</p>}

					<BlogDevLogList 
						client:load 
						posts={articles} 
						lang={lang} 
						labels={{ readArticle: t('blog.readArticle') }}
                        layout='list'
					/>
				</div>
			</div>

			<!-- Columna lateral: TILs -->
			<TilAside lang={lang} limit={6} />
		</div>
	</div>
</BaseLayout>
